<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Congzhi's Notes Vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://congzhi.wiki/</link><image><url>https://congzhi.wiki/lib/media/favicon.png</url><title>Congzhi's Notes Vault</title><link>https://congzhi.wiki/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 26 Mar 2025 20:54:25 GMT</lastBuildDate><atom:link href="https://congzhi.wiki/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 26 Mar 2025 20:54:21 GMT</pubDate><copyright><![CDATA[Congzhi]]></copyright><ttl>60</ttl><dc:creator>Congzhi</dc:creator><item><title><![CDATA[1. Compilation]]></title><description><![CDATA[ 
 <br><br><br>在本节，我们将讨论 GCC 是如何一步一步地将 C/C++ 语言源代码编译成二进制机器语言的。也就是 C/C++ 代码是如何变成 ELF 的。<br><br>在编译 C/C++ 时，我们常常使用 GCC 作为我们的编译器。GCC 并不是 GNU C Compiler， GCC 是一系列编译器的集合。不仅仅支持 C 语言，还支持 C++ 、 D 、 Objective-C  、 Go 等其他的编程语言。你可以用 gcc -v 来查看你的 GCC 支持哪些语言。<br><br>我们把程序从源代码到可执行文件的过程分为两步——编译和链接。在本节，我们将会学习程序是如何编译的。我们把编译的过程共分为 3 步，分别是预处理、编译和汇编。我们先来从机器的视角观察 C/C++ 源代码是怎么样的。<br><br>这是一个最简单的例子。这是一段源代码，我将其存放到 hello.c 文件中。我们在文件中输入的所有指令都是 human-friendly 的，而计算机是没有办法理解这个文本文件到底写了什么的。<br>#include &lt;stdio.h&gt;
int main(){
	printf("hello, world\n"); // This prints "hello, world\n"
}
<br>这段源代码以文本文件的形式存储在磁盘上，它在计算机眼中就是这样的：<br>#include&lt;stdio.h&gt; int main(){printf("hello, world\n");//This prints "hello, world\n"}

<br>而实际上计算机存储的只有 0 和 1 构成的二进制数，如果将这些 ASCII 字符转换成 16 进制的二进制数，就是这样：<br>23696e636c7564653c737464696f2e683e20696e74206d61696e28297b7072696e7466282268656c6c6f2c20776f726c645c6e22293b2f2f54686973207072696e7473202268656c6c6f2c20776f726c645c6e22227d
<br><br>我们有源程序后，我们需要“翻译”这段程序，让计算机能够理解我们想要表达的意思，这个过程就是编译。而编译的第一步，就是预处理。<br>我们用下面的 shell 指令对程序进行预处理：<br>gcc -E hello.c -o hello.i
cpp hello.c &gt; hello.i
<br>完成后，编译器就会生成一个 .i 文件，即中间文件(intermediate file)。那么预处理的作用是什么呢？我们把这一步骤叫做预处理，把预处理完成所得到的文件叫中间文件。不难想到，预处理阶段是程序正式进行编译的临门一脚。预处理阶段的作用是处理源文件中以 # 开头的语句。即：<br>
<br>删除 #define 并展开其所定义的宏。
<br>处理所有条件预编译指令，如 #if、#ifdef、#endif等。
<br>插入头文件到#include处，可以递归方式进行处理（复制粘贴）。
<br>删除注释（可选择保留）。
<br>添加行标记和文件名标识。
<br>保留#pragma编译指令（编译用）。
<br>如果你打开 .i 文件，你会发现一些函数的声明、一些系统信息......各种乱七八糟的东西，这就是因为我们将头文件插入（粘贴）到 #include 的地方了。但总体上，中间文件还是可读的。只不过是将文件进行了一些加工。在中间文件中，你仍然会看到：<br>int main(){
	printf("hello, world\n"); // Why this are not causing error?
}
<br>此外，你还会看到 printf 的函数声明，这也解释了为什么你的程序不会报错。<br>extern int printf (const char *__restrict __format, ...);
<br>在 C/C++ 中，我们指预处理完成后的 .i （.ii in C++）文件为一个个的翻译单元。<br><br>我们发现，预处理完成后，我们实际上得到的仍然是高级语言源程序。要将它编程机器可读的二进制程序，编译这一步至关重要。编译过程通过把预处理文件中的高级语言代码进行词法分析、语法分析、语义分析和优化后生成汇编代码文件。狭义上，我们把进行编译处理的程序就叫编译器。<br>我们用如下的命令可将程序编译为可读的汇编代码文件。<br>gcc -S hello.i -o hello.s
gcc -S hello.c -o hello.s
/user/lib/gcc/xxxx-linux-gnu/4.1/cc1 hello.c
<br>尽管汇编代码仍是文本，机器无法理解这些代码，但是汇编代码和二进制机器语言代码实际上是一一对应的。你可以把 C/C++ 这种高级语言理解为在汇编语言上的进一步封装/抽象，编译器就是提供这种抽象的核心工具。<br>一般而言，高级语言都是机器无关的(machine-independent)。但是编译器可以将机器无关的高级语言转换成机器相关的汇编。在 x86 的机器上，编译器会将高级语言源程序编译为 x86 汇编，在 ARM 上，编译器会将高级语言程序编译成 ARM 汇编。<br>硬件--&gt;（封装抽象）ISA--&gt;（封装抽象）汇编语言--&gt;（封装抽象）高级语言程序<br>此外，由于高级语言（标准库函数）提供对操作系统的屏蔽和封装，编译器的运行可能还会依赖操作系统。<br><br>机器汇编语言被称为低级语言，相比高级语言，汇编语言和机器的二进制指令之间的对应关系非常紧密。也就是说，不同机器架构上使用的汇编语言是不一样的。你可以用下面的指令得到可重定位目标文件。也就是 .o 文件，即目标文件。<br>gcc –c hello.s –o hello.o
gcc –c hello.c –o hello.o
as hello.s -o hello.o
<br>生成的目标文件中，除了汇编得到的机器码（01数据）之外，还包含元数据。在链接过程中，这些选数据会供链接器使用以完成可执行文件的生成。这些元数据我们在下一节介绍。<br>至此，广义上的编译就算完成了。]]></description><link>https://congzhi.wiki/building-and-version-control/1.-compilation.html</link><guid isPermaLink="false">Building and Version Control/1. Compilation.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:24:59 GMT</pubDate></item><item><title><![CDATA[2. Linking]]></title><description><![CDATA[ 
 <br><br>.o文件中包含一系列的01数据和元数据（链接器用与重定义和。。。）元数据指明了当前的object file定义了那些符号声明了那些符号<br>这些01数据以一定的格式（数据段/bss/代码段)存储，这些格式也作为元数据存储在.o文件中<br>
.o文件是机器指令，实际上可以放到机器上运行了，但是我们上节课也看到，有的符号定义可能在其他的翻译单元（external reference)，也就是为什么在Linux中，我们把.o文件成为.elf，链接后的文件格式仍然是.elf。但是视角不同了。链接器的职责就是将符号的外部引用替换到。。。（place the placeholder of external reference to an address）<br>one definition rule(ODR): ambitious, which one to call<br>生成可执行文件后：<br>
-ldd prog （查看动态链接库）<br>objdump -g 添加debug信息<br>为什么我不需要链接C的动态链接库来运行程序？我直接用 ./proc？甚至用pthread库我也可以./proc而不是 ./proc -lpthread<br>-L来寻找库路径（默认会在 PATH 中去寻找，PATH 有很多（和环境变量的关系呢？<br>
-I 是干嘛的？如果找不到，那么就在这里找<br>当使用&lt;&gt;时，就会去system path中寻找（include path<br>
echo $PATH]]></description><link>https://congzhi.wiki/building-and-version-control/2.-linking.html</link><guid isPermaLink="false">Building and Version Control/2. Linking.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 20:52:34 GMT</pubDate></item><item><title><![CDATA[3. Building System and Makefile]]></title><description><![CDATA[ 
 <br>Source: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=DtGrdB8wQ_8&amp;t=14s" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=DtGrdB8wQ_8&amp;t=14s" target="_blank">Makefiles: 95% of what you need to know</a><br>what is a building system do?<br>
<br>自动地进行文件的编译和链接，将各个文件变成一个可执行文件。通过构建系统，你可以直观地体会到整个项目是如何编译并链接的，各个文件之间的联系是什么。
<br>应当只完成必要的：也就是说当文件（依赖项）有修改时，重新编译这些修改过的文件并链接。可以省去全部编译所产生的时间。也就是说你不需要重新编译所有的代码，用 shell bash 就需要整个的进行编译。当项目非常大时，你可能需要数个小时进行编译，而用makefile，你只需要编译需要的
<br>同时，build system 应当有一定的规约（一种编程语言，比如用shell script）使得整个构建系统易于上手
<br>一个简单的makefile.   前面的都是变量，直到 all: <br>CC=gcc # complier variable
INCDIRS=-I # 
OPT=-O0 # optimization variable
CFLAGS=-Wall -Wextra -g $(INCDIRS) $(OPT)

CFLAGS=x.c y.c
OBJECTS=x.o y.o

BINARY=bin

all: $(BINARY)

$(BINARY): $(OBJECTS)
		$(CC) -o $@ $^
%.o:%.c # make feature, % is a wildcard (repersenting everything)
		$(CC) $(CFLAGS) -c -o $@ $^
clean:
		rm -rf $(BINARY) $(OBJECTS)
<br>build rule: all: $(BINARY) 就是一个build rule（这里的target和dependencies有何联系？）<br>
all directive, 当你用make all就会转到makefile中的 （默认情况下只用 make 会转到第一个 rule）<br>上面的makefile的意思就是说当你在终端 make all 的时候，你就会转到 $(BINARY): $(OBJECTS)。但是BINARY depends on OBJECTS，也就是你要构建bin你就需要先得到所有的 .o 文件。如果没有，就会执行 %.o:%.c (.o 文件 依赖 .c 文件) @ 表示 LHS (.o) ^表示RHS (.c)<br>target: dependencies 如果所有依赖项都满足就执行 command
		command
<br>即使你有 x.o 如果你修改了源文件，make 一个新的 x.o 将会被编译(build system的第二个事情，只做需要的事情)<br>需要先介绍不用variable会怎么样。<br>用variable之后makefile才会做需要做的事情吗？<br>如果头文件修改，makefile不会察觉到有什么修改了（因为.h没有依赖项<br>第三个例子： featureful makefile---我们将头文件都放在include文件夹中，将库放到lib文件夹中。我们将include作为依赖项，当我们修改.h文件时，makefile就能够察觉到有东西被修改了<br>BINARY=bin
CODEDIR=. lib
INCDIRS=. ./include/ # can be listed

CC=gcc
OPT=-O0
# generate files that encode make rules for the .h dependencies
DEPFLAGS=-MP -MD # let make work with compiler?是这样么
CFLAGS=-Wall -Wextra -g $(foreach D, $(INCDIRS),-I$(D) $(OPT) $(DEPFLAGS))

CFILES=$(foreach D,$(CODEDIRS),$(wildcard $(D)/*.c))

OBJECTS=$(patsubst %.c,%.o,%(CFILES))
DEPFILES=$(patsubst %.c,%.d,%(CFILES))

all: $(BINARY)

$(BINARY): $(OBJECT)
		$(CC) -o $@ $^

%.o:%.c # make feature, % is a wildcard (repersenting everything)
		$(CC) $(CFLAGS) -c -o $@ $&lt; # only want .c dependency here thus $&lt;
clean:
		rm -rf $(BINARY) $(OBJECTS) $(DEPFILES)

distribute: clean
		tar zcvf dist.tgz *

diff
# include the dependency
-include $(DEPFILES)
<br><img alt="Pasted image 20250322033111.png" src="https://congzhi.wiki/lib/media/pasted-image-20250322033111.png"><br>依赖项 (dependencies)<br># GCC flags first
target [targets...]: [components...]
	[ command 1]
	# ...
	[ command n]
<br>special commands<br>-
@
+
<br>macros and variables<br>MACRO1 = 12
COMPILE = gcc *.c

gcc:
	$(COMPILE)
<br>multi line commands<br>
在makefile中，每行命令都默认允许在一个独立的shell终端中，也就是说在 Badlisting 中<br>
如果需要多个命令共享同一个上下文（例如切换目录后运行操作），需要将它们合并到一个 Shell 会话中，通常使用反斜杠 \ 或 &amp;&amp;<br>
分号用于在同一行中分隔多个命令。例如：<br>Badlisting:
	cd dir
	ls
Goodlisting:
	cd dir;\ # same as cd dir &amp;&amp; ls
	ls
<br>makefile 也可以用于 testing<br><br>makefile的好处就是只编译修改了的.c/.cpp文件并生成修改后的.o文件。节省编译时间。一个标准的makefile可能是这样的：<br>CC = gcc
INCDIRS = -I.
OPT = -O0
CFLAGS = -Wall -Wextra -g $(INCDIRS) $(OPT)

CFILES = 
OBJECTS = 
BINARY = 

all: $(BINARY)

clean:


random:
	date
	sl
	mkdir useless
	cd useless ;\
	cd..
<br>all: # all 是干嘛的？

help: #这些是按照顺序执行的么

<br>CC = GCC
all:
	$(CC) file.c -o proj
debug:
debug: CC += -g -DDEBUG
<br><br>在构建系列的<br>头文件：存放声明和内联化的函数/变量（constexpr/consteval...）declarations<br>因为内联后的符号没有定义<br>These files contain declarations and inline functions/variables. For example, constexpr and consteval declarations are often found in header files. Declarations inform the compiler about the existence and type of functions or variables without providing the full implementation.<br>Source Files (源文件): These files contain definitions. A definition is a specific type of declaration that provides complete information about an entity, including its implementation.<br>foo.h<br>int foo(int n); //A declaration, no function body.
extern int e; // A non-defining declaration.
<br>foo.cpp<br>#include "foo.h"

int foo(int n) // A definition, we have the function body after this.
{
    // Function implementation goes here.
}
int a; // Definition without initialization
int b = 10; // Definition with initialization
static int c = 10; // A file-scope static definition
extern int d = 10;
<br>other.cpp<br>int e = 10; // 
<br>源文件中存放definitions， definition is a specific type of declaration. Definition gives a set of informations about the entity but no verse visa<br>ProjectName/
├── include/              # Header file
│   ├── main.h
│   └── utils.h
├── src/                  # Source file
│   ├── main.cpp
│   └── utils.cpp
├── lib/                  # Libraries
│   └── mylib.a
├── build/                # Object files
│   └── (object files, executables)
├── tests/                # Testing code
│   └── test_main.cpp
├── CMakeLists.txt        # CMake build file
├── Makefile              # Makefile build file
└── README.md             # Intro to the project

<br>这节课用建立 shell 文件构建代码<br>gcc ....
gcc ....

gcc x.o y.o -o bin
<br>用上面的方法的劣势就是每次构建都需要整个的编译，而不是选择性编译<br>下节课用 makefile]]></description><link>https://congzhi.wiki/building-and-version-control/3.-building-system-and-makefile.html</link><guid isPermaLink="false">Building and Version Control/3. Building System and Makefile.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 08:49:58 GMT</pubDate><enclosure url="https://congzhi.wiki/lib/media/pasted-image-20250322033111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/lib/media/pasted-image-20250322033111.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4. CMake]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/building-and-version-control/4.-cmake.html</link><guid isPermaLink="false">Building and Version Control/4. CMake.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sat, 15 Mar 2025 09:27:52 GMT</pubDate></item><item><title><![CDATA[Building and Version Control]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br>一当 <a data-href="Building and Version Control" href="https://congzhi.wiki/building-and-version-control/building-and-version-control.html" class="internal-link" target="_self" rel="noopener nofollow">Building and Version Control</a> 系列完成， <a data-href="进程的一生——从出生到死亡 (Abandoned)" href="https://congzhi.wiki/some-notes/进程的一生——从出生到死亡-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">进程的一生——从出生到死亡 (Abandoned)</a> 将被彻底废除。其所有关于进程如何出生的内容将会在本系列中重制，其他内容请参阅操作系统系列。<br>在这个系列中，我想系统地探讨探讨 C/C++ 的代码构建方面的知识。我们会聊到一段文本（高级语言）是如何变成 01序列（机器语言）在 CPU 上运行的。同时，我们牵扯到一些 Git 版本控制的简单知识。本系列不会太深入。<br>系列目录如下：<br>Building and Version Control

<br><a data-href="1. Compilation" href="https://congzhi.wiki/building-and-version-control/1.-compilation.html" class="internal-link" target="_self" rel="noopener nofollow">1. Compilation</a>
<br><a data-href="2. Linking" href="https://congzhi.wiki/building-and-version-control/2.-linking.html" class="internal-link" target="_self" rel="noopener nofollow">2. Linking</a>
<br><a data-href="3. A Normal Project Structure" href="https://congzhi.wiki/3. A Normal Project Structure" class="internal-link" target="_self" rel="noopener nofollow">3. A Normal Project Structure</a>
<br><a data-href="3. Building System and Makefile" href="https://congzhi.wiki/building-and-version-control/3.-building-system-and-makefile.html" class="internal-link" target="_self" rel="noopener nofollow">3. Building System and Makefile</a>
<br><a data-href="4. CMake" href="https://congzhi.wiki/building-and-version-control/4.-cmake.html" class="internal-link" target="_self" rel="noopener nofollow">4. CMake</a>
<br><a data-href="5. Release Build and Debug Build" href="https://congzhi.wiki/building-and-version-control/5.-release-build-and-debug-build.html" class="internal-link" target="_self" rel="noopener nofollow">5. Release Build and Debug Build</a>
<br><a data-href="Git and Github (Part I)" href="https://congzhi.wiki/building-and-version-control/git-and-github-(part-i).html" class="internal-link" target="_self" rel="noopener nofollow">Git and Github (Part I)</a>

<br><br><br>任何问题都可以通过 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。]]></description><link>https://congzhi.wiki/building-and-version-control/building-and-version-control.html</link><guid isPermaLink="false">Building and Version Control/Building and Version Control.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:31 GMT</pubDate></item><item><title><![CDATA[C Plus Plus]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br>This series will document my C++ learning path from zero to hero. A big part of these notes are inspired by Mr. Mike, all the learning resources are listed below:<br>
这个系列用于记录我学习 C++ 的进化之路。参考资料来源如下：<br>
<br><a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/" target="_blank">cppreference.com</a>
<br><a data-tooltip-position="top" aria-label="https://www.learncpp.com/" rel="noopener nofollow" class="external-link" href="https://www.learncpp.com/" target="_blank">Learn C++</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/@CppCon" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/@CppCon" target="_blank">CppCon C++ Talks</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/@MikeShah/playlists" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/@MikeShah/playlists" target="_blank">Mr. Mike Shah's C++ Series</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/@TheCherno/playlists" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/@TheCherno/playlists" target="_blank">The Cherno's C++ Series</a>
<br>...
<br>一些好用的工具：<br>
<br><a data-tooltip-position="top" aria-label="https://godbolt.org/" rel="noopener nofollow" class="external-link" href="https://godbolt.org/" target="_blank">Compiler Explorer</a>
<br><a data-tooltip-position="top" aria-label="https://cppinsights.io/" rel="noopener nofollow" class="external-link" href="https://cppinsights.io/" target="_blank">C++ Insights</a>
<br><br><br>由于大多数学习资料的源内容都以英文形式呈现，所以部分笔记的撰写将用英文完成。这些英文笔记通常比较简短（我会尝试完成一些英文长笔记），但对于理解这些 C++ 知识应当是足够的。目前，我所有的 C++ 笔记罗列如下：<br>C++ 中文笔记 (NC stands for Not Covered, 37 notes in total)：

<br><a data-href="Assert in C++ (NC)" href="https://congzhi.wiki/c-plus-plus/assert-in-c++-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Assert in C++ (NC)</a>
<br><a data-href="Auto in C++" href="https://congzhi.wiki/c-plus-plus/auto-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Auto in C++</a>
<br><a data-href="Casting in C++ (NC)" href="https://congzhi.wiki/c-plus-plus/casting-in-c++-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Casting in C++ (NC)</a>
<br><a data-href="Character Literal &amp; String Literal in C++" href="https://congzhi.wiki/c-plus-plus/character-literal-&amp;-string-literal-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Character Literal &amp; String Literal in C++</a>
<br><a data-href="Concurrency in C++" href="https://congzhi.wiki/c-plus-plus/concurrency-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Concurrency in C++</a>
<br><a data-href="Const in C++" href="https://congzhi.wiki/c-plus-plus/const-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Const in C++</a>
<br><a data-href="Copying and Copy Constructors in C++" href="https://congzhi.wiki/c-plus-plus/copying-and-copy-constructors-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Copying and Copy Constructors in C++</a>
<br><a data-href="Decltype in C++" href="https://congzhi.wiki/c-plus-plus/decltype-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Decltype in C++</a>
<br><a data-href="Exception Control in C++ (NC)" href="https://congzhi.wiki/c-plus-plus/exception-control-in-c++-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Exception Control in C++ (NC)</a>
<br><a data-href="Extern Keyword in C++" href="https://congzhi.wiki/c-plus-plus/extern-keyword-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Extern Keyword in C++</a>
<br><a data-href="Forwarding in C++" href="https://congzhi.wiki/c-plus-plus/forwarding-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Forwarding in C++</a>
<br><a data-href="Function Pointers in C++ (Examples)" href="https://congzhi.wiki/c-plus-plus/function-pointers-in-c++-(examples).html" class="internal-link" target="_self" rel="noopener nofollow">Function Pointers in C++ (Examples)</a>
<br><a data-href="Functions in Standard Library (Examples)" href="https://congzhi.wiki/c-plus-plus/functions-in-standard-library-(examples).html" class="internal-link" target="_self" rel="noopener nofollow">Functions in Standard Library (Examples)</a>
<br><a data-href="Generics Programming in C++" href="https://congzhi.wiki/c-plus-plus/generics-programming-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Generics Programming in C++</a>
<br><a data-href="Inheritance in C++" href="https://congzhi.wiki/c-plus-plus/inheritance-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Inheritance in C++</a>
<br><a data-href="Integer Literal &amp; Float Literal in C++" href="https://congzhi.wiki/c-plus-plus/integer-literal-&amp;-float-literal-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Integer Literal &amp; Float Literal in C++</a>
<br><a data-href="Lambdas in C++" href="https://congzhi.wiki/c-plus-plus/lambdas-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Lambdas in C++</a>
<br><a data-href="Memory Management in C++ (Abandoned)" href="https://congzhi.wiki/c-plus-plus/memory-management-in-c++-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">Memory Management in C++ (Abandoned)</a>
<br><a data-href="Move Semantics in C++" href="https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Move Semantics in C++</a>
<br><a data-href="Networking - CS model" href="https://congzhi.wiki/c-plus-plus/networking-cs-model.html" class="internal-link" target="_self" rel="noopener nofollow">Networking - CS model</a>
<br><a data-href="Object Oriented Programming in C++" href="https://congzhi.wiki/c-plus-plus/object-oriented-programming-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Object Oriented Programming in C++</a>
<br><a data-href="Part1：C++11 (Abandoned)" href="https://congzhi.wiki/c-plus-plus/part1：c++11-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">Part1：C++11 (Abandoned)</a>
<br><a data-href="Part2：Class (Abandoned)" href="https://congzhi.wiki/c-plus-plus/part2：class-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">Part2：Class (Abandoned)</a>
<br><a data-href="Program Arguments Handling in C++" href="https://congzhi.wiki/c-plus-plus/program-arguments-handling-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Program Arguments Handling in C++</a>
<br><a data-href="RAII and Scope in C++" href="https://congzhi.wiki/c-plus-plus/raii-and-scope-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">RAII and Scope in C++</a>
<br><a data-href="Smart Pointers in C++" href="https://congzhi.wiki/c-plus-plus/smart-pointers-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Smart Pointers in C++</a>
<br><a data-href="Standard Variant in C++" href="https://congzhi.wiki/c-plus-plus/standard-variant-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Standard Variant in C++</a>
<br><a data-href="Static Keyword in C++" href="https://congzhi.wiki/c-plus-plus/static-keyword-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Static Keyword in C++</a>
<br><a data-href="STL in C++ (Pre-Part)" href="https://congzhi.wiki/c-plus-plus/stl-in-c++-(pre-part).html" class="internal-link" target="_self" rel="noopener nofollow">STL in C++ (Pre-Part)</a>
<br><a data-href="STL Container - Standard Array in C++" href="https://congzhi.wiki/c-plus-plus/stl-container-standard-array-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">STL Container - Standard Array in C++</a>
<br><a data-href="STL Container - Standard Vector in C++" href="https://congzhi.wiki/c-plus-plus/stl-container-standard-vector-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">STL Container - Standard Vector in C++</a>
<br><a data-href="STL Container - Standard Span Since C++20" href="https://congzhi.wiki/c-plus-plus/stl-container-standard-span-since-c++20.html" class="internal-link" target="_self" rel="noopener nofollow">STL Container - Standard Span Since C++20</a>
<br><a data-href="String Library in C++" href="https://congzhi.wiki/c-plus-plus/string-library-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">String Library in C++</a>
<br><a data-href="The Rule of Five in C++" href="https://congzhi.wiki/c-plus-plus/the-rule-of-five-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">The Rule of Five in C++</a>
<br><a data-href="Unions in C++" href="https://congzhi.wiki/c-plus-plus/unions-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Unions in C++</a>
<br><a data-href="Virtual Dispatch in C++" href="https://congzhi.wiki/c-plus-plus/virtual-dispatch-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Virtual Dispatch in C++</a>
<br><a data-href="Volatile Specifier in C++ (Questioning)" href="https://congzhi.wiki/c-plus-plus/volatile-specifier-in-c++-(questioning).html" class="internal-link" target="_self" rel="noopener nofollow">Volatile Specifier in C++ (Questioning)</a>

<br>Current existing C++ English notes are listed down below:<br>C++ English Notes: (29 notes in total)

<br><a data-href="Alignment in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/alignment-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Alignment in C++ (ENG)</a>
<br><a data-href="ASLR for Safety (ENG)" href="https://congzhi.wiki/c-plus-plus/aslr-for-safety-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">ASLR for Safety (ENG)</a>
<br><a data-href="Call Stack in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/call-stack-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Call Stack in C++ (ENG)</a>
<br><a data-href="Constexpr in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/constexpr-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Constexpr in C++ (ENG)</a>
<br><a data-href="Consteval in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/consteval-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Consteval in C++ (ENG)</a>
<br><a data-href="Constinit in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/constinit-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Constinit in C++ (ENG)</a>
<br><a data-href="Delegating Constructors in C++ (ENG, NC)" href="https://congzhi.wiki/c-plus-plus/delegating-constructors-in-c++-(eng,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Delegating Constructors in C++ (ENG, NC)</a>
<br><a data-href="Explicit Specifier in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/explicit-specifier-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Explicit Specifier in C++ (ENG)</a>
<br><a data-href="Friend Keyword in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/friend-keyword-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Friend Keyword in C++ (ENG)</a>
<br><a data-href="Inline in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/inline-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Inline in C++ (ENG)</a>
<br><a data-href="Malloc in C (ENG)" href="https://congzhi.wiki/c-plus-plus/malloc-in-c-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Malloc in C (ENG)</a>
<br><a data-href="Member Initializer List in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/member-initializer-list-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Member Initializer List in C++ (ENG)</a>
<br><a data-href="Mutable and The M&amp;M Rule in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/mutable-and-the-m&amp;m-rule-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Mutable and The M&amp;M Rule in C++ (ENG)</a>
<br><a data-href="Namespaces in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/namespaces-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Namespaces in C++ (ENG)</a>
<br><a data-href="Noexcept in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/noexcept-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Noexcept in C++ (ENG)</a>
<br><a data-href="Operator Overloading in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/operator-overloading-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Operator Overloading in C++ (ENG)</a>
<br><a data-href="Parameter Pack in C++ (ENG, NC)" href="https://congzhi.wiki/c-plus-plus/parameter-pack-in-c++-(eng,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Parameter Pack in C++ (ENG, NC)</a>
<br><a data-href="Preprocessor in C++ (Part I, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-i,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part I, NC)</a>
<br><a data-href="Preprocessor in C++ (Part II, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-ii,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part II, NC)</a>
<br><a data-href="Preprocessor in C++ (Part III, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-iii,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part III, NC)</a>
<br><a data-href="Preprocessor in C++ (Part IV, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-iv,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part IV, NC)</a>
<br><a data-href="Preprocessor in C++ (Part V, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-v,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part V, NC)</a>
<br><a data-href="Preprocessor in C++ (Part VI, NC)" href="https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-vi,-nc).html" class="internal-link" target="_self" rel="noopener nofollow">Preprocessor in C++ (Part VI, NC)</a>
<br><a data-href="Standard Array Basics (ENG)" href="https://congzhi.wiki/c-plus-plus/standard-array-basics-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Standard Array Basics (ENG)</a>
<br><a data-href="Static Dispatch in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/static-dispatch-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Static Dispatch in C++ (ENG)</a>
<br><a data-href="The pIMPL Idiom in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/the-pimpl-idiom-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">The pIMPL Idiom in C++ (ENG)</a>
<br><a data-href="This Keyword in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/this-keyword-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">This Keyword in C++ (ENG)</a>
<br><a data-href="Typename Keyword in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/typename-keyword-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Typename Keyword in C++ (ENG)</a>
<br><a data-href="Using Keyword in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/using-keyword-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Using Keyword in C++ (ENG)</a>

<br><br><br>才疏学浅，笔记内容可能不会过于深入，欢迎批评指正、交流学习。如果有发现任何疑问、错误和错别字问题，欢迎在邮箱 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。]]></description><link>https://congzhi.wiki/c-plus-plus/c-plus-plus.html</link><guid isPermaLink="false">C Plus Plus/C Plus Plus.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:24 GMT</pubDate></item><item><title><![CDATA[Call Stack in C++ (ENG)]]></title><description><![CDATA[ 
 <br>Learn more at: <a data-tooltip-position="top" aria-label="https://www.icourse163.org/learn/NJU-1001625001?tid=1472100484#/learn/content?type=detail&amp;id=1257458503&amp;cid=1291031865" rel="noopener nofollow" class="external-link" href="https://www.icourse163.org/learn/NJU-1001625001?tid=1472100484#/learn/content?type=detail&amp;id=1257458503&amp;cid=1291031865" target="_blank">计算机系统基础(一)：第七周<em></em>中国大学MOOC(慕课)</a>过程调用概述<br>
<br><a data-tooltip-position="top" aria-label="Call Stack" data-href="#Call Stack" href="https://congzhi.wiki/about:blank#Call_Stack" class="internal-link" target="_self" rel="noopener nofollow">Call Stack</a>
<br><a data-tooltip-position="top" aria-label="An Easy Example" data-href="#An Easy Example" href="https://congzhi.wiki/about:blank#An_Easy_Example" class="internal-link" target="_self" rel="noopener nofollow">An Easy Example</a>
<br><a data-tooltip-position="top" aria-label="Under the Hood" data-href="#Under the Hood" href="https://congzhi.wiki/about:blank#Under_the_Hood" class="internal-link" target="_self" rel="noopener nofollow">Under the Hood</a>
<br><a data-tooltip-position="top" aria-label="Copy and Reference" data-href="#Copy and Reference" href="https://congzhi.wiki/about:blank#Copy_and_Reference" class="internal-link" target="_self" rel="noopener nofollow">Copy and Reference</a>
<br><a data-tooltip-position="top" aria-label="Pass by Value or Pass by Const Reference?" data-href="#Pass by Value or Pass by Const Reference?" href="https://congzhi.wiki/about:blank#Pass_by_Value_or_Pass_by_Const_Reference" class="internal-link" target="_self" rel="noopener nofollow">Pass by Value or Pass by Const Reference?</a>
<br><a data-tooltip-position="top" aria-label="Parameter Passing Rule in 64-Bit Machine (AI Generated)" data-href="#Parameter Passing Rule in 64-Bit Machine (AI Generated)" href="https://congzhi.wiki/about:blank#Parameter_Passing_Rule_in_64-Bit_Machine_(AI_Generated)" class="internal-link" target="_self" rel="noopener nofollow">Parameter Passing Rule in 64-Bit Machine (AI Generated)</a>
<br><br>The call stack, also known as the execution stack or just the stack if you will, is a crucial component for running your program. Before we dive deep, it's important to understand the process memory layout. If you're not familiar with it, check the linked resources above.<br>When you call a function, the system sets aside some space in the stack memory for the function to do its necessary work. These chunks of space or memory are often called "stack frames" or "function frames." The purpose of the call stack is to manage the way procedures or functions call each other and pass parameters.<br>Each thread has its own call stack, also known as stack memory.<br><br>Let's learn how a function stack frame is formed and what's inside a frame using the code below:<br>int add(int x, int y){
	return x + y;
}
int main(){
	int a = 32;
	int b = 64;
	int sum = add(a, b);
}
<br>Here's what happens:<br>
<br>The main() function is called first, and its function frame is created.    
<br>The add() function is called by main(), and its function frame is added to the stack.
<br>After the add() function finishes executing, its function frame is popped off the stack, returning control to main().
<br>The main() finishes executing, the program finishes.
<br><img alt="call_stack.png" src="https://congzhi.wiki/c-plus-plus/pics/call_stack.png"><br><br>We now understand how stack frames are pushed and popped. Next, let's delve into what is inside the stack frame. We'll compile the code above into assembly language to examine the details. For this purpose, I'll use GCC with the -m32 option here, because on a 64-bit machine, parameters are typically passed using registers rather than the stack.<br>Here's the assembly:<br>_Z3addii:
    pushl   %ebp
    movl    %esp, %ebp
    movl    8(%ebp), %edx
    movl    12(%ebp), %eax
    addl    %edx, %eax          ; &lt;&lt;&lt;&lt;&lt; Calling add()
    popl    %ebp
    ret ; Return address -&gt; EIP
main:
    pushl   %ebp
    movl    %esp, %ebp
    subl    $16, %esp
    movl    $32, -12(%ebp)
    movl    $64, -8(%ebp)
    pushl   -8(%ebp)
    pushl   -12(%ebp)
    call    _Z3addii            ; &lt;&lt;&lt;&lt;&lt; Before calling add()
    addl    $8, %esp
    movl    %eax, -4(%ebp) ; &lt;- Next instruction address
    movl    $0, %eax            ; &lt;&lt;&lt;&lt;&lt; After calling add()
    leave
    ret
<br>Okay, in assembly, you would always see the annoying base pointer register (ebp in this case) and stack pointer register (esp in this case). But don't worry, you'll get there.<br>
<img alt="Stack_under_the_hood.png" src="https://congzhi.wiki/c-plus-plus/pics/stack_under_the_hood.png"><br>
Before calling add(), main() forms its stack frame using ebp and esp. It first saves the old base pointer using a pushl instruction, and then sets the new ebp to point to the old ebp, creating the base of the stack frame. After that, space is allocated on the stack for local variables. Then, the passing parameters are pushed, and add() is called.<br>When the call instruction is executed, a return address is automatically pushed into the stack frame. In the add() function, a new stack frame is formed using pushl %ebp and movl %esp, %ebp. After the calculation is done, the return value is passed back via eax. The frame is then cleaned up with popl %ebp.<br>After the frame is cleaned up, the return address is instantly passed to eip, which points to the next instruction address of call _Z3addii. The stack space allocated for passing parameters is then cleaned up. Finally, the return value 0 is set, and the stack is further cleaned up.<br><br>From the above, we have seen that passing parameters involves copying them to the stack (32-bit machine). If the object is large, this copying can be quite costly in terms of CPU time. To mitigate this, we can pass a pointer or a reference to the object instead, making the copy much smaller. You can consider references in C++ as syntactic sugar for pointers, they act the same way.<br>For large objects, it's always recommended to pass it by a reference. You might be concerned that directly operating on the original object could lead to unintended modifications. To avoid this, you can use the const keyword to ensure the object is not altered. This approach is exactly what we use in a copy constructor and copy assignment operator.<br><br>It is generally recommended to pass by const reference. On modern 64-bit machines, a pointer requires 8 bytes to store. Whether you use pass-by-pointer or pass-by-reference, you will always copy an 8-byte pointer to somewhere, typically a register (or the stack when there are many parameters).<br>When you pass a easy type no bigger than 8 bytes (e.g., int, which typically stores 4 bytes on most machines) by value, you only copy 4 bytes. However, if you use a pointer or reference, it would take 8 bytes. In this case, will pass this type no bigger than 8 bytes by value be better?<br>It looks so, because you copy 4 bytes must be two times faster than copy a 8 bytes pointer. But in most cases, these parameters will be passed to a register (the rule is in the next section). Copying a type no larger than 8 bytes to a register doesn't make much of a difference in terms of performance. But it's a good practice to do so.<br>It seems so, because copying 4 bytes must be two-times faster than copying an 8-byte pointer, right? However, in most cases, these parameters will be passed to a register. Copying a type no larger than 8 bytes to a register doesn't make much of a difference in terms of performance. But it's a good practice to do so.<br><br>On 64-bit machines, function parameters are usually passed through specific registers, and only when the number of parameters exceeds the available registers do parameters get passed on the stack. Here are the typical rules for x86-64 (System V ABI):<br>
<br>Integer and Pointer Parameters:<br>
Passed through registers: RDI, RSI, RDX, RCX, R8, R9 (for the first six parameters).<br>
Any additional parameters are passed on the stack.
<br>Floating-point Parameters:<br>
Passed through registers: XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7 (for the first eight parameters).<br>
Any additional parameters are passed on the stack.
<br>For custom complex types:<br>
<br>If passed by value and they do not fit into available registers, they are stored on the stack.
<br>If passed by reference (pointer), the reference itself is passed through a register if there are enough available.
<br>Following these rules ensures efficient and consistent parameter passing, helping to optimize function calls.]]></description><link>https://congzhi.wiki/c-plus-plus/call-stack-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Call Stack in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 17:40:39 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/call_stack.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/call_stack.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Computer Networking A Top-Down Approach]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br>原计划对 Computer Networking: A Top-Down Approach 整本书进行翻译，翻译了三章翻译不动了。目前已弃坑......<br><br><br>三章的入口罗列在下：<br>Computer Networking: A Top-Down Approach

<br><a data-href="Chapter 1 Computer Networks and the Internet" href="https://congzhi.wiki/computer-networking-a-top-down-approach/chapter-1-computer-networks-and-the-internet.html" class="internal-link" target="_self" rel="noopener nofollow">Chapter 1 Computer Networks and the Internet</a>
<br><a data-href="Chapter 2 Application Layer" href="https://congzhi.wiki/computer-networking-a-top-down-approach/chapter-2-application-layer.html" class="internal-link" target="_self" rel="noopener nofollow">Chapter 2 Application Layer</a>
<br><a data-href="Chapter 3 Transport Layer" href="https://congzhi.wiki/computer-networking-a-top-down-approach/chapter-3-transport-layer.html" class="internal-link" target="_self" rel="noopener nofollow">Chapter 3 Transport Layer</a>
<br><a data-href="SMTP" href="https://congzhi.wiki/computer-networking-a-top-down-approach/smtp.html" class="internal-link" target="_self" rel="noopener nofollow">SMTP</a>

]]></description><link>https://congzhi.wiki/computer-networking-a-top-down-approach/computer-networking-a-top-down-approach.html</link><guid isPermaLink="false">Computer Networking A Top-Down Approach/Computer Networking A Top-Down Approach.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:20 GMT</pubDate></item><item><title><![CDATA[Congzhi's OS Series]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br>This series is intended solely for educational purposes. Some images used in this series are sourced from the internet. If any of these images conflict with your creation principles, please contact me at <a data-tooltip-position="top" aria-label="mailto:duzhi02@qq.com." rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi02@qq.com." target="_blank">duzhi02@qq.com.</a> I would address the issue ASAP.<br>所有内容均由我独自完成，所有学习资料来源如下：<br>
<br><a data-tooltip-position="top" aria-label="https://space.bilibili.com/286191426/channel/collectiondetail?sid=2293786" rel="noopener nofollow" class="external-link" href="https://space.bilibili.com/286191426/channel/collectiondetail?sid=2293786" target="_blank">Y4NGY操作系统课程</a>
<br>(<a data-tooltip-position="top" aria-label="https://www.youtube.com/playlist?list=PLFCH6yhq9yAHFaI00FrrgG0dPg8a5SjTJ" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/playlist?list=PLFCH6yhq9yAHFaI00FrrgG0dPg8a5SjTJ" target="_blank">ECE 252: Systems Programming and Concurrency</a>)
<br>(<a data-tooltip-position="top" aria-label="https://www.youtube.com/playlist?list=PLFCH6yhq9yAHFUGyk4U5KaoA24gnnDJA-" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/playlist?list=PLFCH6yhq9yAHFUGyk4U5KaoA24gnnDJA-" target="_blank">ECE 350: Real-Time Operating System</a>)
<br><a data-tooltip-position="top" aria-label="https://zh.z-lib.gs/book/25277046/1b1f19/operating-system-concepts.html?ts=1905" rel="noopener nofollow" class="external-link" href="https://zh.z-lib.gs/book/25277046/1b1f19/operating-system-concepts.html?ts=1905" target="_blank">Operating System Concepts from Z-Lib</a>
<br><a data-tooltip-position="top" aria-label="https://www.cs.csustan.edu/~john/Classes/CS3750/" rel="noopener nofollow" class="external-link" href="https://www.cs.csustan.edu/~john/Classes/CS3750/" target="_blank">Prof. John Sarraillé's CS3750 course notes</a>
<br><a data-tooltip-position="top" aria-label="https://wiki.osdev.org" rel="noopener nofollow" class="external-link" href="https://wiki.osdev.org" target="_blank">OSDev Wiki</a>
<br><a data-tooltip-position="top" aria-label="https://www.josehu.com/notes.html" rel="noopener nofollow" class="external-link" href="https://www.josehu.com/notes.html" target="_blank">Notes | Guanzhou Hu</a>
<br>...
<br><br><br>Your Attention Please!
系列仍在施工中......在2025年内，将计划第一遍重写整个系列，旨在补全系列中缺失的内容。阶段章节中许多空标题多来源于原作者内容的编排，第一遍重写会逐步补全这些内容。
	 |ˉˉˉˉˉˉˉ|
	 |Salute!|
	 |__  ___|
	    |/
	(◍•ᴗ•◍)ゝ

后续，系列的结构还会不断调整更新。
<br><br><br>目前，所有的阶段都罗列如下，其中 x(extend) 表示拓展阶段或小节。部分暂未补全但不影响阅读：<br>Congzhi's OS Series
<a data-href="1. Introduction to the OS" href="https://congzhi.wiki/congzhi's-os-series/1.-introduction-to-the-os.html" class="internal-link" target="_self" rel="noopener nofollow">1. Introduction to the OS</a><br>
<a data-href="2. OS Development Stages" href="https://congzhi.wiki/congzhi's-os-series/2.-os-development-stages.html" class="internal-link" target="_self" rel="noopener nofollow">2. OS Development Stages</a><br>
<a data-href="3. Operating System Structures" href="https://congzhi.wiki/congzhi's-os-series/3.-operating-system-structures.html" class="internal-link" target="_self" rel="noopener nofollow">3. Operating System Structures</a><br>
<a data-href="4. System Boots Up" href="https://congzhi.wiki/congzhi's-os-series/4.-system-boots-up.html" class="internal-link" target="_self" rel="noopener nofollow">4. System Boots Up</a><br>
<a data-href="5. Interruption" href="https://congzhi.wiki/congzhi's-os-series/5.-interruption.html" class="internal-link" target="_self" rel="noopener nofollow">5. Interruption</a><br>
<a data-href="6. Processing The Processes" href="https://congzhi.wiki/congzhi's-os-series/6.-processing-the-processes.html" class="internal-link" target="_self" rel="noopener nofollow">6. Processing The Processes</a><br>
<a data-href="6.5 Inter-Process Communications" href="https://congzhi.wiki/congzhi's-os-series/6.5-inter-process-communications.html" class="internal-link" target="_self" rel="noopener nofollow">6.5 Inter-Process Communications</a><br>
<a data-href="7. Thread and Concurrency" href="https://congzhi.wiki/congzhi's-os-series/7.-thread-and-concurrency.html" class="internal-link" target="_self" rel="noopener nofollow">7. Thread and Concurrency</a><br>
<a data-href="8. CPU Scheduling" href="https://congzhi.wiki/congzhi's-os-series/8.-cpu-scheduling.html" class="internal-link" target="_self" rel="noopener nofollow">8. CPU Scheduling</a><br>
<a data-href="9. Synchronization and Mutex" href="https://congzhi.wiki/congzhi's-os-series/9.-synchronization-and-mutex.html" class="internal-link" target="_self" rel="noopener nofollow">9. Synchronization and Mutex</a><br>
<a data-href="10. Deadlock" href="https://congzhi.wiki/congzhi's-os-series/10.-deadlock.html" class="internal-link" target="_self" rel="noopener nofollow">10. Deadlock</a><br>
<a data-href="10.5 Advanced Concurrency Problems" href="https://congzhi.wiki/congzhi's-os-series/10.5-advanced-concurrency-problems.html" class="internal-link" target="_self" rel="noopener nofollow">10.5 Advanced Concurrency Problems</a><br>
<a data-href="10.x A Thread Pool Library in C++" href="https://congzhi.wiki/congzhi's-os-series/10.x-a-thread-pool-library-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">10.x A Thread Pool Library in C++</a><br>
<a data-href="11. Memory Management" href="https://congzhi.wiki/congzhi's-os-series/11.-memory-management.html" class="internal-link" target="_self" rel="noopener nofollow">11. Memory Management</a><br>
<a data-href="12. IO Systems" href="https://congzhi.wiki/congzhi's-os-series/12.-io-systems.html" class="internal-link" target="_self" rel="noopener nofollow">12. IO Systems</a><br>
<a data-href="13. File Systems" href="https://congzhi.wiki/congzhi's-os-series/13.-file-systems.html" class="internal-link" target="_self" rel="noopener nofollow">13. File Systems</a><br>
<a data-href="14. Asynchronous IO" href="https://congzhi.wiki/congzhi's-os-series/14.-asynchronous-io.html" class="internal-link" target="_self" rel="noopener nofollow">14. Asynchronous IO</a><br>
<a data-href="15. Virtualization and Container" href="https://congzhi.wiki/congzhi's-os-series/15.-virtualization-and-container.html" class="internal-link" target="_self" rel="noopener nofollow">15. Virtualization and Container</a><br>
<a data-href="T1. Valgrind and Helgrind" href="https://congzhi.wiki/congzhi's-os-series/t1.-valgrind-and-helgrind.html" class="internal-link" target="_self" rel="noopener nofollow">T1. Valgrind and Helgrind</a>
<br><br><br>如果您发现任何知识上的疑问、错误和错别字问题，也欢迎通过邮箱 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。]]></description><link>https://congzhi.wiki/congzhi's-os-series/congzhi's-os-series.html</link><guid isPermaLink="false">Congzhi's OS Series/Congzhi's OS Series.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:17:45 GMT</pubDate></item><item><title><![CDATA[T1. Valgrind and Helgrind]]></title><description><![CDATA[ 
 <br><br><br>本节课，我们将会学习两个工具—— Valgrind 和 Helgrind 。这两个工具是用来分析 C/C++ 程序中的漏洞，分析之后，你可以更好的修正你漏洞百出的程序。<br><br>在北欧神话中，死后灵魂可能会前往不同的领域 (realm) 。分别是由爱与战争女神 Freyja 掌管的 Fólkvangr 、由冥界女神 Hel 掌管的 Hel 、由海洋女神 Rán 掌管的海洋领域、Burial Mound 和由主神 Odin 掌管的 Valhöll (Valhalla) 。<br>通往 Valhalla 的门被称为 Valgrind。据传说，Valgrind 是一个巨大的大门，通往战死英灵 (einherjar) 最终安息的地方——Valhalla。女武神 (valkyries) 会带领这些英勇牺牲的战士通过这扇大门，进入英灵殿 Valhalla 享受盛宴和荣耀，为最终的末日决战——诸神黄昏（Ragnarök）做准备。<br><img alt="valhalla.jpg" src="https://congzhi.wiki/congzhi's-os-series/pics/valhalla.jpg"><br>Valgrind，通往英灵殿的大门，象征着筛选和守护。只有英勇牺牲的战士才能跨过此门，进入奥丁的殿堂，为世界末日筛选战士。<br>而 Valgrind，通往内存安全的大门，也象征着筛选和守护。它筛选出内存错误，引导程序员修复问题，为程序的崩溃排除隐患。<br><br>需要加上 -g 参数么<br>definitely lost<br>indirectly lost: 链表结构<br>possibly lost: valgrind也不知道有没有内存泄漏<br>still reachable: 在程序退出时，仍然由指针指向为泄漏的内存<br>valgrind ./memAlloc
# 获得更多信息
valgrind --leak-check=full ./memAlloc
# 获得更多更多的信息
valgrind --leak-check=full --show-leak-kinds=all ./memAlloc
<br>valgrind可以告诉你内存泄漏发生在哪里，是什么函数申请的内存，但是不能告诉你到底在哪里去释放内存<br>如果有一个双重释放的程序，用valgrind运行会怎么样？<br>如果不用valgring，你的程序可能会立刻结束。但是使用valgring可能会运行一些时间？<br>相比 gdb ，valgrind好用多了<br>]]></description><link>https://congzhi.wiki/congzhi's-os-series/t1.-valgrind-and-helgrind.html</link><guid isPermaLink="false">Congzhi's OS Series/T1. Valgrind and Helgrind.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 17:13:49 GMT</pubDate><enclosure url="https://congzhi.wiki/congzhi's-os-series/pics/valhalla.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/congzhi's-os-series/pics/valhalla.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CS50 SQL]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/cs50" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/cs50" target="_blank">CS50</a>本身是 Harvard 开设的面向大众的计算机科学入门课程(Introduction to Computer Science)，由 David J. Malan 教授进行授课，其中就包含 SQL 和其他的内容。现在，你可以在 CS50 上学到很多 Harvard 和 Yale 所开设的一些小而精的计算机科学课程，很多都作为 CS50 Lectures 内容的延申，其中就包括这个 folder 下的 CS50's Introduction to Databases with SQL。<br><br><br>这个系列是对 CS50 数据库课程的一些笔记。内容结构会基本按照 CS50 课程的编排走，内容也会相对基础。参考来源有：<br>
<br><a data-tooltip-position="top" aria-label="https://cs50.harvard.edu/sql/2024/" rel="noopener nofollow" class="external-link" href="https://cs50.harvard.edu/sql/2024/" target="_blank">CS50's Introduction to Databases with SQL</a>
<br>...
<br><br><br><a data-href="CS50 SQL" href="https://congzhi.wiki/cs50-sql/cs50-sql.html" class="internal-link" target="_self" rel="noopener nofollow">CS50 SQL</a> 的目录结构如下，你可以在 <a data-tooltip-position="top" aria-label="https://cs50.harvard.edu/sql/2024/" rel="noopener nofollow" class="external-link" href="https://cs50.harvard.edu/sql/2024/" target="_blank">CS50</a> 学到 Lecture 0 - Lecture 6 的所有知识。你还能在官网上做 CS50 的课后作业并提交。Lecture x 是另一些课程中的内容。<br>CS50 SQL (NC Stand for Not Covered)

<br><a data-href="Lecture 0 - Querying" href="https://congzhi.wiki/cs50-sql/lecture-0-querying.html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 0 - Querying</a>
<br><a data-href="Lecture 1 - Relating (NC)" href="https://congzhi.wiki/cs50-sql/lecture-1-relating-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 1 - Relating (NC)</a>
<br><a data-href="Lecture 2 - Designing (NC)" href="https://congzhi.wiki/cs50-sql/lecture-2-designing-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 2 - Designing (NC)</a>
<br><a data-href="Lecture 3 - Writing (NC)" href="https://congzhi.wiki/cs50-sql/lecture-3-writing-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 3 - Writing (NC)</a>
<br><a data-href="Lecture 4 - Viewing (NC)" href="https://congzhi.wiki/cs50-sql/lecture-4-viewing-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 4 - Viewing (NC)</a>
<br><a data-href="Lecture 5 - Optimizing (NC)" href="https://congzhi.wiki/cs50-sql/lecture-5-optimizing-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 5 - Optimizing (NC)</a>
<br><a data-href="Lecture 6 - Scaling (NC)" href="https://congzhi.wiki/cs50-sql/lecture-6-scaling-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Lecture 6 - Scaling (NC)</a>

<br>Consistency Checking in Database

<br><a data-href="Transaction in Database (NC)" href="https://congzhi.wiki/cs50-sql/transaction-in-database-(nc).html" class="internal-link" target="_self" rel="noopener nofollow">Transaction in Database (NC)</a>

<br><br><br>如有疑问或内容问题，欢迎通过 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。]]></description><link>https://congzhi.wiki/cs50-sql/cs50-sql.html</link><guid isPermaLink="false">CS50 SQL/CS50 SQL.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:15 GMT</pubDate></item><item><title><![CDATA[Data Structure and Algorithm]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br>DSA 系列上会放一些数据结构（DS）、排序算法（SA）和 Leecode 算法题（L）。下面是本系列的目录：<br>Data Structure

<br><a data-href="DS. B Tree" href="https://congzhi.wiki/data-structure-and-algorithm/ds.-b-tree.html" class="internal-link" target="_self" rel="noopener nofollow">DS. B Tree</a>
<br><a data-href="DS. Red-Black Tree" href="https://congzhi.wiki/data-structure-and-algorithm/ds.-red-black-tree.html" class="internal-link" target="_self" rel="noopener nofollow">DS. Red-Black Tree</a>
<br><a data-href="DS. Heap (Priority Queue)" href="https://congzhi.wiki/data-structure-and-algorithm/ds.-heap-(priority-queue).html" class="internal-link" target="_self" rel="noopener nofollow">DS. Heap (Priority Queue)</a>

<br>Leecode Algo Questions

<br><a data-href="L1. Contains Duplicate" href="https://congzhi.wiki/data-structure-and-algorithm/l1.-contains-duplicate.html" class="internal-link" target="_self" rel="noopener nofollow">L1. Contains Duplicate</a>
<br><a data-href="L2. Valid Anagram" href="https://congzhi.wiki/data-structure-and-algorithm/l2.-valid-anagram.html" class="internal-link" target="_self" rel="noopener nofollow">L2. Valid Anagram</a>
<br><a data-href="L3. Two Sum" href="https://congzhi.wiki/data-structure-and-algorithm/l3.-two-sum.html" class="internal-link" target="_self" rel="noopener nofollow">L3. Two Sum</a>
<br><a data-href="L4. Group Anagrams (Star)" href="https://congzhi.wiki/data-structure-and-algorithm/l4.-group-anagrams-(star).html" class="internal-link" target="_self" rel="noopener nofollow">L4. Group Anagrams (Star)</a>
<br><a data-href="L5. Top K Frequent Elements (Star)" href="https://congzhi.wiki/data-structure-and-algorithm/l5.-top-k-frequent-elements-(star).html" class="internal-link" target="_self" rel="noopener nofollow">L5. Top K Frequent Elements (Star)</a>
<br><a data-href="L6. Product of Array Except Self (Star)" href="https://congzhi.wiki/data-structure-and-algorithm/l6.-product-of-array-except-self-(star).html" class="internal-link" target="_self" rel="noopener nofollow">L6. Product of Array Except Self (Star)</a>
<br><a data-href="L7. Valid Sudoku (Medium)" href="https://congzhi.wiki/data-structure-and-algorithm/l7.-valid-sudoku-(medium).html" class="internal-link" target="_self" rel="noopener nofollow">L7. Valid Sudoku (Medium)</a>
<br><a data-href="L8. Encode and Decode Strings (Midium)" href="https://congzhi.wiki/data-structure-and-algorithm/l8.-encode-and-decode-strings-(midium).html" class="internal-link" target="_self" rel="noopener nofollow">L8. Encode and Decode Strings (Midium)</a>

<br>Sorting Algorithms

<br><a data-href="SA. Bubble Sort" href="https://congzhi.wiki/data-structure-and-algorithm/sa.-bubble-sort.html" class="internal-link" target="_self" rel="noopener nofollow">SA. Bubble Sort</a>

<br><br><br>你可以通过 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我！]]></description><link>https://congzhi.wiki/data-structure-and-algorithm/data-structure-and-algorithm.html</link><guid isPermaLink="false">Data Structure and Algorithm/Data Structure and Algorithm.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:12 GMT</pubDate></item><item><title><![CDATA[DS. B Tree]]></title><description><![CDATA[ 
 <br><br>B树是一种高效的多路平衡搜索树。你可以在文件系统/数据库这类有关磁盘存储（Mass storage system）中经常看到B树极其变种的身影。我们知道，树这种结构往往代表着优秀的查询时间复杂度，比如红黑树这类二叉树的查询时间复杂度为  ，即假如我们有10亿数据，我们最多需要30次 I/O 操作。相比顺序结构简直好到那里去了。<br>既然二叉树搜索已经足够快了，我们为什么还要学习B树？因为磁盘 I/O 太太太慢了。访问一次磁盘 I/O 会浪费数百万个时钟周期，相比之下，访问内存通常需要 200-300 个时钟周期。这就相当于在厨房做饭，去菜市场买菜和在冰箱里面拿的区别。<br>同样的10亿数据，怎么能让查询更快呢？既然我们的树不能往高了长，那就压低树高，让他变宽不就行了吗？Rudolf Bayer 和 Edward M. McCreight 在上世纪70年代也是这样想的。所以相比二叉树，B树的每个节点可以包含 m 个子节点（我们称之为m阶B树）。<br>在文件系统和数据库中，B树及其变种的阶数通常在 64-1600 之间。假如我们的B树阶数为200阶，那么其搜索10亿数据所需要的I/O操作就是：4次。足足减少了 86% 的I/O操作。（所以红黑树并不应用在磁盘中，你可以在内存/缓存结构中看到红黑树的身影）<br><br>数据结构并不是最难的，算法才是。下面是一个最简单的B树，一个父节点，三个子节点。除了中间的子节点外，其他的节点均拥有2个键，父节点有三个指向子节点的指针。所以这个树是3阶B树。<br><br>从之前的学习中，我们只看到B树降低了查询次数，我们还会得到什么呢？天下没有掉馅饼的好事情，B树也不例外。我们减少了 I/O 操作，但是我们查询子节点时需要比较的操作肯定变多了。二叉树你只需要一次比较，但是m阶B树，你需要  次的比较操作。<br><br>但是一旦我们从磁盘中取到节点，我们比较的操作实际上是在内存中进行的。前面我们提到了磁盘操作相比内存操作要慢多少了，上千次内存操作也比不上一次磁盘操作所消耗的时间长，所以比较操作的时间几乎可以不计了。我们赢了两次。<br>B树有许多规则，通过这些规则，我们就能保证B树处于一个平衡状态，以便发挥其特性。B树的规则有：<br>
<br>B树的叶节点并不指向任何子节点（NIL），只存储键和数据。
<br>B树的叶节点深度相同，确保B树是平衡的（Same level of the tree）。
<br>除了叶子节点外的其他节点存储键的个数在 m/2-1 到 m-1 之间。
<br>叶子节点可以至少有一个键。
<br>在B树建立的过程中，有些规则可以无视。
<br>需要再次补充说明的是，每个节点除了键还会存储指向子节点的指针。从上面的图不难发现，指针的个数往往是键个数+1。<br><br>B树的新键插入也很有意思，具体的规则是：<br>
<br>B树新键的插入始终插入到叶子节点。
<br>如果插入后节点键数超过上限（阶数-1），则进行节点分裂。
<br>如果分裂导致父节点溢出，则继续进行向上递归的节点分裂，直到根节点。
<br>当根节点溢出，树高增加一层。
<br>假如我们现在有下面的3阶B树（每个节点最多2个键）。我们通过 mermaid 图来了解整个过程。<br><br>第一步插入键值8，我们通过定位将其插入到叶子节点 [5, 7]。这时变为 [5, 7, 8]，键数为3，溢出。<br><br>溢出后分裂叶子节点，中间键 7 提升到父节点中，源节点分裂为 [5] 和 [8]。<br><br>我们再插入键值25。同样的也会溢出。<br><br>分裂叶子节点，我们讲中间键提升到父节点中。这时，父节点也会溢出。这时，我们就增加一层树高，把父节点的中间键提升到新的根节点中。<br><br>至此，B+树的插入完成了。<br><br>B+树和B树的区别在于，B+树只使用叶子节点来存储数据，内部节点仅仅作为索引使用。所以B+树所有查询的路径长度是严格一致的。这样做的好处是，由于指针只有 8 字节，你可以一次性从磁盘中读取很多指针信息。这样，你就可以在内存中找你想要的信息，适合范围查询。]]></description><link>https://congzhi.wiki/data-structure-and-algorithm/ds.-b-tree.html</link><guid isPermaLink="false">Data Structure and Algorithm/DS. B Tree.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 20:49:44 GMT</pubDate></item><item><title><![CDATA[DS. Red-Black Tree]]></title><description><![CDATA[ 
 <br><br>红黑树是一颗自平衡的二叉搜索树，红黑树有 5 个属性，这五个属性都满足时，我们就说红黑树是平衡的。由于其属性，在每次增删改查时，红黑树都需要不断地进行调整，所以它是自平衡的。红黑树的属性是：<br>
<br>每个节点要么是红节点，要么是黑节点。（红黑树名字的由来）
<br>根节点总是黑节点。
<br>每个 NIL 节点（即叶子节点）都是黑节点。
<br>每个红节点的子节点必须都要是黑节点。
<br>从根节点到任意叶子节点之间的所有路径中，黑节点的数量总是一样的。
<br>为了满足 5 ，红黑树每次加入节点时，初始颜色总是红色的。
<br><br>当你在红黑树中插入一个节点时，插入的节点会被默认设定为红节点。为什么？因为上面的第五条规则，从根节点到任意 nil 节点之间黑节点的个数都应当是相同的。插入红节点不会造成影响。之后，如果两个红节点连在一起，我们就需要修正红黑树（颜色翻转、旋转），平衡红黑树。<br><br>插入一个子节点（红节点）。但是 uncle node 是红结点，这时候，切换 grandparent node 和 parent/uncle node 的颜色。（颜色翻转）<br>初始状态：
	 ...
	  /
   ● G(黑)
    /   \
 ○ P(红) ○ U(红)

插入N(红)后：
	 ...
	  /
   ● G(黑)
    /   \
 ○ P(红) ○ U(红)
  /
○ N(红) ← 冲突！

颜色翻转：
	 ...
	  /
   ○ G(红)
    /   \
 ● P(黑) ● U(黑)
  /
○ N(红)
<br><br>插入一个子节点（红节点）。Parent node 是红节点，而且 uncle node 是黑结点，这时候，旋转。<br>初始状态：
	 ...
	  /
   ● G(黑)
    /   \
 ○ P(红) ● U(黑)

插入N(红)后：
	 ...
	  /
   ● G(黑)
    /   \
 ○ P(红) ● U(黑)
    \
   ○ N(红) ← 冲突！

P节点左旋：转换成 Case 3
	 ...
	  /
   ● G(黑)
    /   \
 ○ N(红) ● U(黑)
  /
○ P(红)
<br><br>初始状态：
	 ...
	  /
   ● G(黑)
    /   \
 ○ P(红) ● U(黑)
  /
○ N(红)

旋转 grandparent node
	 ...
	  /
   ○ P(红)
    /   \
 ○ N(红) ● G(黑)
		  \
		  ● U(黑)

最终形态：
	 ...
	  /
   ● P(黑)
    /   \
 ○ N(红) ○ G(红)
		  \
		  ● U(黑)
<br><br>我们要插入 1, 2, 3, 4, 5, 6<br><br>○ 1(红)
/   \
NIL NIL

由于根节点必须是黑节点:

● 1(黑)
/   \
NIL NIL
<br><br>● 1(黑)
/   \
NIL ○ 2(红)
	/   \
   NIL  NIL
<br><br>● 1(黑)
/   \
NIL ○ 2(红)
	/   \
   NIL  ○ 3(红)
	    /   \
	   NIL  NIL

冲突发生，回到我们 Case 3, 翻转 grandparent node

	○ 2(红)
	/   \
● 1(黑) ○ 3(红)
/   \     /   \
NIL	NIL  NIL  NIL

翻转颜色：
	● 2(黑)
	/   \
○ 1(红) ○ 3(红)
/   \     /   \
NIL	NIL  NIL  NIL
<br><br>	● 2(黑)
	/   \
○ 1(红) ○ 3(红)
/   \     /   \
NIL	NIL  NIL  ○ 4(红)
			  /   \
             NIL  NIL

冲突发生，回到 Case 1 的情况：颜色翻转

	○ 2(红)
	/   \
● 1(黑) ● 3(黑)
/   \     /   \
NIL	NIL  NIL  ○ 4(红)
			  /   \
             NIL  NIL

根节点需要是黑节点：

	● 2(黑)
	/   \
● 1(黑) ● 3(黑)
/   \     /   \
NIL	NIL  NIL  ○ 4(红)
			  /   \
             NIL  NIL
<br><br>	● 2(黑)
	/   \
● 1(黑) ● 3(黑)
/   \     /   \
NIL	NIL  NIL  ○ 4(红)
			  /   \
             NIL  ○ 5(红)
	              /   \
	             NIL  NIL

回到 Case 3：

	● 2(黑)
	/    \
● 1(黑)  ○ 4(红)
/    \    /    \
NIL	NIL ● 3(黑) ○ 5(红)
		/    \   /    \
      NIL   NIL NIL  NIL

Recoloring:

	● 2(黑)
	/    \
● 1(黑)  ● 4(黑)
/    \    /    \
NIL	NIL ○ 3(红) ○ 5(红)
		/    \   /    \
      NIL   NIL NIL  NIL
<br><br>
	● 2(黑)
	/    \
● 1(黑)  ● 4(黑)
/    \    /    \
NIL	NIL ○ 3(红) ○ 5(红)
		/    \   /    \
      NIL   NIL NIL  ○ 6(红)
					/   \
				  NIL   NIL
回到 Case 1:

	● 2(黑)
	/    \
● 1(黑)  ○ 4(红)
/    \    /    \
NIL	NIL ● 3(黑) ● 5(黑)
		/    \   /    \
      NIL   NIL NIL  ○ 6(红)
				    /   \
				  NIL   NIL
<br><br>红黑树是自平衡的二叉搜索树，通过中序遍历，你就可以按顺序地得按顺序排列的节点（在这个例子中是从小到大）。<br>中序遍历的顺序是：左子树-&gt;根节点-&gt;右子树]]></description><link>https://congzhi.wiki/data-structure-and-algorithm/ds.-red-black-tree.html</link><guid isPermaLink="false">Data Structure and Algorithm/DS. Red-Black Tree.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 19:08:18 GMT</pubDate></item><item><title><![CDATA[SA. Bubble Sort]]></title><description><![CDATA[ 
 <br>排序算法的作用是将一组元素按照指定顺序进行排列。常见的顺序包括数字从小到大的升序排列、字母从 A 到 Z 的字典序排列，也可以是其他任意顺序（如降序排列）。高效的排序算法对于系统至关重要，因为它在一定程度上会影响系统的整体性能，尤其是在需要频繁处理大规模数据时。<br><br>冒泡排序可以说是最简单的排序算法，它的核心思想是通过多次比较和交换，将较大的元素逐步“冒泡”到序列的末尾。<br>每一次”冒泡“都需要  的时间复杂度]]></description><link>https://congzhi.wiki/data-structure-and-algorithm/sa.-bubble-sort.html</link><guid isPermaLink="false">Data Structure and Algorithm/SA. Bubble Sort.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 19:10:23 GMT</pubDate></item><item><title><![CDATA[Redis at a Peek]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=jgpVdJB2sKQ" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=jgpVdJB2sKQ" target="_blank">Redis Crash Course</a>]]></description><link>https://congzhi.wiki/some-notes/redis-at-a-peek.html</link><guid isPermaLink="false">Some Notes/Redis at a Peek.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 18:48:30 GMT</pubDate></item><item><title><![CDATA[Some Notes]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="index" data-href="index" href="https://congzhi.wiki/index.html" class="internal-link" target="_self" rel="noopener nofollow">回到上级</a><br><br><br><a data-href="Some Notes" href="https://congzhi.wiki/some-notes/some-notes.html" class="internal-link" target="_self" rel="noopener nofollow">Some Notes</a> 用于保存记录零碎的小笔记，或是暂时未开工的新计划。<a data-href="Some Notes" href="https://congzhi.wiki/some-notes/some-notes.html" class="internal-link" target="_self" rel="noopener nofollow">Some Notes</a> 下的笔记有：<br>Some Notes:

<br><a data-href="Three Steps to Have Your Own Obsidian Site" href="https://congzhi.wiki/some-notes/three-steps-to-have-your-own-obsidian-site.html" class="internal-link" target="_self" rel="noopener nofollow">Three Steps to Have Your Own Obsidian Site</a>
<br><a data-href="进程的一生——从出生到死亡 (Abandoned)" href="https://congzhi.wiki/some-notes/进程的一生——从出生到死亡-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">进程的一生——从出生到死亡 (Abandoned)</a> --&gt; <a data-href="Building and Version Control" href="https://congzhi.wiki/building-and-version-control/building-and-version-control.html" class="internal-link" target="_self" rel="noopener nofollow">Building and Version Control</a>
<br><a data-href="存储器扩展技术" href="https://congzhi.wiki/some-notes/存储器扩展技术.html" class="internal-link" target="_self" rel="noopener nofollow">存储器扩展技术</a>
<br><a data-href="Endianness" href="https://congzhi.wiki/some-notes/endianness.html" class="internal-link" target="_self" rel="noopener nofollow">Endianness</a>
<br><a data-href="Flask" href="https://congzhi.wiki/some-notes/flask.html" class="internal-link" target="_self" rel="noopener nofollow">Flask</a>
<br><a data-href="ISA, Instructions and CPU" href="https://congzhi.wiki/some-notes/isa,-instructions-and-cpu.html" class="internal-link" target="_self" rel="noopener nofollow">ISA, Instructions and CPU</a>
<br><a data-href="CS50's Introduction to Python" href="https://congzhi.wiki/some-notes/cs50's-introduction-to-python.html" class="internal-link" target="_self" rel="noopener nofollow">CS50's Introduction to Python</a>
<br><a data-href="Real-Basic Algorithm Concepts" href="https://congzhi.wiki/some-notes/real-basic-algorithm-concepts.html" class="internal-link" target="_self" rel="noopener nofollow">Real-Basic Algorithm Concepts</a>
<br><a data-href="Redis at a Peek" href="https://congzhi.wiki/some-notes/redis-at-a-peek.html" class="internal-link" target="_self" rel="noopener nofollow">Redis at a Peek</a>
<br><a data-href="Intro to Algorithm" href="https://congzhi.wiki/some-notes/intro-to-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">Intro to Algorithm</a>
<br><a data-href="YOLO Env Config" href="https://congzhi.wiki/some-notes/yolo-env-config.html" class="internal-link" target="_self" rel="noopener nofollow">YOLO Env Config</a>

<br><br><br>任何疑问都欢迎通过 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。]]></description><link>https://congzhi.wiki/some-notes/some-notes.html</link><guid isPermaLink="false">Some Notes/Some Notes.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 15:18:05 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br><br><br>
<br><a data-tooltip-position="top" aria-label="Congrats on Finding Here!" data-href="#Congrats on Finding Here!" href="https://congzhi.wiki/about:blank#Congrats_on_Finding_Here!" class="internal-link" target="_self" rel="noopener nofollow">Congrats on Finding Here!</a>
<br><a data-tooltip-position="top" aria-label="Everything You Could Learn Right Now" data-href="#Everything You Could Learn Right Now" href="https://congzhi.wiki/about:blank#Everything_You_Could_Learn_Right_Now" class="internal-link" target="_self" rel="noopener nofollow">Everything You Could Learn Right Now</a>
<br><a data-tooltip-position="top" aria-label="All About Me" data-href="#All About Me" href="https://congzhi.wiki/about:blank#All_About_Me" class="internal-link" target="_self" rel="noopener nofollow">All About Me</a>
<br><a data-tooltip-position="top" aria-label="Contact Me" data-href="#Contact Me" href="https://congzhi.wiki/about:blank#Contact_Me" class="internal-link" target="_self" rel="noopener nofollow">Contact Me</a>
<br><br><br>Hi there! Welcome to my home site. This site will be my zone of the internet. I will be sharing everything here, including some computer science notes I have made myself, some life stuff, and on and on and on...<br>From this page, you might assume this site is English-friendly. However, the majority of the note content is written in Chinese. For those who don't know Chinese, I feel real-sorry for you, but you can find some C++ notes written in English. Come on, go take an adventure!<br><br><br>Currently, there's six series I have are listed below. In the future, this list will grow longer.<br>Congzhi's CS Note Series

<br><a data-href="Building and Version Control" href="https://congzhi.wiki/building-and-version-control/building-and-version-control.html" class="internal-link" target="_self" rel="noopener nofollow">Building and Version Control</a>
<br><a data-href="Congzhi's OS Series" href="https://congzhi.wiki/congzhi's-os-series/congzhi's-os-series.html" class="internal-link" target="_self" rel="noopener nofollow">Congzhi's OS Series</a>
<br><a data-href="C Plus Plus" href="https://congzhi.wiki/c-plus-plus/c-plus-plus.html" class="internal-link" target="_self" rel="noopener nofollow">C Plus Plus</a> &lt;--- English Notes here!
<br><a data-href="CS50 SQL" href="https://congzhi.wiki/cs50-sql/cs50-sql.html" class="internal-link" target="_self" rel="noopener nofollow">CS50 SQL</a>
<br><a data-href="Data Structure and Algorithm" href="https://congzhi.wiki/data-structure-and-algorithm/data-structure-and-algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">Data Structure and Algorithm</a>
<br><a data-href="Some Notes" href="https://congzhi.wiki/some-notes/some-notes.html" class="internal-link" target="_self" rel="noopener nofollow">Some Notes</a>

<br>Sadly, projects or series have been abandoned for some reasons. But you might strike gold there!<br>Abandoned Projects

<br><a data-tooltip-position="top" aria-label="Computer Networking A Top-Down Approach" data-href="Computer Networking A Top-Down Approach" href="https://congzhi.wiki/computer-networking-a-top-down-approach/computer-networking-a-top-down-approach.html" class="internal-link" target="_self" rel="noopener nofollow">Computer Networking</a>

<br><br><br>This section will be released when it's appropriate:<br>All About Me

<br><a data-href="生记" href="https://congzhi.wiki/生记/生记.html" class="internal-link" target="_self" rel="noopener nofollow">生记</a>
<br><a data-href="游记" href="https://congzhi.wiki/游记/游记.html" class="internal-link" target="_self" rel="noopener nofollow">游记</a>
<br><a data-href="业记" href="https://congzhi.wiki/业记/业记.html" class="internal-link" target="_self" rel="noopener nofollow">业记</a>

<br><br><br>You are welcomed to contact me at <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a>!<br>
你可以通过邮箱 <a data-tooltip-position="top" aria-label="mailto:duzhi_02@qq.com" rel="noopener nofollow" class="external-link" href="https://congzhi.wiki/mailto:duzhi_02@qq.com" target="_blank">duzhi_02@qq.com</a> 联系我。欢迎任何类型的留言！]]></description><link>https://congzhi.wiki/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Mar 2025 05:29:54 GMT</pubDate></item><item><title><![CDATA[5. Release Build and Debug Build]]></title><description><![CDATA[ 
 <br>release build and debug build<br>#ifdef DEBUG
printf("Debugging info...\n");
#endif

#ifdef NDEBUG
printf("This version is for releasing\n");
#endif
]]></description><link>https://congzhi.wiki/building-and-version-control/5.-release-build-and-debug-build.html</link><guid isPermaLink="false">Building and Version Control/5. Release Build and Debug Build.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 23 Mar 2025 14:15:13 GMT</pubDate></item><item><title><![CDATA[Git and Github (Part I)]]></title><description><![CDATA[ 
 <br><br>Git 是一种开源的分布式版本控制系统，在学习 Git 之前，我们先来了解<br>提供了对代码（不仅仅）的版本控制。<br><br><br>]]></description><link>https://congzhi.wiki/building-and-version-control/git-and-github-(part-i).html</link><guid isPermaLink="false">Building and Version Control/Git and Github (Part I).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 23 Mar 2025 15:58:31 GMT</pubDate></item><item><title><![CDATA[Alignment in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>The operating system provides us with an abstract view of how real memory works, giving us a virtual contiguous sequence of bytes to use. When an object is created, the system needs to allocate the object on the stack or heap memory, depending on how it is created, and you get a memory address to manipulate this object. This address is called the memory location.<br>(By the way, if you find a class with no data members in it, would it have zero memory cost? No, because it needs at least one byte to be instantiated in memory. Otherwise, chaos would ensue since you wouldn’t be able to obtain a unique address for that instance.)<br>class no_data_member{
	void printName(){
		std::cout &lt;&lt; "no_data_member" &lt;&lt; std::endl;
	}
};
int main(){
	no_data_member i; // occipies 1 byte of memory
}
<br>At this location, you need some contiguous space to store the object, so every object will have a size property, which you can get through the sizeof operator. And also, every complete object type has an alignment requirement property. This alignment is what we are going to talk about.<br><br>Alignment is an integer value of the size_t type representing the number of bytes between successive addresses at which objects of a type can be allocated. A valid alignment value is a non-negative integer that is a power of two. For example:<br>#include &lt;stdio.h&gt;
struct A{
	char c;  // size: 1, alignment: 1
	long l;  // size: 8, alignment: 8
	short s; // size: 2, alignment: 2
	int i;   // size: 4, alignment: 4
};

int main(){
	printf("sizeof struct A is: %ld\n", sizeof(A));
	// The alignment of a type can be queried with the `alignof` operator.
	printf("alignof struct A is: %ld\n", alignof(A));
}
<br>When we add up the struct size, we might expect the struct size to be 13 bytes, right? Wrong! We got 24 bytes instead. And we have an alignment of struct A being 8. What the heck is that?<br>The alignment requirement of the struct is determined by the member with the strictest (largest) alignment, which is long l with an 8-byte alignment. Therefore, the overall alignment of struct A is 8 bytes.<br>To satisfy the alignment requirement of all members of the struct, the compiler will insert padding after some of its members. The grey area in the picture below represents those inserted padding.<br><img alt="align_ex.png" src="https://congzhi.wiki/c-plus-plus/pics/align_ex.png"><br>In order to optimize the memory layout of the struct, we could:<br>#include &lt;stdio.h&gt;
struct A{
	char c;  // size: 1, alignment: 1
	long l;  // size: 8, alignment: 8
	short s; // size: 2, alignment: 2
	int i;   // size: 4, alignment: 4
};
// same member, but smaller size
struct B{
	char c;  // size: 1, alignment: 1
	short s; // size: 2, alignment: 2
	int i;   // size: 4, alignment: 4
	long l;  // size: 8, alignment: 8	
};

int main(){
	printf("sizeof struct A is: %ld\n", sizeof(A));
	// The alignment of a type can be queried with the `alignof` operator.
	printf("alignof struct A is: %ld\n", alignof(A));
	printf("sizeof struct B is: %ld\n", sizeof(B));
	// The alignment of a type can be queried with the `alignof` operator.
	printf("alignof struct B is: %ld\n", alignof(B));
}
<br>We see the struct B only used 16 bytes of memory. What happened here? We reduced the need for padding by arranging its members in a more efficient order. The padding in this struct is only 1 byte after char c like what I draw fellows:<br><img alt="align_ex2.png" src="https://congzhi.wiki/c-plus-plus/pics/align_ex2.png"><br>By optimizing the member order, we minimized the padding required to satisfy alignment requirements, resulting in a more compact memory layout for the struct.]]></description><link>https://congzhi.wiki/c-plus-plus/alignment-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Alignment in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sat, 22 Mar 2025 16:48:36 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/align_ex.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/align_ex.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ASLR for Safety (ENG)]]></title><description><![CDATA[ 
 <br>Inspired by <a data-href="Malloc in C (ENG)" href="https://congzhi.wiki/c-plus-plus/malloc-in-c-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Malloc in C (ENG)</a><br>Actually, I really should put this in operating system section......<br><br>ASLR is a computer security technique. Its primary purpose is to protect against memory corruption vulnerabilities. It is primarily a security feature used to prevent exploitation by making it harder for attackers to predict memory locations. <br>With ASLR, every time you run your program, the memory mapping will differ. We will demonstrate this phenomenon using an example just a second.<br>In this brief note, we will continue using the example from the malloc note. If you compile that code and run it multiple times, you will observe that the heap memory layout varies with each execution. This variability is a direct result of ASLR.<br>du@DVM:~/cpp$ ./proc
Size of struct linked_block is 16 bytes.
The address of first block is: 0x584b0525b6b0
The address of second block is: 0x584b0525b6d0
du@DVM:~/cpp$ ./proc 
Size of struct linked_block is 16 bytes.
The address of first block is: 0x59697921b6b0
The address of second block is: 0x59697921b6d0
du@DVM:~/cpp$ ./proc 
Size of struct linked_block is 16 bytes.
The address of first block is: 0x5659369f46b0
The address of second block is: 0x5659369f46d0
du@DVM:~/cpp$ ./proc 
Size of struct linked_block is 16 bytes.
The address of first block is: 0x61b7291d06b0
The address of second block is: 0x61b7291d06d0
<br>Modern operating systems enable ASLR by default. This is why, each time you run your program, the memory mapping is different. And you can disable ASLR using this:<br>setarch $(uname -m) -R ./proc
<br><br>When running your program in GDB, you will notice that the memory addresses remain consistent across executions. For instance:<br>(gdb) run
Starting program: /home/du/cpp/proc 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Size of struct linked_block is 16 bytes.
The address of first block is: 0x5555555596b0
The address of second block is: 0x5555555596d0
[Inferior 1 (process 12774) exited normally]
<br>This happens because ASLR is disabled by default in GDB. The reason for this is that GDB is designed for debugging. Consistent memory addresses are very important during debugging to allow for repeatable and predictable analysis of memory-related behaviors. <br>If you wish, you can enable ASLR in GDB using the following command:<br>set disable-randomization off
]]></description><link>https://congzhi.wiki/c-plus-plus/aslr-for-safety-(eng).html</link><guid isPermaLink="false">C Plus Plus/ASLR for Safety (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Mar 2025 16:36:49 GMT</pubDate></item><item><title><![CDATA[Assert in C++ (NC)]]></title><description><![CDATA[ 
 <br>static_assert: a compile-time assert]]></description><link>https://congzhi.wiki/c-plus-plus/assert-in-c++-(nc).html</link><guid isPermaLink="false">C Plus Plus/Assert in C++ (NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 27 Feb 2025 14:41:55 GMT</pubDate></item><item><title><![CDATA[Auto in C++]]></title><description><![CDATA[ 
 <br><br>在 C++ 中，我们有各种各样的数据类型。我们有 int 、 long 、 float 、 double 还有表示字符串的 const char* 等等。我们每次定义一个变量的时候都要带上不同的类型符，好不麻烦。C++ 什么时候能像 python 那样做一些无所谓内置类型的变量定义呢？在 C++11 后，我们有 auto 关键字来帮我们做类似的类型推导。<br>简单来说，我们在定义类型的时候不需要再考虑它是什么类型了，编译器会帮我们做这些。甚至你可以让它帮你推导自定义的类类型。我们用下面的代码举一些例子：<br>class MyClass {
public:
    MyClass(int val) : i(val) {}
    int i;
};
auto func(){ // return type is deduced as int type, since C++14
	return 0;
}
int main() {
    int a = 0;
    auto b = a; // b is deduced as int type
    auto c = 0; // c is deduced as int type
    auto d = 3.14; // d is deduced as double type

    auto obj = MyClass{10}; // obj is deduced as MyClass type
    std::cout &lt;&lt; "obj.i = " &lt;&lt; obj.i &lt;&lt; std::endl; // Outputs: obj.i = 10

    return 0;
}
<br>auto 是一个占位符(placeholder)，在编译时，编译器会自动推导变量的类型或函数的返回类型。<br><br>有人可能会觉得 auto 的滥用可能导致变量类型或函数返回类型的混乱。但事实上，当你使用 auto 后，你不需要太担心什么类型推导错误的问题。相反地，一旦你使用 auto，你就应该使用到底。不然就可能导致你不希望看到的问题。我们用一个例子来说明，假设我们有一个 API，我们可以直接用 auto 来与 API 返回的类型相匹配，而不需要担心 API 返回类型的变化，例如：<br>#include &lt;string&gt;

char* API(int i) {
	char* status;
    if (i == 0) {
	    status = "OKAY";
    } else {
	    status = "false";
    }
	return status;
}

int main() {
    auto status_code = API(1); // status_code is deduced as char*
    std::cout &lt;&lt; status_code &lt;&lt; std::endl; // Outputs: false
}

<br>在上面的例子中，auto 会将 status_code 推导成 char* 类型。但如果 API 的返回类型变成标准库的 std::string，你仍不需要担心，届时 auto 会推导 status_code 为 std::string 类型。如果你没有使用 auto，在这种情况下，你的源代码就需要随着 API 返回类型的改变而改变<br>但另一方面，当你使用 auto 之后，status_code 的类型将对你不可见。为了确定性，你也可以将 auto 去掉。<br>此外，你需要留意 auto 会忽略引用和 const 。如：<br>const int&amp; ref = x;
auto a = ref; // a is deduced as int type
const auto&amp;b = ref; // b has the same type as ref
<br><br>这部分将在 <a data-href="Decltype in C++#`decltype(auto)`" href="https://congzhi.wiki/c-plus-plus/decltype-in-c++.html#`decltype(auto)`" class="internal-link" target="_self" rel="noopener nofollow">Decltype in C++ &gt; `decltype(auto)`</a> 中介绍。]]></description><link>https://congzhi.wiki/c-plus-plus/auto-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Auto in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 25 Mar 2025 08:45:44 GMT</pubDate></item><item><title><![CDATA[Casting in C++ (NC)]]></title><description><![CDATA[ 
 <br><br><br>我们观察下面的一段代码，思考这两个问题：pi_int 的值是怎么转换成 3 的？直接输出 355/113 为什么是整数 3 ？<br>#include &lt;iostream&gt;
int main(){
	int pi_int = 3.14159;
	std::cout &lt;&lt; pi_int &lt;&lt; std::endl; // 3
	std::cout &lt;&lt; 355/113 &lt;&lt; std::endl;// 3
	return 0;
}
<br>这两个问题都和 implicit narrowing conversion 有关。当我们运行 int pi_int = pi; 时，由于类型不同，这里会发生 narrow conversion（ casting 的一种）。会损失相关的数据和精度，将结果截断到整数个位，损失小数的精度。<br>在执行 std::cout &lt;&lt; 355/113 &lt;&lt; std::endl; 时，编译器会先检查除数和被除数的类型。这两种类型都是 int 类型，所以编译器断定商数应该是 int 类型的，在运行这行代码时也会出现截断。要输出正确的值，我们可以将类型显式地告诉编译器或者显式地使用浮点字面量类型。如：<br>#include &lt;iostream&gt;
int main(){
    std::cout &lt;&lt; (double)355/(double)113 &lt;&lt; std::endl; // 3.14159
    // or, explicitly use the float literals
    std::cout &lt;&lt; 355.0/113.0 &lt;&lt; std::endl; // 3.14159
    return 0;
}
<br>这种将一种类型变成另一种类型的方式就是我们所说的强制类型转换，这是一种 C-style casting。<br>上述的这些类型转换我们喜欢么？可能一般，因为它们不一定保证类型安全。除了可能发生的截断之外，编译器解析不同类型的方式也是不一样的，如果你把一个 int 类型值赋给 char 类型变量，输出 char 后你并不会看到一个整型数，而大概率是一个字符。<br>int val = 65;
char c = val;          // implicit conversion
std::cout &lt;&lt; c;        // prints out 'a'
std::cout &lt;&lt; (int)c;   // prints out 65

int val2 = 256;
char danger = val2; // undefined behavior
<br>为了类型安全，在 C++11 后引入的列表初始化禁止这种 narrowing conversion。<br>int pi = 3.14; // okay
int pi{3.14}; // error
<br><br>]]></description><link>https://congzhi.wiki/c-plus-plus/casting-in-c++-(nc).html</link><guid isPermaLink="false">C Plus Plus/Casting in C++ (NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 04 Mar 2025 14:19:26 GMT</pubDate></item><item><title><![CDATA[Character Literal & String Literal in C++]]></title><description><![CDATA[ 
 <br><br><br>在我们了解了整数型字面量和浮点型字面量之后，这篇文档我们来学习什么是字符字面量和字符串字面量。首先，我们来看一看最常见的字符字面量和字符串字面量。<br><img alt="std_ascii.png" src="https://congzhi.wiki/c-plus-plus/pics/std_ascii.png"><br>普通字符字面量就是我们常用 char 类型来表示的标准 ASCII 字符。 char 类型只占 1 个字节，能表示的数值在 0 - 255 这 256 个数字，而用来表示标准的 ASCII 绰绰有余（不包含 EASCII ）。普通字符字面量在 C++ 中有这几种表示形式：<br>char a1 = 'a';      // basic character, ASCII value of 'a' is 97
char a2 = '\x61';   // using escape sequence, equals to '\141' as in octal
char a3 = 0x61;     // direct hexadecimal value, equals to a3 = 97;
<br>第一种形式适合用于表示那些在 ASCII 中可显示的字符，上图从 0x21(32) 到 0x7E(126) 都是可显示字符。而那些不可显示的字符我们通常用转义字符来表示，比如换行符 \n 和水平制表符 \t，你也可以用转移字符表示可显示的字符。因为每个 ASCII 字符在表中都有一个数字与之对应，你也可以直接使用这些数值来对 char 类型变量赋值。<br><br>"String is an array of characters"，不难理解，普通字符串字面量就是由普通字符字面量构成的字符序列。这些字符序列要在双引号 " " 中进行表示。里面的字符可以是标准 ASCII 字符和转义字符。普通字符串字面量的类型是 const char[N] 或 const char*。为了知道结尾的位置，编译器会在字符串末尾添加一个空字符 \0。<br>const char* str1 = "Hello, world"; // Same as const char[] str1 = "Hello, World!";
const char* str2 = "Line1\nLine2";
const char* str3 = "Hello,\0world"; // only prints "Hello,"
<br>在这个例子中的三个普通字符串字面量在内存中如下图所示：<br>
<img alt="string_literal.png" src="https://congzhi.wiki/c-plus-plus/pics/string_literal.png"><br>
C++11 引入了原始字符串字面量，这也是一种普通字符串字面量。和上面的用双引号表示方法不同的是，原始字符串字面量以 R"()" 的形式表示。允许字符串中包含反斜杠和引号而不用转义。我们接着用上面的例子举例：<br>const char* str1 = R"(Hello, world)";
const char* str2 = R"(Line1
Line2)";
const char* str3 = R"(Hello,\0world)"; // prints Hello,\0world
<br><br>Unicode 是一个字符集，旨在包含全世界上所有的字符和符号，它兼容 ASCII 。UFT(Unicode Transformation Format) 是一系列用于编码 Unicode 字符的标准。<br><br>UFT-8 字符字面量能够表示的字符和普通字符字面量能表示的字符是相同的（0x00 - 0x7F），都只能表示标准 ASCII 字符。所以UFT-8 字符字面量的一个字符只占用 1 字节。<br>UFT-8 表示字面量格式如下：<br>char a = u8'a'; // until C++20
char8_t a = u8'a'; // since C++20
<br>在 C++20 之前，我们用 char 类型来表示 UFT-8 字符字面量，因为 Unicode 兼容 ASCII 嘛。但是在 C++20 之后，我们用 char8_t 类型来表示 UFT-8 的字符字面量。为了保持统一。<br><br>// Until C++20
const char[] c = u8"Hello, world!";
const char[] c2 = u8R"(Hello, world!)";

// Since C++20
const char8_t[] c = u8"Hello, world!";
const char8_t[] c2 = u8R"(Hello, world!)";
<br>普通和 UFT-8 d 字符串字面量统称为narrow string literals.<br><br><br>虽然 char 类型表示的字符还能扩容到 256 个。但是对于世界上这么多字符符号，256 个完全是不够用的。为了表示比普通字符集更大的字符集，在 C++ 中，我们有宽字符或者叫长字符字面量。在不同的平台，宽字符大小的实现可能有所不同，通常是 2 字节（UFT-16）或是 4 字节（UFT-32）。字节数多了，能够表示的字符数量也就指数级别的增多。2 字节宽字符可以表示 65536 个字符，4 字节宽字符可以表示超过 400 万个字符。<br>宽字符用 wchar_t 类型来表示，我们有下面的例子：<br>wchar_t a = L'哈'; // Allocate 2/4 bytes of memory depending on the system
std::wcout &lt;&lt; a &lt;&lt; std::endl;
std::wcout &lt;&lt; L'β' &lt;&lt; std::endl;
<br>奇怪的是宽字符的前缀不为 W 而是 L，令人百思不得其解。<br><br>一切尽在不言中。<br>const wchar_t* c = L"Hello, world!";
const wchar_t* c2 = LR"(Hello, world!)";
<br><br>你现在知道了字符字面量和字符串字面量表示上的联系，我们最后再来看看 C++ 中的最后两种字符字面量：UFT-16 字符字面量和 UFT-32 字符字面量。<br><br>UFT-16 字符用 char16_t 类型表示，单个 char16_t 字符占用 2 字节内存，可以表示 65536 个不同的字符。UFT-32 字符用 char32_t 类型表示，单个 char32_t 字符占用 4 字节内存，可以表示 4,294,967,296 个不同的字符。<br>UFT-16 和 UFT-32 表示字面量的格式如下：<br>char16_t a = u'a';
char32_t a = U'a';
<br><br>// UFT-16 string literals
const char16_t* c = u"Hello, world!";
const char16_t* c2 = uR"(Hello, world!)";
// UFT-32 string literals
const char32_t* c = U"Hello, world!";
const char32_t* c2 = UR"(Hello, world!)";
]]></description><link>https://congzhi.wiki/c-plus-plus/character-literal-&amp;-string-literal-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Character Literal &amp; String Literal in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 28 Feb 2025 19:29:45 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/std_ascii.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/std_ascii.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Concurrency in C++]]></title><description><![CDATA[ 
 <br><br><br>我们在操作系统课程中了解到过并发和并行的概念，并发和并行都为我们提供了一种多个线程在同时运行的宏观感受。在多核机器上，不同的线程可以并发执行，也可以并行执行。在我们用户的视角上，线程好像都是并行执行的，但微观上它们可能是交替轮流地执行，也就是并发。<br>对于这两个概念，我们可以这样理解：并发是操作系统通过时间片轮转提供的，而并行是硬件平台提供的（多核CPU）。对于开发高并发程序，我们的目标可能是降低使用延迟，充分利用多核心的性能。通过封装，我们可以在C++线程库中使程序并发执行。<br><br>在早期的 C++ 中，标准库中并不包含相关的线程机制，你要是需要创建线程执行流，你就得调用第三方的库函数（pthread, Boost, Thread Building Block）。关于 POSIX Thread，我们在操作系统的系列课程中已经了解了许多。你可以在 <a data-tooltip-position="top" aria-label="7. Thread and Concurrency > 第二课 The POSIX Thread" data-href="7. Thread and Concurrency#第二课 The POSIX Thread" href="https://congzhi.wiki/congzhi's-os-series/7.-thread-and-concurrency.html#第二课_The_POSIX_Thread" class="internal-link" target="_self" rel="noopener nofollow">pthread</a> 进一步了解 pthread 库提供的线程 API 。<br><br>直到 C++11，也就是 pthread API 初次 release 的 16 年后，标准库才在语言层面封装了自己的线程库。现在，你只需要用 std::thread 来创建一个线程对象。标准库中的 std::thread 简化了线程的创建和使用，屏蔽了操作系统平台带来的差异性，我们还能享受 RAII 带来的资源的自动管理。<br>在多线程的程序中，每个运行的进程都需要至少包含一个（主线程）的线程执行流。由于同一进程下的不同线程共享进程资源，所以不恰当的多线程程序就很容易出现竞态条件导致。在本文档中，我们也会覆盖C++中的同步互斥的相关内容（std::mutex和std::atomic&lt;T&gt;）。<br><br><br><br>如下，我们用标准库的 std::thread 很轻易的创建了一个线程执行流。std::thread的构造函数的参数表示你想让线程执行的任务，即任何可调用对象。<br>#include &lt;iostream&gt;
#include &lt;thread&gt;

void new_thread(){
    std::cout &lt;&lt; "Creating a thread\n" &lt;&lt; std::endl;
}
int main(){
	std::cout &lt;&lt; "In main thread." &lt;&lt; std::endl;
    std::thread newThread(&amp;new_thread);
    return 0;
}
<br>由于函数很小，我们还可以用 Lambda 表达式来简化代码：<br>#include &lt;iostream&gt;
#include &lt;thread&gt;

int main(){
	std::cout &lt;&lt; "In main thread." &lt;&lt; std::endl;
    std::thread newThread([](){ std::cout &lt;&lt; "Creating a thread\n"; });
    return 0;
}
<br>运行这段代码，你大概率会得到一个 Abort 。这是因为主线程提前退出而没有等待子线程结束。为什么会得到 abort，你可以参照 <a data-tooltip-position="top" aria-label="7. Thread and Concurrency > 第二课 The POSIX Thread > 2.1.4 Join the Family `pthread_join()`" data-href="7. Thread and Concurrency#第二课 The POSIX Thread#2.1.4 Join the Family `pthread_join()`" href="https://congzhi.wiki/congzhi's-os-series/7.-thread-and-concurrency.html#第二课_The_POSIX_Thread" class="internal-link" target="_self" rel="noopener nofollow">joining</a> 。<br><br>当线程执行结束，线程变得无事可做，我们描述这种执行结束的线程为 joinable。即调用线程和被调用线程两个执行流合并(join) 为一个执行流。这个时候我们就该调用std::thread.join();函数来回收线程的资源（调用其析构函数）。值得注意的是， join 操作会阻塞调用线程，直到被调用的线程完成执行。<br>std::thread new_Thread([](){std::cout &lt;&lt; "Creating a thread\n";});
if (new_Thread.joinable()) {
    new_Thread.join();
}
<br><br>join()方法提供的阻塞调用线程在下面这种简单的例子中是线程安全(thread safe) 的。因为这两个线程实际上是同步的，我们并不需要担心有任何数据竞争(data race) 的问题。<br>int dataVar = 0;
std::thread new_Thread([](){
	std::cout &lt;&lt; "Creating a thread\n";
	dataVar = 15;
});
std::cout &lt;&lt; "Doing my work...\n";
if (new_Thread.joinable()) {
    new_Thread.join();
}
std::cout &lt;&lt; "I have read:" &lt;&lt; dataVar &lt;&lt; std::endl;
<br><br>当你将这行代码std::cout &lt;&lt; "I read:" &lt;&lt; dataVar &lt;&lt; std::endl;放到join()前面就会有这种未定义行为的出现，你会看到输出不确定的dataVar。<br>int dataVar = 0;
std::thread new_Thread([](){
	std::cout &lt;&lt; "Creating a thread\n";
	dataVar = 15;
});
std::cout &lt;&lt; "Doing my work...\n";
std::cout &lt;&lt; "I have read:" &lt;&lt; dataVar &lt;&lt; std::endl;
if (new_Thread.joinable()) {
    new_Thread.join();
}
<br><br><br><br>if&nbsp;*this&nbsp;has an associated thread (joinable()&nbsp;==&nbsp;true), calls&nbsp;request_stop()&nbsp;and then&nbsp;join().<br><br><br>如果你对数据竞争的概念还不够明晰，下面这个经典的例子能帮助你理解数据竞争及其危害。这段代码逻辑上看起来没问题，但实际操作每次&nbsp;counter++;&nbsp;时，都会将&nbsp;counter&nbsp;从内存读取到寄存器，对寄存器中的值进行操作，然后将结果写回内存。乍看之下似乎没问题，但麻烦就出在这里。<br>运行第一个例子时，你会发现&nbsp;counter&nbsp;的输出值远远小于&nbsp;20000000，而不是期望的&nbsp;20000000。原因可能是：线程&nbsp;A&nbsp;将&nbsp;counter&nbsp;的值取到寄存器中，线程&nbsp;B&nbsp;也将值取到另一个寄存器，两个线程分别操作后各自将结果写回内存。我们期望的是取值到写回之间的操作不间断，但实际上，两次加法操作的结果只写回了一次。<br>#include &lt;stdio.h&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

int counter = 0;

int main(){
	std::thread newThread([](){
        for (int i = 0; i &lt; 10000000; i++)
        {
            counter++; 
        }   
    });
	for(int i = 0; i &lt; 10000000; i++){
		counter++;
	}
    newThread.join();
	printf("I counted: %d\n", counting);
	return 0;
}
<br>运行后的结果可能是：<br>du@DVM:~/Desktop/DSA$ for i in {1..10}; do    ./stack; done
Counting is 10586215
Counting is 11715366
Counting is 10550633
Counting is 11083560
Counting is 10850192
Counting is 10812720
Counting is 10717796
Counting is 10972930
Counting is 11482931
Counting is 11098842
<br>而通过使用 std::atomic 将 counter 定义为原子变量，为其提供原子性，我们就可以得到我们想要的输出。这里面的逻辑就是当我们进行 counter++; 操作时，原子性使得从读取到寄存器、对寄存器中的值进行加1操作和写回这些操作是不间断的，从而避免了数据竞争。<br>#include &lt;stdio.h&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;

std::atomic&lt;int&gt; counter = 0;

int main(){
	std::thread newThread([](){
        for (int i = 0; i &lt; 10000000; i++)
        {
            counter++; 
        }   
    });
	for(int i = 0; i &lt; 10000000; i++){
		counter++;
	}
    newThread.join();
	printf("I counted: %d\n", counting.load());
	return 0;
}
<br><br><a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/cpp/atomic/atomic" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/cpp/atomic/atomic" target="_blank">std::atomic - cppreference.com</a><br><br>C++标准库并没有直接提供自旋锁，但我们可以利用原子变量来实现如下的自旋忙等待：<br>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
int main(){
    std::atomic&lt;bool&gt; ready = false;
    std::thread chld_thread = std::thread([&amp;](){
        while(!ready){
        }
        printf("HELLO FROM CHILD.\n");
    });
        
    printf("CHILD, WAKE-UP.\n");
	ready = true;
    chld_thread.join();
    return 0;
}
<br>在这里，我们需要确保忙等待是有限的等待，不然可能会造成死锁问题。<br><br><br>虽然没有提供自旋锁，但 C++标准库提供了互斥锁这种二元信号量。在使用互斥锁前，我们需要包含头文件 #include &lt;mutex&gt; 。同样是上面的例子，互斥锁的实现方式如下：<br>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
int main(){
    std::mutex mtx;;
    std::thread chld_thread = std::thread([&amp;](){
        mtx.lock();
        printf("HELLO FROM CHILD.\n");
    });
        
    printf("CHILD, WAKE-UP.\n");
	mtx.unlock();
    chld_thread.join();
    return 0;
}
<br>与自旋锁不同，阻塞锁并不会浪费CPU资源。如果条件不满足，它会将线程阻塞起来。与我们在操作系统课程中学习的pthread相比，C++的std:mutex相当于对pthread的封装。<br><br><br><br>那假如加锁之后程序出现异常退出怎么办？上面的代码是 thread safe 的，但并不是 exception safe 的。假如线程在解锁前异常退出，那么解锁操作将永远无法完成，死锁就会发生。C++ 为我们提供了 RAII ，我们可以将清理和 mutex 解锁操作都放到析构函数中去完成，确保 exception safe。<br>C++ 为我们提供了 std::lock_guard&lt;T&gt; ，它接受一个 BasicLockable 的类型参数，即它只接受特定的锁类型。为了满足对 BasicLockable 的要求，规定我们必须在类类型中提供 lock() 和 unlock() 的成员函数，不然就会导致编译出错。下面是使用 std::lock_guard&lt;T&gt; guard 自定义锁的例子：<br>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

class myLock{
public:
    void lock(){
        std::cout &lt;&lt; "locked" &lt;&lt; std::endl;
    }
    void unlock(){
        std::cout &lt;&lt; "unlocked" &lt;&lt; std::endl;
    }
};
int main(){
    myLock lk;
	std::cout &lt;&lt; "In main thread." &lt;&lt; std::endl;
    std::thread myThread([&amp;lk](){ 
                                std::lock_guard&lt;myLock&gt; lock(lk); // calls myLock::lock()
                                std::cout &lt;&lt; "Hello, this is thread.\n"; 
                            }); // calls myLock::unlock() automatically
    myThread.join();
    return 0;
}
<br>一般而言，我们使用 std::lock_guard 作为 std::mutex 的 wrapper。当 std::lock_guard 对象被创建时，立即锁定传递的 std::mutex。要是 std::lock_guard 对象超出其作用域（例如函数返回或异常抛出）时，它的析构函数会自动解锁 std::mutex。这就是 std::lock_guard&lt;T&gt; 的作用，确保在异常发生时资源也能得到正确释放。<br>下面是一个例子：<br>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

std::mutex mtx;
std::vector&lt;int&gt; data;

void addData(int value) {
    std::lock_guard&lt;std::mutex&gt; lk(mtx); // Locks the mutex
    data.push_back(value); // If this throws, the mutex is still unlocked
}

int main() {
    try {
        addData(42);
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    return 0;
}
<br><br>我们有 unique_ptr，我们也有unique_lock。unique_lock确保当前锁的持有者是唯一的。相比于lock_guard，std::unique_lock更加地灵活。std::unique_lock同样遵循RAII，你可以在一个作用域内加锁和解锁多次，相比于lock_guard ，你还可以对锁的所有权进行转移。<br>#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

std::mutex mtx;
std::vector&lt;int&gt; data;

void addData(int value) {
    std::unique_lock&lt;std::mutex&gt; lk(mtx); // Locks the mutex
    data.push_back(value); // If this throws, the mutex is still unlocked
    lk.unlock(); // Manually unlock the mutex
    // Do some other work
    lk.lock(); // Lock the mutex again if needed
}

int main() {
    try {
        addData(42);
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    return 0;
}
<br><br>在C++17引入了std::scoped_lock&lt;Ts...&gt;作为std::lock_guard&lt;&gt;的升级版。scoped_lock&lt;&gt;允许你一次性对多个 mutexes 进行锁定。C++17 还引入一项新特性 CATD(Class Template Argument Deduction)，类模板参数推导。CTAD 通过自动推导模板参数类型，使得代码更加简洁和易读。<br>template &lt;typename T1, typename T2&gt;
struct Pair {
    T1 first;
    T2 second;
    Pair(T1 f, T2 s) : first(f), second(s) {}
};
Pair&lt;int, double&gt; p(42, 3.14);
Pair p(42, 3.14); // CATD to Pair&lt;int, double&gt;

<br><br><br><br><br>std::condition_variable 是一种同步原语，用于阻塞一个或多个线程，直到某个条件变为真。它通常与 std::mutex 一起使用，以确保对共享数据的访问是线程安全的。<br><br><br><br>#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

bool videoLoader(size_t video_size){


}
<br><br><br><br>]]></description><link>https://congzhi.wiki/c-plus-plus/concurrency-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Concurrency in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 04 Mar 2025 18:10:20 GMT</pubDate></item><item><title><![CDATA[Const in C++]]></title><description><![CDATA[ 
 <br><br>现代C++中，我们会用const来来做以下的三件事情：<br>
<br>定义一个常符号/常量；
<br>传递一个不可修改的参数；
<br>定义常成员函数以防止潜在的修改；
<br>对于第一种，constexpr 通常是更好的选择。对于 const 而言，最主要的作用就是用指针或引用传递参数、返回值时防止修改指令 (modifiable operand) 对参数和返回值的修改。防止修改指令对参数/返回值的修改，实际上就是将潜在的运行时 bugs 转换成了编译时的一些错误。而通常情况下，编译时错误很难被忽略，所以使用 const 可以让我们更好地创建接口 (interfaces) 。<br>而 constexpr 的职责是将运行时的一些计算转换成编译时计算。<br><br>在使用const的时候，我们经常看到：<br>int const number = 123456;
char const msg[] = "hello";
<br>上面的示例中，我们使用const来定义一些不可修改的类型，第一个定义了一个不可修改的int类型，下面定义了一个用const char所组成的array。这些类型的共同点是可读但不可修改（写）。<br><br>这些不可修改的类型只有在初始化的时候给初值，并且C++要求const类型的对象必须初始化。<br>namespace example{
	int const un_initialized_;  // Error: missing initializer.
	extern int const initialized_;  // Ok: this is a declaration, not a def
}
<br><br>
Constexpr is conster than const.
<br>在 C/C++ 中，在 array 中对维度的定义也必须是一个常值，叫做 integer constant expression。<br>int x[n];  // Error
int y[10]; // OK

int const level = 10;
int x[2 * level + 1];  // OK
<br>在定义一个位域长度时也是一样的。<br>int bf: W; // Firld width, W must be constant.
<br>C++允许你将一个非const对象用const来初始化。下面的程序允许你在运行时初始化变量 level，也因此，在编译时的level不是一个const object，对应的表达式也不再是constant expression。<br>int n = 10;
int const level = n;  // Ok
int x[2 * level + 1]; // Error, this is not a constant expression
<br>constexpr 就是在这种情况下诞生的，一个 constexpr 的对象必须用一个 constant expression 来初始化：<br>int n = 10;
constexpr int m = n; // Not ok, n is not a constant expression.
constexpr int l = 10; // Ok, 10 is a const expression.
<br><br>每个对象和函数的声明都有两个部分：declaration specifiers 和 declarator。在下面的例子中前面一长串static unsigned long int都是declaration specifiers，后面的*x[N]是declarator。<br>static unsigned long int *x[N];
<br>Declaration specifiers进一步又分为type specifier（int、unsigned、long等）和non-type specifier（extern、static、inline等）。<br><br>Declarator是一个declarator-id，围绕着一些operators。上面的例子中，x就是这个declarator-id，*和[]都属于operator。这些operators有一定的优先级关系。<br><br>根据优先级关系，我们能够轻易说出后面的*x[N]是一个array of pointers。而我们很容易能够想清楚，(*x)[N]就是一个指针指向一个array of N integers。<br><br>我们提到过，Declaration specifiers进一步又分为type specifier和non-type specifier。它们分别的作用是什么？假如我们有下面的声明：<br>static unsigned long int *x[N];
<br>其中static是修饰declarator-idx的，其他的type specifiers都是修饰其他的type specifier。所以下面的几种表达都是一样的：<br>const unsigned int x;
unsigned int const x;
unsigned const int x;
int const unsigned x;
<br><br>在我们之前学习的过程中，常常会困惑于是指向常量的指针？还是常指针指向一个变量？我们需要注意：const是一个type specifier，而constexpr是一个non-type specifier。<br>constexpr unsigned long int *x[N]; // 指向变量数组的常指针 
const unsigned long int *x[N]; // 指向常量的数组指针
unsigned long int *const x[N]; // 指向变量数组的常指针
<br><br>非const类型可以转换成const类型的变量，但是反过来并不成立。const相当于一种保证，使用变量的函数或表达式（借），可以使用const保证原先的变量（被借）不被改变。但是反过来，如果变量本来就不允许被改变，但是函数或表达式不提供不被改变的保证，那么就会出错。<br>int ver;
const int const_ver = 10;

int add1(const int const_ver, const int ver); // ok
int add2(const int const_ver, int ver); // ok
int add3(int const_ver, int ver); // error
<br>add a const is ok, but not to lose it.(同样适用于volatile, const-volatile 被称为CV qulifier)]]></description><link>https://congzhi.wiki/c-plus-plus/const-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Const in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 02 Mar 2025 18:36:18 GMT</pubDate></item><item><title><![CDATA[Consteval in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>After learning about the constexpr specifier, we have got some understandings about compile-time optimization. In this note, let's explore the consteval specifier.<br>The consteval specifier was introduced in C++20 and it declares a function as an "immediate function", meaning that every call to the function must produce a compile-time constant expression. This enforces that the function is always evaluated at compile-time.<br>You can put constexpr anywhere, but consteval is only allowed in function and function template declarations.<br><br>Our question here is: what's the different between constexpr and consteval? We have one main difference though. The constexpr specifier does not provide a guarantee about function evaluation at compile-time, which means the the machine code may vary depending on the compiler. However, consteval can give you a guarantee, ensuring Compile-Time Function Execution(CTFE).<br>For example, GCC may be strict about CTFE, making every possible constexpr declared function inlined and a constant expression at compile-time. On the other hand, MSVC may be more lenient about CTFE, possibly not performing the work at compile-time. And if the constexpr function do executing at run-time which we would not like to, the compiler won't complain anything about it.<br>Let's dive into an example we are familiar with:<br>#include &lt;iostream&gt;

constexpr int add(int a, int b){
    return a + b;
}

int main() {
    int a = 100; // no constexpr declared this time
    int b = 200; // no constexpr declared this time
    int c = add(a, b); // no constexpr declared this time
    return 0;
}
<br>After compilation, let's see what we get:<br>add(int, int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 100
        mov     DWORD PTR [rbp-8], 200
        mov     edx, DWORD PTR [rbp-8]
        mov     eax, DWORD PTR [rbp-4]
        mov     esi, edx
        mov     edi, eax
        call    add(int, int)
        mov     DWORD PTR [rbp-12], eax
        mov     eax, 0
        leave
        ret
<br>The add() function is back, which means the function will execute at runtime. This is because the variables a and b are regular variables, while a constant expression evaluation cannot depend on any runtime-modifiable regular variables. Even with constexpr, compiler cannot give you a guarantee about CTFE.<br>But with consteval, you will get a compiler error instead. This is because the function add is declared consteval, but the compiler cannot determine the function value at compile-time with regular values.<br>#include &lt;iostream&gt;

consteval int add(int a, int b){
    return a + b;
}

int main() {
	const int a = 100; // constexpr declaration will also work
	const int b = 200; // constexpr declaration will also work
	int c = add(a, b); // okay
	int c2 = add(a, add(a, b)); // okay
	
    int d = 100; // error, must be constant expression
    int e = 200; // error, must be constant expression
    int f = add(d, e); // error, add(a, b) is not a constant expression
    return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/consteval-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Consteval in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 02 Mar 2025 08:54:28 GMT</pubDate></item><item><title><![CDATA[Constexpr in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>We always want our programs to be faster and faster, and people are constantly searching for algorithms that make our programs run swiftly at runtime. Typically, these algorithms calculate a number or perform other tasks. The lower the time complexity, the better the algorithm.<br>Since C++11 introduced the constexpr specifier, we can evaluate the value of entities at compile time, allowing the compiler to determine the results during the compilation process. This can significantly improve runtime performance by shifting some of the work from runtime to compile-time, thus it's called compile-time optimization.<br>Additionally, with the constexpr specifier, you can catch errors at compile time, making the code even safer. However, there is a trade-off because performing all calculations at compile-time makes the process compiler-dependent. The result may vary with different compilers.<br><br>Let's first go dive in a real example to see how the compile-time optimization happens. This code example following below will serve as our first example today:<br>#include &lt;iostream&gt;

int add(int a, int b){ // No constant expression
    return a + b;
}

int main() {
    int a = 100;
    int b = 200;    
    int c = add(a, b);
    return 0;
}
<br>This example demonstrates a simple function add that adds two integers. In the main function, we call add with a and b as arguments. Currently, the function does not use constexpr, so the addition is performed at runtime.<br>After compilation:<br>add(int, int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 100
        mov     DWORD PTR [rbp-8], 200
        mov     edx, DWORD PTR [rbp-8]
        mov     eax, DWORD PTR [rbp-4]
        mov     esi, edx
        mov     edi, eax
        call    add(int, int)
        mov     DWORD PTR [rbp-12], eax
        mov     eax, 0
        leave
        ret
<br>So you can see how many assembly instructions there are needed to be execute in the run-time.<br>With the using of constexpr , our C++ code turns into:<br>#include &lt;iostream&gt;

constexpr int add(int a, int b){
    return a + b;
}

int main() {
    constexpr int a = 100;
    constexpr int b = 200;    
    constexpr int c = add(a, b);
    return 0;
}
<br>After compilation without any compiler optimization:<br>main:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], 100
        mov     DWORD PTR [rbp-8], 200
        mov     DWORD PTR [rbp-12], 300
        mov     eax, 0
        pop     rbp
        ret
<br>You see, we don't have the add() function symbol here. Why? You may have guessed it, the constexpr specifier implies inline semantics. <br><br>The previous example might not be very intuitive, now let's do another experiment to see how awesome constexpr can be.<br>#include &lt;iostream&gt;

int fibonacci(int n) {
    return (n &lt;= 1) ? n : (fibonacci(n - 1) + fibonacci(n - 2));
}
int main() {
    int fib10 = fibonacci(10);
    int fib20 = fibonacci(20);
	int fib30 = fibonacci(30);
	int fib40 = fibonacci(40);
    std::cout &lt;&lt; "Fibonacci(10): " &lt;&lt; fib10 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Fibonacci(20): " &lt;&lt; fib20 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Fibonacci(30): " &lt;&lt; fib30 &lt;&lt; std::endl;
	std::cout &lt;&lt; "Fibonacci(40): " &lt;&lt; fib40 &lt;&lt; std::endl;
    return 0;
}
<br>This code calculates the Fibonacci sequence at runtime. The output might look like this:<br>du@DVM:~/cpp$ time ./proc 
Fibonacci(10): 55
Fibonacci(20): 6765
Fibonacci(30): 832040
Fibonacci(40): 102334155

real    0m0.604s
user    0m0.600s
sys     0m0.003s
<br>And with constexpr, our source code look like this:<br>#include &lt;iostream&gt;

// constexpr function to calculate Fibonacci numbers at compile-time
constexpr int fibonacci(int n) {
    return (n &lt;= 1) ? n : (fibonacci(n - 1) + fibonacci(n - 2));
}

int main() {
    constexpr int fib10 = fibonacci(10);
    constexpr int fib20 = fibonacci(20);
	constexpr int fib30 = fibonacci(30);
    std::cout &lt;&lt; "Fibonacci(10): " &lt;&lt; fib10 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Fibonacci(20): " &lt;&lt; fib20 &lt;&lt; std::endl;
    std::cout &lt;&lt; "Fibonacci(30): " &lt;&lt; fib20 &lt;&lt; std::endl;
    return 0;
}
<br>With the use of constexpr, the output might look like this:<br>du@DVM:~/cpp$ time ./proc 
Fibonacci(10): 55
Fibonacci(20): 6765
Fibonacci(30): 832040
Fibonacci(40): 102334155

real    0m0.005s
user    0m0.003s
sys     0m0.002s
<br>You can see how crazy the difference is—in user time, the optimized version is 200 times faster! This demonstrates the significant impact of compile-time optimization using constexpr.<br><br>We have demonstrated the main idea about the constexpr specifier, which is to evaluate the value of the expressions at compile time. This means the compiler will provide a constant value at the compile-time (or literals, if you will). For this reason, the object declared by constexpr would imply a const semantics.<br>For example:<br>constexpr int i = 100;
i = 200; // error

int j = 100; // j is a regular value, which can be modified at runtime. A constant expression must not depend on runtime values.
/*
there might be some j value modification operations...
so you cannot say the j value down below in the compile-time
*/
constexpr int k = j; // error

<br>Here, we have some points to keep in mind. You must noted the right-hand side of constexpr variable declaration must be a constant expression. Because everything should be figured out at compile-time, thus everything should be known at compile-time. Otherwise, an error will occur.<br>Also, we saw the function declared by constexpr implies an inline semantics, and since C++17, the static data member declared by constexpr would imply inline semantics as well.<br>#include &lt;iostream&gt;
class myClass {
public:
	constexpr static int a = 50;
	// Equivalent to inline const static int a = 50;
	constexpr int a_square();
};
constexpr int myClass::a_square(){ // myClass::a_square would be inlined
	return myClass::a * myClass::a;
}

int main() {

    myClass obj;
    constexpr int i = obj.a_square();
    return 0;
}
<br>And variable/function template can be declared constexpr too.]]></description><link>https://congzhi.wiki/c-plus-plus/constexpr-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Constexpr in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sat, 01 Mar 2025 15:02:15 GMT</pubDate></item><item><title><![CDATA[Constinit in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>We have discussed constexpr and consteval, so in this note, let's delve into the details of constinit. The constinit specifier was introduced in C++20 along with consteval. While consteval specifies that a function must produce a constant expression at compile-time, it is easy to guess that constinit is used to ensure a variable must be initialized at compile-time, quite similar to how consteval applies to functions.<br>To use constinit, the approach differs from what we do with consteval. We mentioned that constexpr can be used anywhere, but it does not guarantee compile-time function execution. This is where consteval comes in—it is more strict and provides guaranteed compile-time function evaluation (CTFE) semantics. So, does the constinit specifier simply provide compile-time initialization to variables compared to constexpr? Nuh-uh!<br>The constinit specifier is only allowed to declare variables with static storage duration(global variable has this static semantics by default) and thread-local variables. This means that regular stack variables(automatic storage duration) cannot be declared as constinit. Here's some examples:<br>constinit int globalVar = 100; // Allowed because globalVar has static storage duration
int main() {
    constexpr int localVar = 100; // okay 
    constinit int localVar2 = 100; // Error: localVar has automatic storage 
    constinit static int staticVar = 100; // okay 
    return 0;
}
<br>In contrast to static storage duration, we have dynamic storage duration too. Objects with dynamic storage duration are often created and destroyed using the new and delete keywords. Since these objects are allocated and deallocated at run-time, you cannot force the compiler to allocate any memory for them at compile-time. Therefore, if you try to declare a variable with dynamic storage duration as constinit, it will cause you an error.]]></description><link>https://congzhi.wiki/c-plus-plus/constinit-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Constinit in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 03 Mar 2025 07:25:07 GMT</pubDate></item><item><title><![CDATA[Copying and Copy Constructors in C++]]></title><description><![CDATA[ 
 <br><br>拷贝是指将数据从一块内存复制到另一块内存。当我们在栈中进行拷贝时，栈中会出现两份相同的内存块。而当我们拷贝堆上的变量（对象）时，通常会将整个对象先搬到栈上，然后再复制一份到堆上。拷贝的过程涉及两次内存操作，可能会影响性能，如果堆上对象过大还可能引发栈溢出。为了避免拷贝带来的性能开销和不必要的对象，从而引入了<a data-tooltip-position="top" aria-label="Move Semantics in C++" data-href="Move Semantics in C++" href="https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">移动语义</a>。<br>所以当我们拷贝传参时，在函数内部对拷贝对象所作出的改变并不会影响我们原先内存中的数据。对象所占内存越大，拷贝所用的空间开销和时间开销就会越大。某些情况下，我们会尽量避免拷贝造成的开销。我们课堂上学习过两种方式：（1）指针 和 （2）引用。<br>我们下面先用一些简单的拷贝作为示例：<br>示例一：<br>int main(){
	int a = 10;
	int b = a;  // b对a的拷贝
	int* ptr1 = a;
	int* ptr2 = ptr1;   // ptr2对ptr1的拷贝	
	return 0;
}
<br>示例二：<br>void increment(int x) {
    x++;
}
int main() {
    int a = 5;
    increment(a);
    // a 仍然是 5
}
<br>我们将函数拆开放在主函数里面，像内联inline那样，就是如下这样：<br>// 内敛后的代码
int main() {
    int a = 5;
    {
		int x = a;
		x++;
	}
    // a 仍然是 5
}
<br><br>当我们使用指针进行值传递和值改变的时候，实际上仍然使用了拷贝，即指针的拷贝。但相比类对象的拷贝而言，拷贝指针的代价要小很多。我们将上面的代码改成如下的指针传递。我们发现a的值改变了，这是因为我们将a的地址赋值给了指针x。当我们改变指针x所指向的值（也就是a）时，a当然会改变了。<br>void increment(int* x) {
    (*x)++;
}
int main() {
    int a = 5;
    increment(&amp;a);
    // a 变为 6
}

// 相当于
int main() {
    int a = 5;
    {
		int* x = &amp;a;
		(*x)++;
	}
    // a 变为 6
}

<br><br>另一种避免拷贝的方式就是引用了，引用是对现有对象的别名，并不会创建新的对象。当我们用int&amp; x = a;时，a的引用x会直接指向对象的内存地址。这样子好像我们为x分配了内存用于存储&amp;a即a的地址。其实不然，引用和被引用对象共享同一个内存地址，因此对引用的任何修改都会直接反映在被引用对象上。<br>我们用链接视角可能更清楚一点。在C++中，引用（reference）和被引用对象在连接时的符号是一样的。引用只是被引用对象的别名，它们共享同一个内存地址。因此，对引用的任何操作实际上都是对原对象的操作。<br>void increment(int&amp; x) {
    x++;
}
int main() {
    int a = 5;
    increment(a);
    // a 变为 6
}

//相当于
int main() {
    int a = 5;
    {
		int&amp; x = a;
		x++;
	}
    // a 变为 6
}

// 相当于
int main() {
    int a = 5;
    {
	    a++;
    }
    // a 变为 6
}
<br>上面的例子很好的展示了引用的作用。我们创建了a的引用x，但x作为a的别名（其实就是a），当我们操作x实际也就是对a的操作。<br><br>This is why we need a copy constructor/copy assignment operator. That is - the rule of three.<br><br>在一个类中，由于我们没有定义拷贝构造函数，编译器会生成默认的拷贝构造函数进行浅拷贝。那究竟做了什么呢？我们创建了新的String对象string2，随后编译器将string对象中变量m_Buffer 和 m_Size;赋予string2中的变量。带来的后果就是string和string2的m_Buffer指向同一片内存区域。在析构的时候就会导致内存的双重释放。<br>#include &lt;iostream&gt;
#include &lt;string.h&gt;

class String
{
private:
    char* m_Buffer;
    unsigned int m_Size;
public:
    String(const char* str)
    {
        m_Size = strlen(str);
        m_Buffer = new char[m_Size + 1];
        memcpy(m_Buffer, str, m_Size + 1);
        std::cout &lt;&lt; "Constructor's been called." &lt;&lt; std::endl;
    }
    ~String()
    {
        delete[] m_Buffer;
        std::cout &lt;&lt; "Destructor's been called." &lt;&lt; std::endl;
    }
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; str);
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; str)
{
    stream &lt;&lt; str.m_Buffer;
    return stream;
}

int main(){

    String string = "CongZhi";
    String string2 = string;
    std::cout &lt;&lt; string &lt;&lt; std::endl;
    std::cout &lt;&lt; string2 &lt;&lt; std::endl;
    return 0;
}
<br>运行结果如下：<br>Constructor's been called.
CongZhi
CongZhi
Destructor's been called.
free(): double free detected in tcache 2
Aborted
<br>编译器所做的就是一个浅拷贝：<br>String(const String&amp; other)
{
	memcpy(this, &amp;other, sizeof(String));
}
// 也就是
String(const String&amp; other)
	: m_Buffer(other.m_Buffer), m_Size(other.m_Size)
{}
<br><br>如何避免上面的这种情况发生呢？我们可以用深拷贝。在上面浅拷贝的用例中，我们发现类对象的拷贝仅仅停留在指向string的指针上，但是我们期望对字符串本身的拷贝，而不是指向字符串的指针。我们定义一个拷贝构造函数来避免这种浅拷贝的情况发生。<br>String(const String&amp; other)
    : m_Size(other.m_Size)
{
    m_Buffer = new char[m_Size + 1];
    memcpy(m_Buffer, other.m_Buffer, m_Size + 1);
    std::cout &lt;&lt; "Cpoy constructor's been called." &lt;&lt; std::endl;
}
<br>但是我们不想在main()函数中打印，我们封装一个printStr()函数，用printStr()打印类对象会怎么样？<br>void printStr(String str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}
int main(){

    String string = "CongZhi";
    String string2 = string;
    printStr(string);
    printStr(string2);
    return 0;
}
<br>我们会调用非常多的构造和析构函数，这完全是不必要的。平白无故占用系统资源，这当然不是我们想看到的，所以我们应避免使用拷贝。我们可以用const引用，void printStr(String&amp; str)。<br>Constructor's been called.
Cpoy constructor's been called.
Cpoy constructor's been called.
CongZhi
Destructor's been called.
Cpoy constructor's been called.
CongZhi
Destructor's been called.
Destructor's been called.
Destructor's been called.
<br>使用引用后：<br>Constructor's been called.
Cpoy constructor's been called.
CongZhi
CongZhi
Destructor's been called.
Destructor's been called.
]]></description><link>https://congzhi.wiki/c-plus-plus/copying-and-copy-constructors-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Copying and Copy Constructors in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Feb 2025 07:35:42 GMT</pubDate></item><item><title><![CDATA[Decltype in C++]]></title><description><![CDATA[ 
 <br><br>decltype 是在 C++11 引入的关键字，用来推导 entity 或者 expression 的类型。它允许在编译时获取表达式的静态类型，用该类型声明变量、定义函数返回类型等。当需要保留引用、CV qualifier 等修饰符时，decltype 提供精确的类型推导。<br>一个简单的例子，下面是如何推导变量类型：<br>int a = 10; // 'a' is an int type variable
decltype(a) b = 20; // 'b' has the same type as 'a'

const int c_a = 10; // 'c_a' is a const int type variable
decltype(c_a) c_b = 20; // 'c_b' has the same type as 'c_a'

<br>下面是推导表达式类型的例子：<br>int a = 10;
double b = 3.14;
decltype(a + b) c = a + b;
<br><br>decltype 还能显性的指示函数的返回值，使用 decltype 配合 auto 将返回类型后置，被称为 trailing return type 。同样的，函数的返回类型将在编译时推导出来。这种写法尤其适合泛型编程。<br>template&lt;typename T, typename U&gt;
auto add(T a, U b) -&gt; decltype(a + b) {
    return a + b;
}
<br>template&lt;typename T, typename U&gt;
auto add(T a, U b) { // C++14
    return a + b;
}
<br>实际上，自 C++14，auto 也可以用于推导返回类型，那要 decltype 有什么好处呢？我们现在可以明确的好处有：declytpe 会保留所有的修饰符，而 auto 会忽略掉引用和 const。<br><br>使用 decltype(auto) 推导变量类型会保留引用、const 等修饰符。<br>#include &lt;type_traits&gt;

const int&amp; getVal();

int main(){
	auto i = getVal(); // i is deduced as int type
	static_assert(std::is_same_v&lt;decltype(i), int&gt;)
	
	decltype(auto) j = getVal(); // j is deduced as const int&amp; type
	static_assert(std::is_same_v&lt;decltype(j), const int&amp;&gt;)
	return 0;
}
<br>使用 decltype(auto) 推导表达式不需要尾置返回类型：<br>#include &lt;type_traits&gt;

decltype(auto) getVal(){

}

int main(){

	return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/decltype-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Decltype in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 25 Mar 2025 09:04:41 GMT</pubDate></item><item><title><![CDATA[Delegating Constructors in C++ (ENG, NC)]]></title><description><![CDATA[ 
 <br>]]></description><link>https://congzhi.wiki/c-plus-plus/delegating-constructors-in-c++-(eng,-nc).html</link><guid isPermaLink="false">C Plus Plus/Delegating Constructors in C++ (ENG, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Feb 2025 07:24:09 GMT</pubDate></item><item><title><![CDATA[Exception Control in C++ (NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/exception-control-in-c++-(nc).html</link><guid isPermaLink="false">C Plus Plus/Exception Control in C++ (NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:56:10 GMT</pubDate></item><item><title><![CDATA[Explicit Specifier in C++ (ENG)]]></title><description><![CDATA[ 
 <br>ref: <a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/cpp/language/explicit" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/cpp/language/explicit" target="_blank">explicit specifier - cppreference.com</a><br><br>In some official code, you may see the explicit specifier used inside a class, especially when specifying a constructor. Since C++11, this specifier is also be used for conversion functions and deduction guides. Today, I will take a peek at how this specifier works inside a class.<br>Before we delve into the technical details, let's first understand the word "explicit."<br><br>In the <a data-tooltip-position="top" aria-label="https://www.etymonline.com/word/explicitly#etymonline_v_32876" rel="noopener nofollow" class="external-link" href="https://www.etymonline.com/word/explicitly#etymonline_v_32876" target="_blank">dictionary</a>, the word "explicit" in English is barrowed from the French loanword "explicite" from the 1610s. It originally comes from the Latin word "explicitus" meaning "unobstructed", which is the variant past participle of the Latin verb "explicare" original meaning "unfold, explain".<br>The word "explicit" means "open to understanding, specific, clear" nowadays, which is similar to the old Latin "explicare," meaning "to unfold." You might say, "why don't you unfold/explain your language" to ask for a specific answer (equals to "why don't you explicate your language"). In Chinese, you may call it "显性、明确", indicating something should be obvious or specific.<br>The opposite "implicit" means "vogue, no specific", which refers to something implied or understood without being directly stated.<br><br>In C++, you may have heard about "implicit conversions" or "implicit casts," which act as follows:<br>class MyClass {
public:
    MyClass(int x) {
        // Constructor logic
    }
};

void someFunction(MyClass obj) {
    // Function logic
}

int main() {
    someFunction(42); // Implicitly converts 42 to MyClass using MyClass(int)
    return 0;
}
<br>Without the explicit specifier, the compiler will do implicit conversions. Meaning the compiler will automatically convert the input into a type-specific class or type, which can lead to unintended behavior because of the uncertainty and lack of definition.<br>To prevent implicit conversions and ensure that conversions are type-specific and intentional, you can use the explicit keyword. Here’s how it works:<br>class MyClass {
public:
    explicit MyClass(int x) {
        // Constructor logic
    }
};

void someFunction(MyClass obj) {
    // Function logic
}

int main() {
    // someFunction(42); // Error: cannot convert int to MyClass implicitly
    someFunction(MyClass(42)); // OK: Explicitly create a MyClass object
    return 0;
}
<br>By marking the constructor as explicit, you prevent unintended implicit conversions and ensure that object creation is always intentional and clear. This helps avoid errors and unexpected behavior in more complex scenarios.]]></description><link>https://congzhi.wiki/c-plus-plus/explicit-specifier-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Explicit Specifier in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:56:14 GMT</pubDate></item><item><title><![CDATA[Extern Keyword in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Static Keyword in C++" href="https://congzhi.wiki/c-plus-plus/static-keyword-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Static Keyword in C++</a><br><br>在学习 static 关键字的时候，我们了解到了内部链接性：被&nbsp;static&nbsp;修饰的变量和函数仅在定义它们的翻译单元（即当前.cpp文件）内可见。这种封装特性为代码模块化提供了基础。如果不加入 static 关键字，那么所有的全局变量和函数在所有的翻译单元中都可见，这就是所谓外部链接性。（局部变量不具有链接性）<br>我们用下面的例子来解释，我们有两个文件 a.cpp 和 main.cpp，也就是说我们有两个翻译单元：<br>// a.cpp
int global_var_a = 1;    // external definition with external linkage
static int static_var_a = 0; // internal linkage

int global_fun_a(void)   // external definition with external linkage
{
    int local_a = 1; // non-external
    b += local_a;
    return b;
}

static void staitc_func_a() // internal linkage
{
}
<br>在 a.cpp 中，我们定义了一个全局变量 global_var_a、一个静态变量 static_var_a 并用 extern 声明了一个变量 b 。后面，我们还定义了一个全局的函数和静态的函数。<br>我们上面所定义的所有全局的变量、函数都具备外部链接性。所有其他的 .cpp 文件都可以看到并使用这些全局符号，如在下面的 main.cpp 中所作的一样。<br>// main.cpp
extern int global_var_a; // external declaration with external linkage
extern int global_fun_a; // external declaration with external linkage

int main(){
	global_var_a = 100;
	global_fun_a();	
	return 0;
}
<br>但为什么在使用前，我用 extern 声明了这些全局变量？extern 的作用是告诉链接器这些符号是其他翻译单元的。因为链接器需要确保每个符号的单一定义规则。如果你不加 extern 链接器可能会误以为你在 main.cpp 里定义了一个未初始化的全局变量。extern 存在的意义就是为避免一定程度上的命名冲突。<br><br>在现代 C++ 中，我们常用 namespace 来封装全局变量，避免全局符号的精确定义。你也可以用 inline 请求编译器将某个全局符号内联化。<br><br>此外，我们还可能经常看到如下的 extern 用法：<br>// example.h
#ifndef EXAMPLE_H
#define EXAMPLE_H

#ifdef __cplusplus
extern "C" {
#endif

void my_c_function();

#ifdef __cplusplus
}
#endif

#endif // EXAMPLE_H
<br>通常我们在 C++ 中调用 C 的函数库时会用到 extern "C"。这是因为 C++ 会对函数名进行名词修饰（name mangling）。简单的来说，就是 C++ 支持函数重载，而 C 语言并不支持。这就导致 C++ 编译器生成的符号和 C 编译器生成的符号有差别，进而导致链接错误。<br>比如我们有下面的函数：<br>int add(int i, int j){}
<br>使用 C++ 编译器编译后生成的符号名是 _Z3addii 而使用 C 编译器所生成的汇编函数名直接就是 add。你看到 C++ 编译器添加了许多字符来修饰函数，这是 C++ 实现静态多态的基石。如果直接链接 C 编译后的代码，链接器会无法识别这些符号。]]></description><link>https://congzhi.wiki/c-plus-plus/extern-keyword-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Extern Keyword in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 13 Mar 2025 16:33:59 GMT</pubDate></item><item><title><![CDATA[Forwarding in C++]]></title><description><![CDATA[ 
 <br>Do these at first:<br>
<br><a data-href="Move Semantics in C++" href="https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Move Semantics in C++</a>
<br><a data-href="Generics Programming in C++" href="https://congzhi.wiki/c-plus-plus/generics-programming-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Generics Programming in C++</a>
<br><br>在 <a data-tooltip-position="top" aria-label="Move Semantics in C++" data-href="Move Semantics in C++" href="https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Move Semantics</a> 中，我们提到，左值引用只能绑定左值，右值引用只能绑定右值。右值的应用让那些绑定右值的函数能够对物体直接进行所有权转移的操作，避免了不必要的拷贝。<br>然而，你会发现有时候当你传递左值给一个右值引用时，仍然行得通。但这应当是非法的。为什么呢？这是因为函数模板参数类型推导过程中会发生引用折叠。<br>#include &lt;cstdio&gt;
template&lt;typename T&gt;
void foo(T &amp;&amp;){
	printf("foo(T&amp;&amp;)");
}
int main(){
	int i = 5;
	foo(i); // i is a lvalue
	foo(5); // pass a rvalue
	return 0;
}
<br>这里会发生 "reference collapsing"。我们传入了一个左值 i，在编译器推导函数 foo() 接收的类型时，会将其推导成 T&amp; &amp;&amp;。而 C++ 有一些 reference collapsing rules 如下所示。进一步地，编译器会将类型推导成一个接受左值的函数 foo(T&amp;)。（引用折叠，自 C++11）<br><br>那传入一个右值会怎么样？传递右值给 foo 函数当然会推导出 T&amp;&amp;，从而保持右值引用的性质。也就是说，传递左值时，会折叠成左值引用；传递右值时，会保持右值引用。<br><br>有时候，我们希望写出一个既能够接受左值，也能接受右值的函数。在这种情况下，C++11 引入了转发引用（forwarding references），也称为通用引用（universal references）。了解了引用折叠是怎么回事后，我们可以利用其特性编写一个中继函数来同时接受左值和右值。再通过中继函数对参数的转发，我们就实现了完美转发。<br>要实现完美转发，需要根据原始参数的值类别（左值/右值），保留其引用性质。这些都是在中继函数中完成的。我们需要用到 std::forward 保留原始的引用类别来传递给下层的函数。<br>template&lt;typename T&gt;
T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; arg) noexcept {
    return static_cast&lt;T&amp;&amp;&gt;(arg);
}
/*
std::move turns a arg into a rvalue
std::forward turns arg into a rvalue ref
*/
<br>如：<br>#include &lt;cstdio&gt;
#include &lt;utility&gt;

template&lt;typename T&gt;
void foo(T&amp; arg) {
    printf("lvalue foo\n");
}

template&lt;typename T&gt;
void foo(T&amp;&amp; arg) {
    printf("rvalue foo\n");
}

template&lt;typename T&gt;
void relay(T&amp;&amp; arg) {
    foo(std::forward&lt;T&gt;(arg)); // correctly forward the argument
}

int main() {
    int i = 5;
    relay(i); // i is a lvalue
    relay(5); // pass a rvalue
    return 0;
}

<br>通过使用模板参数和 std::forward，我们实现了完美转发，从而在编写泛型代码时处理不同类型的引用。<br><br>如果我们有几个重载的引用转发，我们有下面的代码， f(w) 等调用这些重载的顺序是什么？<br>#include &lt;utility&gt;
struct Widget{};
// function with lvalue ref (1)
void f( Widget&amp; ){}

// function with lvalue ref to const (2)
void f( const Widget&amp; ){}

// function with rvalue ref (3)
void f( Widget&amp;&amp; ){}

// function with rvalue ref to const (4)
void f( const Widget&amp;&amp; ){};

// function with forwarding ref (5)
template&lt; typename T &gt;
void f( T&amp;&amp; ){}

// function template with rvalue ref to const (6)
template&lt; typename T &gt;
void f( const T&amp;&amp; ){}

int main(){
	Widget w{};
	f(w); // (1), (5), (2)

	const Widget w2{};
	f(w2); // (2), (5)

	f(std::move(w)); // (3), (5), (4), (6), (2)

	const Widget w3{std::move(w)};
	f(w3); // (4), (6), (5), (2)
	return 0;
}
<br>Avoid overloading on forward references.]]></description><link>https://congzhi.wiki/c-plus-plus/forwarding-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Forwarding in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 06 Mar 2025 09:14:34 GMT</pubDate></item><item><title><![CDATA[Friend Keyword in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>In C++, we use the friend keyword in the class body to declare a function or a class as a friend to the current class. This means that the friend function or class will have access to the private and protected members of the current class. The declaration syntax is as follows:<br>class MyClass {
    int a, b, c; // private members

    // Friend function declaration
    friend void printMember();

    // Friend class declaration
    friend class AnotherClass;
};
<br>#include &lt;iostream&gt;

class MyClass {
private:
    int a, b, c;

public:
    MyClass(int x, int y, int z) : a(x), b(y), c(z) {}

    // Declare AnotherClass as a friend
    friend class AnotherClass;
};

class AnotherClass {
public:
    void showValues(const MyClass&amp; obj) {
        std::cout &lt;&lt; "a: " &lt;&lt; obj.a &lt;&lt; ", b: " &lt;&lt; obj.b &lt;&lt; ", c: " &lt;&lt; obj.c &lt;&lt; std::endl;
    }
};

int main() {
    MyClass obj(1, 2, 3);
    AnotherClass anotherObj;
    anotherObj.showValues(obj); // Friend class can access private members
    return 0;
}
<br><br>Interestingly, the friendship friend brings is not transitive, which means a friend of your friend is not your friend. Additionally, friendship is not inherited.<br>Using the friend keyword makes private data transparent, which can be convenient, but it breaks the encapsulation of a class. In most cases, your code should not include any friend declarations, as this might indicate poor design.<br>One of the most common use cases for the friend keyword in C++ is in non-member operator overloads. By declaring a non-member operator function as a friend, you grant it access to the private and protected members of your class. This is particularly useful for operator overloading, such as the &lt;&lt; operator for output streams.<br>#include &lt;iostream&gt;

class MyClass {
private:
    int a, b, c; // private members

public:
    MyClass(int x, int y, int z) : a(x), b(y), c(z) {}

    // Friend function declaration for operator&lt;&lt;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyClass&amp; obj);
};

// Definition for operator&lt;&lt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyClass&amp; obj) {
    os &lt;&lt; "a: " &lt;&lt; obj.a &lt;&lt; ", b: " &lt;&lt; obj.b &lt;&lt; ", c: " &lt;&lt; obj.c;
    return os;
}

int main() {
    MyClass obj(1, 2, 3);
    std::cout &lt;&lt; obj &lt;&lt; std::endl; // Uses the friend function to access private members
    return 0;
}

]]></description><link>https://congzhi.wiki/c-plus-plus/friend-keyword-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Friend Keyword in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:56:23 GMT</pubDate></item><item><title><![CDATA[Function Pointers in C++ (Examples)]]></title><description><![CDATA[ 
 <br>#include &lt;iostream&gt;

int add(int a, int b){
    return a + b;
}
int multiply(int a, int b){
    return a * b;
}
int main(){
	auto (*fp)(int, int);
    bool sel = 1;
    if(sel == 0){
        fp = add;
        std::cout &lt;&lt; fp(1, 2) &lt;&lt; std::endl;
    }else{
        fp = multiply;
        std::cout &lt;&lt; fp(1, 2) &lt;&lt; std::endl;
    }
    return 0;
}
<br>#include &lt;iostream&gt;

// 定义回调函数类型
typedef void (*Callback)(int);

void process(int value, Callback cb) {
    std::cout &lt;&lt; "Processing value: " &lt;&lt; value &lt;&lt; std::endl;
    cb(value); // 调用回调函数
}

void myCallback(int result) {
    std::cout &lt;&lt; "Callback function called with result: " &lt;&lt; result &lt;&lt; std::endl;
}

int main() {
    // 使用回调函数
    process(42, myCallback);
    return 0;
}

<br>std::function<br>std::function&lt;int(int, int)&gt; op;
]]></description><link>https://congzhi.wiki/c-plus-plus/function-pointers-in-c++-(examples).html</link><guid isPermaLink="false">C Plus Plus/Function Pointers in C++ (Examples).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:56:27 GMT</pubDate></item><item><title><![CDATA[Functions in Standard Library (Examples)]]></title><description><![CDATA[ 
 <br>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

int main(){

	int x = 10;
	std::cout &lt;&lt; "x type: " &lt;&lt; typeid(x).name() &lt;&lt; std::endl;

	return 0;
}
<br>check if a variable is const type<br>#include &lt;iostream&gt;
#include &lt;type_traits&gt;

int main(){

	int x = 10;
	std::cout &lt;&lt; std::is_const_v&lt;decltype(x)&gt; &lt;&lt;std::endl; //C++17
	//or
	std::cout &lt;&lt; std::is_const&lt;decltype(x)&gt;::value &lt;&lt; std::endl;
	return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/functions-in-standard-library-(examples).html</link><guid isPermaLink="false">C Plus Plus/Functions in Standard Library (Examples).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:56:31 GMT</pubDate></item><item><title><![CDATA[Generics Programming in C++]]></title><description><![CDATA[ 
 <br><br><br><br>C 语言不支持函数重载(function overloading)，这就意味着我们必须给不同的函数起不同的函数名，这对于完成相同任务但接收不同参数的函数来说非常麻烦。而 C++ 从一开始就支持函数重载，允许代码实现静态多态性。通过传递不同的参数，编译器会调用相应的函数。<br>函数重载当然是一个伟大的特性，但是如果我们要重载许多函数，我们就需要复制粘贴许多遍。但使用函数重载会给我们带来一些潜在问题。除了复制粘贴许多遍之外，我们还可能碰到一些未定义重载函数的情况，比如下面我们使用 long long sum_ll = sum(5342ll, 5864ll); 我们并没有定义相关的函数重载，编译器就不知道调用哪个函数。<br>函数重载当然是一个伟大的特性，但是如果我们要重载许多函数，我们就需要复制粘贴许多遍。但使用函数重载会带来一些潜在问题。除了需要复制粘贴许多遍之外，我们还可能碰到一些未定义重载函数的情况，比如下面我们使用 long long sum_ll = sum(5342ll, 5864ll); 我们并没有定义相关的函数重载，编译器就不知道调用哪个函数。<br>int add(int a, int b){
	return a + b;
}
float add(float a, float b){
	return a + b;
}
double add(double a, double b){
	return a + b;
}
// ...
int main(){
	int sum_i = add(20, 30); // Call int add(int a, int b)
	float sum_f = add(3.14f, 5.58f); // Call float add(float a, float b)
	double sum_d = sum(3.254, 2.546); // Call double add(double a, double b)
	long long sum_ll = sum(5342ll, 5864ll); // Which to call? It's ambiguous!
	return 0;
}
<br>而在 C++98 后，函数模板（泛型函数）的出现避免了多次代码的复制粘贴。模板相当于一个你编写的蓝图，编译器在编译代码的时候会根据你提供的蓝图帮你生成重载函数。从而，你不需要记忆你到底重载了哪些函数。<br>// Compiler will generate function code at compile-time
// And function template is not a function btw
template&lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
int main() {
    int sum_i = add&lt;int&gt;(20, 30); // Same as add(20, 30) expicitly
    float sum_f = add&lt;float&gt;(3.14f, 5.58f); // Same as add(3.14f, 5.58f)
    double sum_d = add&lt;double&gt;(3.254, 2.546); // Same as add(3.254, 2.546)
    long long sum_ll = add&lt;long long&gt;(5342, 5864); // Same as add(5232ll, 5864ll)
    return 0;
}
<br>上面的例子中，编译器帮我们实例化生成了四个重载函数。在 C++17 后，你实际上可以不再显式地提供模板重载类型，编译器会帮你推导相关的类型。<br><br>每个模板类型都至少被类型推断一次<br>multiple template parameters and non object type params<br>with auto<br>Variadic arguments and Variadic Function Templates<br><br><br><br><br><br>reference collapsing<br><br><br>同样，类模板也不是一个类。它是让编译器帮我们创建类的模板蓝图。<br>STL - you use all the time<br>class myContainer {
public:
	myContainer(int N) {
		m_data = new int[N];
	}
	~myContainer() {
		delete[] m_data;
	}
private:
	int* m_data;
};

class myContainer {
public:
	myContainer(int N) {
		m_data = new float[N];
	}
	~myContainer() {
		delete[] m_data;
	}
private:
	float* m_data;
};
<br>template&lt;typename T&gt;
class myContainer {
public:
	myContainer(int N) {
		m_data = new T[N];
	}
	~myContainer() {
		delete[] m_data;
	}
private:
	T* m_data;
};
<br>还可以提供一个 non-type object<br>#include &lt;cstddef&gt; // For size_t

template&lt;typename T, size_t N&gt;
class myContainer {
public:
    myContainer() {
        m_data = new T[N];
    }
    ~myContainer() {
        delete[] m_data;
    }
private:
    T* m_data;
};

int main() {
    myContainer&lt;int, 5&gt; container;
    return 0;
}
<br><br><br><br>typeid().name()<br><br><br>#include &lt;vector&gt;

// Without alias templates:
typedef std::vector&lt;int&gt; myvec_int; // C++03 alias syntax
typedef std::vector&lt;float&gt; myvec_float; // C++03 alias syntax

// With alias templates:
template&lt;typename T&gt;
using myvec = std::vector&lt;T&gt;; // C++11 syntax

int main(){
    myvec_int vi = {1, 2, 3, 4, 5}; // Using the old alias syntax
    myvec_float vf = {1.1f, 2.2f, 3.3f}; // Using the old alias syntax

    myvec&lt;int&gt; vi_alias = {6, 7, 8, 9, 10}; // Using the new alias template syntax
    myvec&lt;float&gt; vf_alias = {4.4f, 5.5f, 6.6f}; // Using the alias template syntax
    return 0;
}
<br>Alias template cannot be specialized.<br><br><br><br>模板的参数并不必须为一种”类型“：<br>template&lt;class T, size_t N&gt;
class Array{
	T    m_data[N];
	// ...
};

Array&lt;foobar, 10&gt; some_foobars;
<br>NTTPs中的常数类型必须在编译阶段或链接时确定好，而且类型必须为：<br>
<br>整型或枚举（最常见）
<br>指针
<br>std::nullptr_t
<br>其他
<br>Unwatched: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=VIz6xBvwYd8&amp;t=11s" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=VIz6xBvwYd8&amp;t=11s" target="_blank">CppCon 2016: Arthur O'Dwyer “Template Normal Programming (part 2 of 2)"</a>]]></description><link>https://congzhi.wiki/c-plus-plus/generics-programming-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Generics Programming in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 04 Mar 2025 16:17:40 GMT</pubDate></item><item><title><![CDATA[Inheritance in C++]]></title><description><![CDATA[ 
 <br><br>继承是面向对象技术得以发扬光大的原因之一。本节课，我们来学习 C++ 中最基础的继承知识，简单了解一下继承是什么。我们一般将被继承的类称为基类（也称为父类、祖先类），将继承其他类的类称为派生类（也称为子类、扩展类）。下面用一个例子展示这种关系：<br>class Base{ // parent class or ancestor class
// Some implementation
};
class Derived : public Base{
// Some implementation
};
<br>一个类可以被继承和派生，正如上面基类 Base 和派生类 Derived 的关系。这里的继承可以理解为派生类接收到来自基类的传承，脉脉相承就是继承最主要的思想。类与类之间有两种关系："is-a" 和 "has-a"，请不要混淆，我们下面就来解释这两种关系。<br><br>我们所说的继承是 "is-a" 的关系，也就是“是一种”的关系。而 "has-a" 表示的是“有一个”的关系，即“composition”。我们用下面的示例来直观地感受这两种关系：<br>class Widget {};
class Base {};
class Derived : public Base { // class Derived is-a Base
    // Class data member
    Widget w; // class Derived has-a Widget
};
<br>在这个例子中，我们说派生类 Derived 继承了基类 Base，所以 Derived 是一种 Base。而派生类内有个 Widget 成员，所以我们说派生类 Derived 中有一个 Widget，也就是 "has-a" 的关系。<br>And by the way, we also have another 'has-a' relationship called aggregation, which has a weaker relationship than compositional 'has-a'. For example, you may say a car has an engine, this is compositional 'has-a'. And also, a school could have many students, this is aggregational 'has-a'.<br><br>通过继承，你能得到什么呢？我们说派生类 is-a 基类。那么，我们是否可以将派生类中的一些共性提炼出来放在基类中？实际上，我们的确就是这么做的。通过继承，派生类重用基类的代码，减少了代码的重复，提高了代码的可维护性。在功能扩展时，只需要让派生类在基类的基础上增加新的功能。<br>此外，继承使得基类提供不同的接口，使得派生类可以通过相同的接口做出不同的实现，这被称为多态（或动态多态）。这与我们在 <a data-tooltip-position="top" aria-label="Static Dispatch in C++ (ENG)" data-href="Static Dispatch in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/static-dispatch-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">静态多态</a> 中介绍的“假”多态不同。多态的出现可以使代码在运行时通过不同的接口调用不同的派生类方法。我们将在 <a data-href="Virtual Dispatch in C++" href="https://congzhi.wiki/c-plus-plus/virtual-dispatch-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Virtual Dispatch in C++</a> 介绍这种动态多态。 <br><br>在 C++ 中，我们有三种不同的继承访问控制方式： public、protected 和 private。不同的继承访问方式决定了派生类中对基类成员的不同访问权限。我们用一个例子来展示这三种不同的继承访问控制方式的作用：<br>class Base {
public:
    int pub_i; // Public members are accessible from outside
protected:
    int prot_i; // Protected members are accessible to derived classes
private: 
    int pri_i; // Private members are only accessible within Base class
};

class Pub_Derived : public Base {
public:
    void accessBase() {
        pub_i = 1; // Accessible
        prot_i = 2; // Accessible
        // pri_i = 3; // Not accessible
    }
};

class Prot_Derived : protected Base {
public:
    void accessBase() {
        pub_i = 1; // Accessible
        prot_i = 2; // Accessible
        // pri_i = 3; // Not accessible
    }
};

class Pri_Derived : private Base {
public:
    void accessBase() {
        pub_i = 1; // Accessible
        prot_i = 2; // Accessible
        // pri_i = 3; // Not accessible
    }
};

int main() {
    Pub_Derived pubDerived;
    pubDerived.pub_i = 1; // Accessible from outside
    // pubDerived.prot_i = 2; // Not accessible from outside
    // pubDerived.pri_i = 3; // Not accessible from outside
    
    Prot_Derived protDerived;
    // protDerived.pub_i = 1; // Not accessible from outside
    // protDerived.prot_i = 2; // Not accessible from outside
    // protDerived.pri_i = 3; // Not accessible from outside

    Pri_Derived priDerived;
    // priDerived.pub_i = 1; // Not accessible from outside
    // priDerived.prot_i = 2; // Not accessible from outside
    // priDerived.pri_i = 3; // Not accessible from outside
    return 0;
}
<br>从例子中，你可以看到这三种不同的继承访问控制方式的作用。我们发现，无论是哪种继承关系，派生类都不能访问基类中的 private 成员。对于 public 继承，基类中的 public 和 protected 成员在派生类中的访问权限不变。对于 protected 继承，基类中的 public 成员在派生类中的访问权限会变为 protected。对于 private 继承，基类中所有类型的成员在派生类中都会变为 private 成员。<br><img alt="Pasted image 20250225102217.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250225102217.png"><br><br>
<br>构造顺序：基类 → 派生类成员变量（按声明顺序）→ 派生类构造函数体。
<br>析构顺序：派生类析构函数体 → 派生类成员变量（逆声明顺序）→ 基类析构函数
<br>class Base {
public:
    Base() { std::cout &lt;&lt; "Base constructed\n"; }
    ~Base() { std::cout &lt;&lt; "Base destroyed\n"; }
};

class Derived : public Base {
public:
    Derived() { std::cout &lt;&lt; "Derived constructed\n"; }
    ~Derived() { std::cout &lt;&lt; "Derived destroyed\n"; }
};

int main() {
    Derived d;
}
<br><br>当有多个不同的基类构造函数时，派生类需要在构造函数初始化列表中显式指定要调用的基类构造函数，不然编译器尝试调用基类默认构造函数。<br>class Base {
public:
    Base() { std::cout &lt;&lt; "Base()\n"; }
    Base(int x) { std::cout &lt;&lt; "Base(" &lt;&lt; x &lt;&lt; ")\n"; }
};

class Derived : public Base {
public:
    Derived() { std::cout &lt;&lt; "Derived()\n"; }
    Derived(int x) : Base(x) { std::cout &lt;&lt; "Derived(int)\n"; }

    Derived(int x, double y) : Base(x), y_(y) { 
        std::cout &lt;&lt; "Derived(int, double)\n"; 
    }
private:
    double y_;
};

int main() {
    Derived d1;        // Base() → Derived()
    Derived d2(10);    // Base(10) → Derived(int)
    Derived d3(5, 3.14);// Base(5) → Derived(int, double)
}
<br><br>如果我们在派生类中定义了与基类同名的函数（non-virtual），无论该函数的参数列表是否相同，基类中的函数都会被隐藏，而不是简简单单的覆盖（override）。这种隐藏现象是名称级别的，即基类的同名函数被“隐藏”。因而，你不能直接通过派生类对象调用基类的同名函数。<br>#include &lt;iostream&gt;
class Base {
public:
    void func() {
        std::cout &lt;&lt; "Base::func()" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void func(int x) {
        std::cout &lt;&lt; "Derived::func(int)" &lt;&lt; std::endl;
    }
};

int main() {
    Derived d;
    d.func(42);  // call Derived::func(int)
    // d.func(); // error, because Base::func() was hiden
    d.Base::func(); // call Base::func()
    return 0;
}
<br>上面的例子中，如果你想重写基类中的同名函数，你就需要用到虚函数，我们会在<a data-tooltip-position="top" aria-label="Virtual Dispatch in C++" data-href="Virtual Dispatch in C++" href="https://congzhi.wiki/c-plus-plus/virtual-dispatch-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">虚多态</a>介绍这种机制，这是 C++ 中多态实现的方式。]]></description><link>https://congzhi.wiki/c-plus-plus/inheritance-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Inheritance in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sat, 22 Mar 2025 09:22:13 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250225102217.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250225102217.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Inline in C++ (ENG)]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Call Stack in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/call-stack-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Call Stack in C++ (ENG)</a><br><br>When a function is called, typically, a stack frame is established. To build the frame, the machine needs to do a lot of work, including saving register values, copying parameters, saving the return address, and keeping track of rbp and rsp. After that, the function does its work.<br>The inline specifier simply tells the compiler to not build this frame, effectively "unboxing" the function code and adding it directly into the caller's frame. This can provide several benefits, such as reducing function call overhead (thus improving performance) and slightly improving readability.<br>Although the inline specifier declares the function to be inlined, it serves merely just as a suggestion to the compiler. If the compiler finds no need to be inlined, it may not take the suggestion. As a result, in most cases, the inline specifier might not be applied at all.<br>With GCC optimizations, the compiler can often eliminate the stack frame even without the use of the inline specifier, which is funny.<br><br>The inline specifier is particularly useful when dealing with external linkage, whether for inline functions or inline variables (since C++17). The use of inline helps prevent linker errors caused by naming conflicts, which would otherwise violate the One Definition Rule (ODR). This is because inline functions and variables can be defined in multiple translation units without causing conflicts during linking.<br>To comply with the ODR, the inline specifier comes into play. In the example below, the compiler ensures that the rule is followed by inlining the test function in the test.cpp file during the compilation stage, replacing function calls with the actual function code in the assembly output.<br>// test.cpp
#include &lt;cstdio&gt;
inline void test() { // This function will not exist in its original form after compilation.
// The compiler will replace calls to this inline function with the actual code during compilation.
    printf("This is an inlined hello in %s\n", __FILE__);
}

void printsomething() {
    test(); // Calls the inline version of the test function defined in this file.
}

// main.cpp
#include &lt;cstdio&gt;
extern void printsomething(); // Declares the external function implemented in test.cpp.
void test() { // This is a regular (non-inline) function definition.
    printf("This is a hello in %s\n", __FILE__);
}

int main() {
    test(); // Calls the test function defined in main.cpp.
    printsomething(); // Calls the printsomething function from test.cpp, which, in turn, calls the inline test function from test.cpp.
    return 0;
}
<br>After compilation, these inline functions and variables are directly inserted into the assembly code at their call sites. Consequently, they do not have separate names in the generated object files, thereby avoiding potential conflicts. However, the inline functions or variables must still be declared in every translation unit where they are used.<br>Note: A function declared constexpr or consteval in its first declaration is implicitly inline. Similarly, a static data member declared constexpr in its first declaration is implicitly an inline variable.<br><br>Inline variables are a feature introduced in C++17, which allows variables to be declared with the inline specifier. Inline variables allow variables to be dealt with external linkage like inline functions.<br>Besides, inline variables are also very useful when dealing with header-only libraries. Some design specifics dictate that the interface (.h/.hpp) should be separate from the implementation (.c/.cpp). Inside a class, when we declare a static variable or function, we are traditionally told not to put the definition (initialization) inside the class, as it is forbidden. However, you can do so if you are using the inline specifier.<br>Old way:<br>// .hpp file
class myLib{
	static int counter; // Declareation
	// Other data member
public:
    // Other member functions and definitions
};
<br>// .cpp file
int myLib::counter = 0;
// some other definition and implementation
<br>Header-only library way:<br>// header_only_library.hpp
// This hpp file contains all the declarations and definitions
// An example to "class as a library"

class myLib {
    // static int counter = 0; // Not allowed, definition must be outside the class
    // const static int counter = 0; // Okay, but requires constexpr for inline
    // const static int counter; // Not allowed, must be initialized (defined)
    inline static int counter = 0; // Okay, inline allows definition inside the class
    // inline static int counter; // Also okay, will be default initialized to 0
    // constexpr static int counter = 0; // Okay, constexpr implies inline
    // inline constexpr static int counter = 0; // Same as above

    // Other data members

public:
    // Other member functions and definitions
};
]]></description><link>https://congzhi.wiki/c-plus-plus/inline-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Inline in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 18 Mar 2025 06:40:19 GMT</pubDate></item><item><title><![CDATA[Integer Literal & Float Literal in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Auto in C++" href="https://congzhi.wiki/c-plus-plus/auto-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Auto in C++</a><br><br>在使用 auto 关键字时，我们发现 auto 往往会将整数字面量推导成 int 类型。如下，我们给 a 赋值 0 远远小于 int 能够表示的最大值。既然 short 类型也能表示 0 ，甚至 char 类型也可以。那为什么 auto 不将这个表达式中的 a 推导成 short 类型，甚至 char 类型？<br>auto a = 0; // a is deduced as int type, why not short or char?
<br>这是因为在 C++ 中，整数字面量（例如 0）的默认类型是 int。编译器会优先选择最适合的类型来表示这个字面量，因此在这种情况下，auto 会推导出 int 类型，而不是其他的类型。<br><br>在 C++ 中，整数字面量可以是十进制的、八进制的、十六进制的和二进制的（C++14）。通过加入不同的前缀，我们就可以改变整数的基数。如下：<br>int decimal = 16;
int octal = 020; // 16 on decimal
int hexdecimal = 0x10; // or 0X10
int binary = 0b10000;
<br><br>当整数字面量不带任何后缀时，一般默认的类型就是 int 类型。C++ 整型字面量一共有这几种不同的后缀（基数为10）：<br>
<br>u 或 U：表示 unsigned int （默认）
<br>l 或 L：表示 long int （默认）
<br>ul / UL 等 ：表示 unsigned long int （默认）
<br>ll 或 LL：long long int
<br>ull 或 ULL 等：表示 unsigned long long int
<br>z 或 Z：表示 std::size 类型（C++23）
<br>uz 或 UZ：同上。
<br>auto a = 0; // a is deduced as type int
auto b = 0u; // b is deduced as type unsigned int
auto c = 0l; // c is deduced as type long
auto d = 0ul; // d is deduced as type unsigned long
auto e = 0ll; // e is deduced as type long long
auto f = 0ull; // f is deduced as type unsigned long long
<br>当字面量很长时，你可以用单引号作为分隔符在任意位置将字面量分隔开。在确定字面量时会忽略这些单引号。<br><br>同样的，浮点字面量也可以通过后缀来决定字面量的类型。当没有后缀时，默认定义为 double 类型。对于浮点数字面量，C++ 有以下的后缀：<br>
<br>f 或 F：表示 float
<br>l 或 L：表示 long double
<br>自 C++23 起，C++ 还引入了 f16、f32、f64、f128、bf16、F16、F32、F64、F128、BF16 的后缀。
<br>auto a = 0.0; // a is deduced as type double
auto b = 0.0f; // b is deduced as type float
auto c = 0.0l; // c is deduced as type long double
<br>下一节：<a data-href="Character Literal &amp; String Literal in C++" href="https://congzhi.wiki/c-plus-plus/character-literal-&amp;-string-literal-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Character Literal &amp; String Literal in C++</a>]]></description><link>https://congzhi.wiki/c-plus-plus/integer-literal-&amp;-float-literal-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Integer Literal &amp; Float Literal in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 21 Feb 2025 18:13:37 GMT</pubDate></item><item><title><![CDATA[Lambdas in C++]]></title><description><![CDATA[ 
 <br><br>我们将函数视为对黑匣子内部操作的抽象封装。函数隐藏了内部细节，只向外界暴露其提供的接口。而在内存中，这个黑匣子需要占用存储空间（.text&nbsp;段）。因此，函数是有地址的。函数地址就是指向内存中‘黑匣子’所存放的起始地址，而函数指针则是指向函数地址的指针。<br>因为函数可以取地址，所以我们可以将函数指针作为参数去传递。我们下面举例：<br>#include &lt;iostream&gt;
void hello(){
	std::cout &lt;&lt; "Hello" &lt;&lt; std::endl;
}
void test(void(*ptr)()){
    ptr();
}
int main(){
	auto funcPtr = hello; // same as `void(*funcPtr)() = hello;`
	test(funcPtr); // passing function pointer as a parameter
    funcPtr(); // call hello() using function pointer
}
<br>例二：<br>#include &lt;iostream&gt;
#include &lt;vector&gt;

void PrintValue(int value){
	std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
}
void ForEach(const std::vector&lt;int&gt;&amp; values, void(*print)(int)){
	for(int value : values)
		print(value);
}

int main(){
	std::vector&lt;int&gt; values = {1, 2, 3, 5, 9};
	ForEach(values, PrintValue);
	return 0;
}
<br>例二使用模板和lambda表达式后，我们能够优雅地遍历打印基本类型的vector。从这里我们就能够感受到lambda表达式的便利性，因为你不需要单独定义一个函数了，简化了代码。<br>#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
void ForEach(const std::vector&lt;T&gt;&amp; values, void(*funcPtr)(T))
{
    for (const T&amp; value : values)
        print(value);
}
int main()
{
    std::vector&lt;int&gt; values = {1, 2, 3, 5, 9};
    ForEach(values, [](int value){std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;});
    return 0;
}
<br><br><br>仿函数，也叫函数对象(function object)，是可以像函数一样被调用的对象，常常用重载运算符 operator() 实现。我们用一个例子来说明为什么被称为仿函数：<br>#include &lt;iostream&gt;
struct Increment
{
    int number;
    Increment(int n) : number(n) {}
    int operator()(int x) {
        number += x;
        return number;
    }
};

int main() {
    Increment inc(5);
    std::cout &lt;&lt; inc(15) &lt;&lt; std::endl; // call functor just like functions
    return 0;
}
<br>由于重载了 operator()，仿函数的调用能够像调用函数一样方便自然。而且通过类内的变量 number 能够保留每次被调用后的状态信息，这时函数所不能够做到的。仿函数结合了类的状态管理和函数的调用方式，提供了比普通函数更高的灵活性和功能。<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class Print {
public:
    void operator()(int x) const {
        std::cout &lt;&lt; "Value: " &lt;&lt; x &lt;&lt; std::endl;
    }
};
int main() {
    std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};
    std::for_each(values.begin(), values.end(), Print());
    return 0;
}
<br><br>如果刚刚接触Lambdas，你一定会困惑于如此多的括号。在Lambda中，我们有()、[]、{}。如果带有参数模板你甚至还会看到&lt;&gt;。我们先看看这些Lambda表达式。<br><br><br>
Lambda constructs a closure : an unnamed function object capable of capturing variables in scope.
<br>Lambda表达式构造了一个闭包，在3.2节中我们将会学到（其中[]叫做捕获列表）。通过Lambda表达式，我们实际上能够定义一个具有捕获作用域内变量能力的匿名函数对象。什么意思呢？即在仿函数（函数对象）的基础上，还加入了捕获当前栈帧中局部变量的能力。<br>虽然匿名函数对象虽然是匿名的，但我们仍然可以让一个函数指针指向我们的 Lambda 表达式，从而达到 Store the Lambda 的目的。在下面的例子中，Lambda 表达式被转换为函数指针&nbsp;Print，并且我们可以通过这个指针调用 Lambda 表达式，实现存储和调用。<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main() {
	int i = 5;
	double j = 6;
	char c = 's';
    //auto Print = [=](int v){
    //    std::cout &lt;&lt; "value:" &lt;&lt; v &lt;&lt; std::endl;
    //};
    std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};
    std::for_each(values.begin(), values.end(), 
					[=](int v){
					    std::cout &lt;&lt; "value:" &lt;&lt; v &lt;&lt; std::endl;
					}); 
    // std::for_each(values.begin(), values.end(), Print); 
    return 0;
}
<br>如果我们想看看 Lambda 背后的仿函数真身是什么，接着上面的例子，我们会看到编译器实际上生成了一个仿函数，捕获的成员变量会作为仿函数类中的私有成员变量存储。编译器生成的代码大概是这样的：<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{
  int i = 5;
  double j = 6;
  char c = 's';
  std::vector&lt;int, std::allocator&lt;int&gt; &gt; values = std::vector&lt;int, std::allocator&lt;int&gt; &gt;{std::initializer_list&lt;int&gt;{1, 2, 3, 4, 5}, std::allocator&lt;int&gt;()};
    
  class __lambda_14_6
  {
    public: 
    __lambda_14_6(int i, double j, char c) : i(i), j(j), c(c) {}
    
    inline /*constexpr */ void operator()(int v) const
    {
      std::operator&lt;&lt;(std::cout, "value:").operator&lt;&lt;(v).operator&lt;&lt;(std::endl);
    }
    
    private:
    int i;
    double j;
    char c;
  };
  
  std::for_each(values.begin(), values.end(), __lambda_14_6(i, j, c));
  return 0;
}
<br><br>所以，Lambda 表达式是如何实现的？我们现在能明白的是编译器会将 Lambda 表达式转换成一个匿名类，而且 Lambda 是由仿函数实现的，捕获的变量会作为仿函数类中的成员变量。那从 Lambda 表达式到仿函数这一过程中会发生什么？<br>首先会进行语法解析和捕获，[] 叫做 CAPCHA method，它会按照既定方式捕获作用域内的局部变量（按值或按引用）虽然我们[=]自动按值捕获所有的局部变量，但由于一个都没有用，所有匿名类中也是不会对这些局部变量进行构造的。之后会生成匿名类，类中包括我们所捕获的变量并完成对运算符operator()的重载。<br>Lambda 中 CAPCHA method 中捕获的变量就会在生成匿名类时对这些变量进行构造，当然，这些变量会被作为类内的 private 变量存在。下面，我们来看看 Lambda 的捕获规则。<br><br>我们用捕获std::string对象作为例子来展示不同类型的捕获类型。我们下面会介绍按值捕获、按引用捕获和按右值捕获。<br><br>首先，我们来看看当捕获列表中按值捕获一个对象时会发生什么。最开始，我们用&nbsp;std::string str = "Hello!";&nbsp;定义了一个&nbsp;std::string&nbsp;类型的对象。这时，str&nbsp;指针在栈上，而字符串内容&nbsp;"Hello!"&nbsp;实际上存储在堆上。<br>然后，auto&nbsp;capFunc&nbsp;=&nbsp;[newStr&nbsp;=&nbsp;str]()&nbsp;mutable&nbsp;{}&nbsp;这行代码将&nbsp;lambda&nbsp;表达式的地址赋给了&nbsp;capFunc。在&nbsp;lambda&nbsp;表达式中，[newStr&nbsp;=&nbsp;str]&nbsp;相当于auto newStr = str;。在构造匿名类时，会在匿名类的&nbsp;private&nbsp;域中增加一个&nbsp;std::string&nbsp;newStr;&nbsp;成员，并生成相应的复制构造函数。<br>由于 std::string 类中对拷贝赋值运算符进行了重写，拷贝时进行深拷贝。所以按值捕获后，我们在栈上有两个不同的指针指向两个堆上字符串。我们对拷贝的字符串进行修改，打印出来。<br>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string str = "Hello!";
    auto capFunc = [newStr = str]() mutable
    {
        std::cout &lt;&lt; "In lambda: " &lt;&lt; newStr &lt;&lt; std::endl;
        if (!(newStr).empty())
        {
            newStr = "Changed!";
            std::cout &lt;&lt; "In lambda: " &lt;&lt; newStr &lt;&lt; std::endl;
        }
    };
    capFunc();
    std::cout &lt;&lt; str &lt;&lt; std::endl;
	return 0;
}
<br>按值拷贝的对象改变并不会影响原来的被拷贝对象。<br>$ ./lambda
In lambda: Hello!
In lambda: Changed!
Hello!
<br>使用&nbsp;mutable&nbsp;关键字的原因是，在生成匿名类时，它会去掉重载运算符后的&nbsp;const&nbsp;限定符，这样我们就可以在&nbsp;lambda&nbsp;中修改按值捕获的变量。如下所示，常方法不允许对类内对象进行修改，所以加入&nbsp;mutable&nbsp;关键字，使得修改按值捕获的副本成为可能。<br>inline /*constexpr */ void operator()() const {} // const by default
<br><br>当我们像下面这样按指针或是用引用捕获时，我们其实不太需要考虑 mutable 了。反而，我们这时应当开始关注指针悬挂或引用悬挂的问题。（按指针捕获可以看作是按值捕获）<br>int i = 5;
std::string str0 = "Hello ";
std::string str1 = "World!";
	// captured by pointer
    auto capFunc = [_i = &amp;i, _str0 = &amp;str0, _str1 = &amp;str1]() 
    {
    // any dereference operations will change original object
    }

    // captured by reference
    auto capFunc = [&amp;_i = i, &amp;_str0 = str0, &amp;_str1 = str1]() 
    {
    // any operations will change original object
    }
<br>由于我们用指针解引用和引用修改源对象的方式实际上修改的是指针指向的值或引用原对象的值，并不会修改匿名类内的对象，所以我们并不需要去添加mutable关键字。然而，我们需要注意，假如lambda返回了相关的指针或是引用，而原对象在使用返回值之前释放掉了，就会引发指针悬挂或引用悬挂的问题。<br><br>除了常见的按值捕获、按引用捕获和按指针捕获，我们还可以在此引入移动语义从而实现按右值捕获。通过 std::move 将 str 转移到 _str ，使得 _str 拥有原 str 的资源（即所有权转移了）。对象的所有权一旦转移，str 就不再可用，想要之后继续用到同一个 string 对象，我们可用返回该对象的引用，甚至返回其右值，转移所有权。<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt; // std::move

int main() {
    std::string str = "Hello World!";
    auto capFunc = [_str = std::move(str)]() mutable -&gt; std::string&amp; {
        std::cout &lt;&lt; "In lambda: " &lt;&lt; _str &lt;&lt; std::endl;
        if (!_str.empty()) {
            _str = "Changed!";
            std::cout &lt;&lt; "In lambda: " &lt;&lt; _str &lt;&lt; std::endl;
        }
        return _str;
    };
    std::string&amp; refStr = capFunc();
    // str is moved, thus it's now unusable
    std::cout &lt;&lt; "Original string after move: " &lt;&lt; str &lt;&lt; std::endl;
    // 
    std::cout &lt;&lt; "Original string after move: " &lt;&lt; refStr &lt;&lt; std::endl;
    return 0;
}
<br>同样，我们能这么做是因为 std::string 中对<a data-href="The Rule of Five in C++" href="https://congzhi.wiki/c-plus-plus/the-rule-of-five-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">The Rule of Five in C++</a>有完整的实现。<br><br>当我们在类成员函数中使用 lambda 表达式时，我们可能想要在 lambda 中输出类成员变量的值。如下面代码中所示：<br>#include &lt;iostream&gt;

class myClass {
private:
    int counter{0};
public:
    void printCounter() {
        auto lambda = []() {
            std::cout &lt;&lt; "counter: " &lt;&lt; counter &lt;&lt; std::endl;
        };
        lambda();
    }
};

int main() {
    myClass obj;
    obj.printCounter();
    return 0;
}

<br>因为我们的捕获列表中并没有捕获任何东西，所以编译器会报错。我们学过 this 关键字，知道每个实例化的类都会有一个 this 指针指向实例的数据成员（相当于指向 C-style struct）。由于 this 指针是隐性提供的，所以对 this 的捕获是特殊的。<br>class myClass {
private:
    int counter{0};
public:
    void printCounter() {
        auto lambda = [this](){}; // capture `this` by reference
        auto lambda = [*this](){}; // capture `this` by value(since c++17)
    }
};
<br>我们可以按值捕获或者按引用捕获 this 指针。]]></description><link>https://congzhi.wiki/c-plus-plus/lambdas-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Lambdas in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 04 Mar 2025 08:40:02 GMT</pubDate></item><item><title><![CDATA[Malloc in C (ENG)]]></title><description><![CDATA[ 
 <br><br>In simple terms, malloc() is an abstraction built on system calls like mmap() and brk(). This means you don’t need to worry about the underlying system details. This is what high-level languages have provided such conveniences for us since the 1970s.<br>If you are familiar with how systems allocate memory, you would know that a page (typically 4KB) is the smallest unit that an operating system can process for memory allocation. However, in C, C++, or other high-level languages, you actually can allocate as little as a single byte(in reality, this might round up to 32 bytes). Then there's must be something happened under the hood.<br>For those who aren’t familiar with these system calls or OS memory management, you are encouraged to learn more about mmap() and brk() from <a data-tooltip-position="top" aria-label="6.5 Inter-Process Communications > 4.2.1 `mmap()`" data-href="6.5 Inter-Process Communications#4.2.1 `mmap()`" href="https://congzhi.wiki/congzhi's-os-series/6.5-inter-process-communications.html#4.2.1_`mmap()`" class="internal-link" target="_self" rel="noopener nofollow">here</a> and <a data-tooltip-position="top" aria-label="11. Memory Management > 10.x.2 Dynamic Memory Allocation" data-href="11. Memory Management#10.x.2 Dynamic Memory Allocation" href="https://congzhi.wiki/congzhi's-os-series/11.-memory-management.html#10.x.2_Dynamic_Memory_Allocation" class="internal-link" target="_self" rel="noopener nofollow">here</a>. If you’re entirely new to memory management, feel free to explore my OS series, [Chapter 11](<a data-href="11. Memory Management" href="https://congzhi.wiki/congzhi's-os-series/11.-memory-management.html" class="internal-link" target="_self" rel="noopener nofollow">11. Memory Management</a>).<br><br>At first, let's look at how malloc is originally declared in &lt;stdlib.h&gt;:<br>#include &lt;stdlib.h&gt;
void* malloc(size_t size);
/*
Parameters:
    1. size: The number of bytes to allocate. This specifies the size of the process memory block to be allocated.
   
Return value: 
    - On success: Returns a pointer to the beginning of the allocated memory block. The memory is uninitialized.
    - On failure: Returns NULL, and errno is set to indicate the error.
*/
<br>malloc accepts only one parameter, which specifies the number of bytes to allocate. If the memory chunk allocation succeeds, the function returns a pointer to the beginning of the allocated memory chunk. If the allocation fails, it returns NULL, and then errno is set.<br>Pretty easy, right? But this is only scratching the surface—we want to dig deeper and uncover the inner workings of malloc. In this section, we’ll use the following example to see what’s happening beneath the surface:<br>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct linked_chunk{
	int chunk_value;
	struct linked_chunk* next_chunk;
};

int main(){
	struct linked_chunk *chunk1;
    printf("Size of struct linked_chunk is %ld bytes.\n", sizeof(struct linked_chunk));
	chunk1 = malloc(sizeof(struct linked_chunk));
	chunk1 -&gt; chunk_value = 100;
	printf("The address of first chunk is: %p\n", chunk1);
	block1 -&gt; next_block = malloc(sizeof(struct linked_block));
	printf("The address of second chunk is: %p\n", chunk1 -&gt; next_chunk);
	chunk1 -&gt; next_chunk -&gt; chunk_value = 200;
	chunk1 -&gt; next_chunk -&gt; next_chunk = NULL;
    free(chunk1 -&gt; next_chunk);
    free(chunk1);
	return 0;
}
<br>Using this example, we have just allocated memory chunk with malloc. Let's analyze this with the image under below:<br>
<img alt="linked_block.png" src="https://congzhi.wiki/c-plus-plus/pics/linked_block.png"><br>
Outputs:<br>du@DVM:~/cpp$ setarch $(uname -m) -R ./proc
Size of struct linked_chunk is 16 bytes.
The address of first chunk is: 0x5555555596b0
The address of second chunk is: 0x5555555596d0
<br>Notice anything unusual? Our structure is a 16-byte struct, yet there is a 0x10-byte gap (16 bytes) between allocations. Why is that? Because there’s metadata behind the scenes. As said, the OS only allows processes to allocate memory in multiples of the system's page size. However, with malloc metadata, your compiler does a remarkable fine-grained job for you. For example, it allocates a 32-byte memory chunk, and we are going to explore how that happens.<br>Use your GNU debugger, and you will uncover what’s happening in that gap at 0x5555555596c0, which is a total of 16 bytes (system-specific). Within this space, we encounter 0x21, and it is reasonable to deduce that this is where our metadata resides. So, what does 0x21 signify?<br>(gdb) print chunk1
$1 = (struct linked_block *) 0x5555555596b0
(gdb) x/20x 0x5555555596b0
0x5555555596b0: 0x00000064      0x00000000      0x555596d0      0x00005555
0x5555555596c0: 0x00000000      0x00000000      0x00000021      0x00000000
0x5555555596d0: 0x000000c8      0x00000000      0x00000000      0x00000000
0x5555555596e0: 0x00000000      0x00000000      0x00020921      0x00000000
0x5555555596f0: 0x00000000      0x00000000      0x00000000      0x00000000
<br>To be straightforward, the metadata includes how many bytes are allocated and whether that memory chunk is occupied. For example, 0x20 in 0x21 denote the allocated memory size, while 0x1 indicates that this allocated memory is occupied. To free the chunk, simply set the occupied bit to 0x0, and it's all done. Quite straightforward no? (That explained why you only allocate 1 byte but actually allocated 32 bytes of memory)<br>Understanding that, let's now delve into how malloc manages heap memory. Using gdb, we can observe that our heap spans from 0x555555559000 to 0x55555557a000, totaling 0x21000 bytes in size.<br>Mapped address spaces:

Start Addr           End Addr       Size     Offset  Perms  objfile
0x555555559000     0x55555557a000  0x21000    0x0     rw-p   [heap]
<br>0x555555559000: 0x00000000      0x00000000      0x00000291      0x00000000
0x555555559290: 0x00000000      0x00000000      0x00000411      0x00000000
0x5555555596a0: 0x00000000      0x00000000      0x00000021      0x00000000
0x5555555596c0: 0x00000000      0x00000000      0x00000021      0x00000000
0x5555555596e0: 0x00000000      0x00000000      0x00020921      0x00000000
<br>Bit by bit, we can observe how malloc manages heap memory. In total, we have 0x21000 bytes of heap memory (0x290 + 0x410 + 0x20 + 0x20 + 0x20920 = 0x21000). Visually, it looks like this:<br>
<img alt="malloc_map.png" src="https://congzhi.wiki/c-plus-plus/pics/malloc_map.png"><br>
Also in memory mapping segment, you can find this metadata behind the dynamic allocated memory.]]></description><link>https://congzhi.wiki/c-plus-plus/malloc-in-c-(eng).html</link><guid isPermaLink="false">C Plus Plus/Malloc in C (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 21 Mar 2025 08:34:54 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/linked_block.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/linked_block.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Member Initializer List in C++ (ENG)]]></title><description><![CDATA[ 
 <br>
<br><a data-tooltip-position="top" aria-label="Member Initializer List" data-href="#Member Initializer List" href="https://congzhi.wiki/about:blank#Member_Initializer_List" class="internal-link" target="_self" rel="noopener nofollow">Member Initializer List</a>
<br><a data-tooltip-position="top" aria-label="Curly Brace vs. Parenthesis" data-href="#Curly Brace vs. Parenthesis" href="https://congzhi.wiki/about:blank#Curly_Brace_vs._Parenthesis" class="internal-link" target="_self" rel="noopener nofollow">Curly Brace vs. Parenthesis</a>
<br><a data-tooltip-position="top" aria-label="`std::initializer_list`" data-href="#`std::initializer_list`" href="https://congzhi.wiki/about:blank#`std::initializer_list`" class="internal-link" target="_self" rel="noopener nofollow">`std::initializer_list`</a>
<br><br>There isn't much talk about this member initializer list really. We only use initializer list to initialize a new class object. You may see the member initializer list after a function definition of any kind of constructor, syntax with a colon character : . For example, consider the following:<br>class MyClass{
	int x, y, z;
public:
	// Most commonly used and seen
	MyClass(int _x, int _y, int _z) : x(_x), y(_y), z(_z) {}

	// Brace-enclosed initializer list semantics after C++11
	MyClass(int _x, int _y, int _z) : x{_x}, y{_y}, z{_z} {}
};
<br>But we have to following some rules here to order:<br>
<br>Reference members cannot be bound to temporaries in a member initializer list.
class MyClass{
	const int&amp; ref;
	MyClass() : ref(10) {} // This would cause an error
};


<br>Initialization do follow some orders:

<br>The compiler will initialize the object members in the order they are declared in the class, not the order they appear in the initializer list.

class MyClass {
    int x, y, z;
public:
	// x is still initialized before y and z
    MyClass(int _x, int _y, int _z) : z(_z), y(_y), x(_x) {} 
};


<br>So, when the x is initialized after y or z, or we say y is initialized after z, shit happens:

class MyClass {
    int x, y, z;
public:
	// x is initialized using the uninitialized y
	MyClass(int _x, int _y, int _z) : x(y), y(_y), z(_z) {}
};


<br><br>So, why are you recommended to use {} to initialize an object even though we have ()? Because they have different semantics. An exact example is how they are used in STL container.<br>std::vector&lt;int&gt; v(100, 1);  // Initializes a vector containing 100 items of value 1
std::vector&lt;int&gt; v{100, 1};  // Initializes a vector containing 2 items: 100 and 1

int i(3.14);  // Okay, i will be assigned the value 3 (narrowing conversion)
int i{3.14};  // Error, the assigned value must be type-specific (no narrowing)
<br>Another great thing with curly braces {} is automatically initial everything to zero for basic data types. For example:<br>int a{}; // a is initialized to 0
void* ptr{}; // ptr is initialized to nullptr

class MyClass {
public:
    int a;
    void* ptr;
    MyClass() = default;
};

MyClass obj{}; // All members are initialized to 0 (pointer to nullptr)
<br>But note that if you have a user-defined constructor like this, it can cause undefined behavior:<br>class MyClass {
public:
    int a;
    void* ptr;
    MyClass() {} // Would cause undefined behavior
};

MyClass obj{}; // Not all members are initialized
<br><br>Use initializer list for copy avoidance purposes.<br>#include &lt;iostream&gt;

class MyClass {
public:
    MyClass(int x, int y) {
        std::cout &lt;&lt; "Regular constructor called with " &lt;&lt; x &lt;&lt; " and " &lt;&lt; y &lt;&lt; std::endl;
    }

    MyClass(std::initializer_list&lt;int&gt; list) {
        std::cout &lt;&lt; "Initializer list constructor called with ";
        for (auto elem : list) {
            std::cout &lt;&lt; elem &lt;&lt; " ";
        }
        std::cout &lt;&lt; std::endl;
    }
};

int main() {
    MyClass obj1(100, 200);     // Calls the regular constructor
    MyClass obj2{100, 200};     // Calls the initializer list constructor
	// MyClass obj3{100.5, 200.5}; // No narrowing conversion
    return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/member-initializer-list-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Member Initializer List in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 26 Feb 2025 04:00:12 GMT</pubDate></item><item><title><![CDATA[Memory Management in C++ (Abandoned)]]></title><description><![CDATA[ 
 <br><br>在 ICS 中，我们学习了可执行目标文件视图的ELF可执行文件。我们了解了堆内存、栈内存、bss段、data段、text段等等的作用。程序运行时总是需要内存的，怎么办呢？我们要使用动态内存分配器，如malloc来让程序载入内存运行时能获取内存。<br>动态内存分配器管理进程虚拟内存的堆内存，在32位机器上，堆内存往往能占到进程虚拟内存的1/2甚至3/4，即2GB-3GB的空间。我们将虚拟内存划分成一个个“块(Blocks)"，这也是内存分配器分配内存的最小单位。通常来说，一个块的大小是512KB或4096KB，和磁盘的最小存储单位相同。<br><br><br>如C语言中的malloc和free，需要手动人工释放已经分配的内存。<br><br>如Java（Garbage Collection）。应用申请内存，释放自动完成。<br><br><br><br>#include &lt;stdlib.h&gt;

void *malloc(size_t size)
<br>当申请成功，返回一个指向申请内存块的的指针，申请的内存以字节为单位。如果 size == 0返回NULL或errno也就是申请失败。<br>在程序启动的时候，glibc库中的malloc会为用户申请一小段堆内存作为内存池。<br><br>参数: ptr: 指向要释放的内存块的指针。如果 ptr 为 NULL，则 free 不执行任何操作。<br>
注意事项:<br>
<br>释放内存后，指针 ptr 变为悬空指针（dangling pointer），应将其设置为 NULL 以避免悬空指针错误。
<br>释放未分配或已释放的内存会导致未定义行为。<br>
示例代码：
<br>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int *p = (int *)malloc(10 * sizeof(int));
    if (p == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // 使用分配的内存
    for (int i = 0; i &lt; 10; i++) {
        p[i] = i;
    }

    // 释放内存
    free(p);
    p = NULL; // 避免悬空指针

    return 0;
}
<br>这个示例中，malloc 分配了一个包含 10 个 int 类型元素的内存块，使用完后通过 free 释放内存，并将指针 p 设置为 NULL。<br>free怎么知道释放哪些内存空间？这是因为在内存分配时，分配器会在分配的内存块中存储一些额外的信息。这些信息通常包括内存块的大小和其他管理数据。<br><br>new和malloc的区别就是new在申请时会调用构造函数，如：<br>int parr = new int(10);//调用构造函数
int parr = new int;
<br>#include &lt;iostream&gt;
#include &lt;functional&gt;

int (*FuncPtr)(int, int) funcp1;

typedef int (*FuncPtrII)(int, int);
FuntPointerII funcp2;

std::function&lt;int(int,int)&gt; funcp3;
]]></description><link>https://congzhi.wiki/c-plus-plus/memory-management-in-c++-(abandoned).html</link><guid isPermaLink="false">C Plus Plus/Memory Management in C++ (Abandoned).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:11 GMT</pubDate></item><item><title><![CDATA[Move Semantics in C++]]></title><description><![CDATA[ 
 <br><br>在 C 中，我们常看到这样的表达式：int i = 10;。这种式子中，变量 i 是有地址属性的，而数字 10 是一个栈中的临时量，它只有值属性。由于 i 这样拥有地址属性的变量总是出现在等号的左边而 10 这种只有值属性的值总是出现在等号右侧。我们就将这种有地址属性在内存中有存储区域的表达式或变量称作左值(lvalue)，而不具有持久存储的值我们称作右值(rvalue)。<br>int i = 1; // okay
int j = i;  // okay
int 1 = j; // error
int k = (i + j); // okay, (i + j) is a rvalue
int (i + j) = k; // error
<br>由于左值有地址属性，所以我们可以对左值取地址，也就是 &amp;i 。<br>int i = 10;
int* pi = &amp;i; // okay
int* pi2 = i + i; // error, (i + i) is a rvalue
<br>除了一些字面量，一般而言，函数的返回值也是典型的右值。<br>int addValue(int a, int b)
{
	return a + b;
}
int main(){
	int i = addValue(3, 4); // okay
	addValue() = 5;     // error
}
<br><br>在我们学习引用的时候，我们说引用是另一个变量的别名。比如我们有以下的程序，在这里，变量 ref 是变量 i 的别名。也就是说，这两个变量共用一个地址空间。而右值没有地址空间，所以左值引用对右值的引用就是非法的。编译器会提示你：cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’。<br>int i = 10;
int&amp; lvref = i; // okay
int&amp; lvref = 10;// error, lvalue ref only bind to the lvalue
<br>我们并不能给没有地址的右值起一个别名。但为什么下面的程序就是可以合法的？<br>int main{
	const int&amp; lvref = 10;
	// as same as:
	const int temp = 10;
	const int&amp; lvref = temp;
}
<br>这是由于编译器会隐式地生成一个临时对象来存储右值，这被称为 temporary materialization 。所以实际上我们创建的仍然是对 10(temp) 的左值引用。当然，这种方式只是 C++11 之前右值引用没有出现时 C++ 绑定右值的方式。<br>我们从汇编也能窥见一二。<br>main:

        push    rbp
        mov     rbp, rsp
        mov     dword ptr [rbp - 4], 0
        
		; const int&amp; ref = 10;
        mov     dword ptr [rbp - 20], 10
        lea     rax, [rbp - 20]
        mov     qword ptr [rbp - 16], rax
		
		; const int temp = 10;
		; const int&amp; ref = temp;
        mov     dword ptr [rbp - 24], 10
        lea     rax, [rbp - 24]
        mov     qword ptr [rbp - 32], rax

        xor     eax, eax
        pop     rbp
        ret
<br>在左值引用中，我们最常见的用法就是用左值引用替换掉传统用指针传参的做法。引用和指针汇编后是一样的，但是指针我们需要取地址解引用。而引用完全不需要，你可以把引用理解成一种用户友好化的指针。<br>#include &lt;iostream&gt;

void printVal(int&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}
int main() {
    int x = 1;
    printVal(x);
    printVal(20); // cannot bind non-const lvalue reference to an rvalue
}
<br>同样的，在传递右值（20）的时候，你也需要用 const int&amp; 绑定右值参数。这时，编译器会生成一个临时的 const int 左值对象，并将其绑定到 val 上。<br>#include &lt;iostream&gt;

void printVal(const int&amp; val) {
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}
int main() {
    int x = 1;
    printVal(x); // ok
    printVal(20);// ok
}
<br>此外，我们还可以将函数的返回值变成左值引用类型。比如我们有一个 access_Val ，这样，函数返回引用就会使 int&amp; access_Val() 的返回值变为一个左值引用。在类中，我们可以用这种方式来 set 或 get 类内变量：<br>#include &lt;iostream&gt;

class example{
	int val;
public:
	int&amp; access_Val(){
		return val;
	}
};
int main(){
	example e1;
	e1.access_Val() = 10;
    std::cout &lt;&lt; e1.access_Val() &lt;&lt; std::endl;
	return 0;
}
<br>通过这种方式，我们实际上让 accessVal() 变成数据双向流向的函数。还可以避免不必要的拷贝。这样，我们可以直接操作类中的成员变量，并且在需要时进行赋值和获取，所有这些操作都避免了不必要的拷贝操作，提高了性能和效率。<br><br>在前面，我们发现类似这样的语句是非法的：int&amp; rvref = 10;。编译器会告诉你cannot bind non-const lvalue reference of type ‘int&amp;’ to an rvalue of type ‘int’。因为左值引用所引用的对象是一个右值，而左值引用是不能绑定到右值的。<br>而且我们注意到加上 const 实际上绑定的实际上还是左值。为了实现对右值的绑定，C++11 引入了右值引用 &amp;&amp; 。右值引用只能绑定右值，而不能绑定左值：<br>int&amp;&amp; rvref = 10;

int i = 10;
int&amp;&amp; rvref = i; // cannot bind rvalue reference of type to lvalue
<br>当我们试图去打印 rvref 时，我们可以得到期望的结果。但为什么要这样做？<br>#include &lt;iostream&gt;

int main(){
	int&amp;&amp; rvref = 10; // difference from `int i = 10;` ?
	int i = rvref;
	std::cout &lt;&lt; rvref &lt;&lt; std::endl; // prints out the integer 10
	std::cout &lt;&lt; &amp;rcref &lt;&lt; std:endl; // okay
	std::cout &lt;&lt; &amp;i &lt;&lt; std:endl;     // okay
	return 0;
}
<br>接着之前的例子：<br>#include &lt;iostream&gt;

// lvalue ref copy
void printVal(const int&amp; lval) {
    std::cout &lt;&lt; lval &lt;&lt; std::endl;
}
// rvalue ref no copy
void printVal(int&amp;&amp; rval) {
    std::cout &lt;&lt; rval &lt;&lt; std::endl;
}
// thus, this is not allowed with whose overloading above:
// void printVal(int val){
//
// } // not allowed
int main() {
    int x = 1;
    printVal(x); // ok, call printVal(const int&amp; lval)
    printVal(20);// ok, call printVal(int&amp;&amp; rval)
}
<br>有了因为右值引用绑定右值，所以当我们在函数里面传递的是右值时，它会调用右值引用的重载函数。我们后面会看到，使用右值引用可以减少不必要的内存拷贝的次数。当对象很大的时候，使用右值引用就可以显著优化资源管理和执行效率。<br><br>移动语义是C++11引入的一项特性，右值或右值引用是其最主要的应用。它允许对象的资源（如堆上分配的内存）在不进行深度复制的情况下进行所有权的转移。可以将对象的资源所有权从一个对象转移到另一个对象，从而避免不必要的内存拷贝，提高程序性能和效率。<br>假如我们有如下程序：<br>#inlcude &lt;vector&gt;
int main(){
	std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 }; 
	std::vector&lt;int&gt; v2{}; 
	v2 = v1;
	return 0;
}
<br>在进行拷贝操作时，标准库容器会进行深拷贝，这就意味着v2会拥有v1的所有资源的拷贝。<br><img alt="Pasted image 20250111194242.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250111194242.png"><br>虽然深拷贝可以避免数据的不一致性，但通常会涉及大量的内存操作，进而造成一定的存储和性能开销。而移动语义通过移动构造函数和移动赋值运算符，可以将资源“移动”到新对象中，而不是复制，从而减少了开销。<br><br>std::move 是 C++11 引入的一个标准库函数，std::move()并不移动任何东西。而是将其输入无条件地转换为右值引用（rvalue reference）。这意味着无论传递给 std::move 的是什么类型的对象，它都会被转换为右值引用，从而允许移动语义的应用。<br>template&lt;typename _Tp&gt;
    _GLIBCXX_NODISCARD
    constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;
    move(_Tp&amp;&amp; __t) noexcept
    { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); }
<br>为了避免额外的复制开销，C++ 引入了移动语义。在 STL 标准容器库中，移动赋值运算符已经在类内进行了重载、移动构造函数也进行了实现。确保等号的右边是右值的时候可以进行移动赋值。<br>假如我们有如下程序：<br>#inlcude &lt;vector&gt;
int main(){
	std::vector&lt;int&gt; v1{ 1, 2, 3, 4, 5 }; 
	std::vector&lt;int&gt; v2{}; 
	v2 = std::move(v1);
	return 0;
}
<br>这个例子中，我们用std::move()将v1的资源移动到v2，避免了深拷贝。这个过程图示如下：<br>
<br>
v2将v1所持有的资源进行引用：<br>
<img alt="Pasted image 20250111204014.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250111204014.png">

<br>
所有权进行转移，v1不再持有资源，进而重置v1：<br>
<img alt="Pasted image 20250111204033.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250111204033.png">

<br>通过std::move()，资源从v1转移到v2，v1不再持有这些资源。移动后的v1处于有效但未定义的状态，不再持有原资源。对于程序员而言，我们需要承诺在所有权转移后不再使用v1。<br><br>移动语义出现之后，我们想实践对象所有权的转移，我们需要两个特别的新函数：移动构造函数和移动赋值运算符(move constructor and move assignment operator)。从下面的代码中，你可以窥见所有权的转移是怎么样的。<br>#include &lt;string&gt;
class Widget {
private:
    int i{0};
    std::string s{};
    int* pi{nullptr}; // with unique opinter, you can make move constructor defalut
public:
    Widget(Widget&amp;&amp; w) noexcept
        : i(std::move(w.i)), s(std::move(w.s)), pi(std::move(w.pi)) // member-wise move
    {
        w.pi = nullptr; // Reset
    }
    Widget&amp; operator=(Widget&amp;&amp; w) noexcept {
        if (this != &amp;w) {
            delete pi; // Clean-up
            i = std::move(w.i); // Member-wise move
            s = std::move(w.s); // Member-wise move
            pi = std::move(w.pi); // Member-wise move
            w.pi = nullptr; // Reset
        }
        return *this;
    }
};
/*
#include &lt;string&gt;
#include &lt;memory&gt;

class Widget {
private: 
    int i{0};
    std::string s{};
    std::unique_ptr&lt;int&gt; pi{nullptr};
public:
    Widget(Widget&amp;&amp; w) = default; // noexcept by default
    Widget&amp; operator=(Widget&amp;&amp; w) = default; // noexcept by default
};
*/
<br>为了避免不必要的拷贝操作，“五法则”成为了 class designing 的最佳实践。然而，随着 C++11 引入了移动语义和智能指针等特性，“零法则”逐渐成为一种更理想的设计哲学。<br>“零法则”提倡不要手动定义任何特殊成员函数，而是依赖于编译器生成的默认实现。通过组合已有的类和资源管理器（例如 std::unique_ptr 和 std::shared_ptr），我们可以在需要时自动拥有正确的拷贝或移动行为。<br>// The Rule of Zero
#include &lt;memory&gt;

class myClass {
private:
    std::unique_ptr&lt;int&gt; data;
public:
    myClass() = default;
    ~myClass() = default;
    // No declaration of copy/move constructor or copy/move assignment operator
};

<br><br>例如，考虑一个简单的类 MyString，它包含一个指向字符数组的指针。在使用移动构造函数时，新的 MyString 对象会接管原对象的指针，而原对象的指针会被置为空指针，这样在销毁原对象时就不会重复释放内存。<br>#include &lt;iostream&gt;
#include &lt;string.h&gt;

class String{
private:
   char* m_Data;
   uint32_t m_Size;
public:
    String() = default;
    String(const char* string){
        m_Size = strlen(string);
        m_Data = new char[m_Size];
        memcpy(m_Data, string, m_Size);
        std::cout &lt;&lt; "String created!" &lt;&lt; std::endl;
    }
    String(const String&amp; other){
        m_Size = other.m_Size;
        m_Data = new char[m_Size];
        memcpy(m_Data, other.m_Data, m_Size);
        std::cout &lt;&lt; "String copied!" &lt;&lt; std::endl;
    }
    String(String&amp;&amp; other) noexcept{
        m_Size = other.m_Size;
        m_Data = other.m_Data;
        other.m_Size = 0;
        other.m_Data = nullptr;
        std::cout &lt;&lt; "String Moved!" &lt;&lt; std::endl;
    }
    ~String(){
        delete m_Data;
        std::cout &lt;&lt; "String destroyed!" &lt;&lt; std::endl;
    }
    void Print(){
        for (uint32_t i = 0; i &lt; m_Size; i++)
        {
            printf("%c", m_Data[i]);
        }
    }
};
class Entity{
private:
    String s_Name;
public:
    Entity(const String&amp; name) : s_Name(name){}
    Entity(String&amp;&amp; name) : s_Name((String&amp;&amp;)name){}

    void printName(){
        s_Name.Print();
    }
};

int main(){

    Entity entity("Hello\n");
    entity.printName();
    std::cin.get();
    return 0;
}
<br>在这个例子中，MyString 的移动构造函数通过 std::move 将资源从一个对象转移到另一个对象，从而避免了不必要的复制操作。]]></description><link>https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Move Semantics in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 24 Mar 2025 09:44:16 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250111194242.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20250111194242.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mutable and The M&M Rule in C++ (ENG)]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Const in C++" href="https://congzhi.wiki/c-plus-plus/const-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Const in C++</a><br><br>The mutable specifier allows a member to be modified in a const member function. In the example below, we qualify a function with const, which means we are not supposed to change the class members in the function. However, we do modify the mutable count member within the function scope.<br>class myClass{
private:
	int variable = 0;
	mutable int count;
public:
	int getVar() const{
	    count++;
	    return variable;
    }
};
int main(){
    myClass obj;
    int value = obj.getVar();
    return 0;
}
<br>"Const as a promise", using mutable specifier can break the constness of a function, which can be seen as poor code design. The principal of "const as a promise" implies that a const member function should not modify any member variables. But mutable is an exception to this rule, which can lead to unexcepted behavior.<br>However, mutable could be useful in some situations like mutexes for safer code(the M&amp;M rule), cache memory, and lazy evaluation.<br><br>This code example is copied from  <a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/cpp/language/cv" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/cpp/language/cv" target="_blank">cppreference</a>. As you can see, we have a const get() function, and with std::mutex, we create safe concurrent code. Why is that? While we are not supposed to modify anything in the const specified functions, with mutable, another thread can actually modify the data in a const specified function. This is no thread-safe.<br>class ThreadsafeCounter
{
    mutable std::mutex m; // The "M&amp;M rule": mutable and mutex go together
    int data = 0;
public:
    int get() const
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        return data;
    }
 
    void inc()
    {
        std::lock_guard&lt;std::mutex&gt; lk(m);
        ++data;
    }
};
<br>For achieving the goal of safer code and const correctness at the same time, we have to use the mutable keyword to make the mutex mutable in the const function. While a thread is modifying the critical section, using a lock to prevent other threads from entering and accessing the resource is thus necessary.]]></description><link>https://congzhi.wiki/c-plus-plus/mutable-and-the-m&amp;m-rule-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Mutable and The M&amp;M Rule in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 17 Mar 2025 05:52:20 GMT</pubDate></item><item><title><![CDATA[Namespaces in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br><br>People have family names to help distinguish individuals who have the exact same first name. This is a worldwide practice, no matter where you live. In C++, we do the same thing. We create specific namespaces to avoid name conflicts.<br><br>To the most of us, the very first encounter with namespace in C++ would be likely using namespace std; as shown in the example below:<br>#include &lt;iostream&gt;
using namespace std;

int main(){
	cout &lt;&lt; "Hello world!" &lt;&lt; endl;
	return 0;
}
<br>Using using namespace std; globally allows us to avoid repeatedly typing the std:: prefix. However, this practice can be harmful when handling large projects. Why?<br><br>As we just discussed, namespaces in C++ help us avoid name conflicts. Imagine this scenario: you're using multiple libraries that define functions with the same name. When you call these functions, how can the compiler (or linker) know which function to use? Just like if there are two people named Henry in your class, you don't just call out "Henry" because both might respond.<br>Since this would cause a loading error, we must have some mechanism to solve this problem. In C++, this mechanism is the namespace. It's like giving a function a name suffix. Let me give an easy example:<br>int sum(int a, int b) {
    return a + b;
}
namespace congzhi{ // namespace definition
    int sum(int a, int b) {
    // Do something else...
        return a + b;
    }
}
int main() {
    sum(1, 2);
    {
		using namespace congzhi;
		sum(1,2); // call congzhi::sum(1,2);
    }
//  congzhi::sum(1,2); // Same
    return 0;
}
<br>Let's say we use a math library that has a sum() function, but we would like our own sum() function to do something else inside the function scope. What we do is add a suffix name to the function using a namespace.<br>After compiling, you would see the difference: the congzhi namespace is actually added before the function name, resulting in _ZN7congzhi3sumEii, exactly like a suffix name or family name if you will.<br>_Z3sumii:
	pushq	%rbp
	movq	%rsp, %rbp
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	-4(%rbp), %edx
	movl	-8(%rbp), %eax
	addl	%edx, %eax
	popq	%rbp
	ret
_ZN7congzhi3sumEii:
	pushq	%rbp
	movq	%rsp, %rbp
	movl	%edi, -4(%rbp)
	movl	%esi, -8(%rbp)
	movl	-4(%rbp), %edx
	movl	-8(%rbp), %eax
	addl	%edx, %eax
	popq	%rbp
	ret
main:
	pushq	%rbp
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$2, %esi
	movl	$1, %edi
	call	_Z3sumii
	movl	$2, %esi
	movl	$1, %edi
	call	_ZN7congzhi3sumEii
	movl	$0, %eax
	popq	%rbp
	ret
<br>By the way, :: is called the scope resolution operator in C++, and it is used to specify which namespace or class a particular function or variable belongs to. The :: operator is also used to refer to the global namespace. As in:<br>int func(){ // global function
}
int var; // global variable

int main(){
	::var = 10; // equals to var = 10;
	::func(); // equals to func();
}
<br><br>Just like namespaces, classes can also play a similar role in C++. By defining member functions within a class, you can ensure that functions with the same name do not conflict with each other.<br>class MathLib {
public:
    int sum(int a, int b) {
        return a + b;
    }
    inline static int i = 0;
};

int main() {
    MathLib math;
    int result1 = math.sum(1, 2); // Calls MathLib::sum
    MathLib::i = 5; // Accesses static variable i
    return 0;
}
<br>Differently, unlike namespaces, classes provide encapsulation for member variables and member functions. This is something you cannot achieve with namespaces. That's why in most large projects, we use this pattern:<br>namespace congzhi{
	class MathLib{};
	class GraphLib{};
	class IOLib{};
}
<br>Thus we can group those related functionalities and avoid name conflicts.<br><br>Nested namespaces are not recommended in good design in most cases. We use namespaces primarily to distinguish different libraries. For example, std is used for the C++ standard library, and sdl is used for the SDL library. However, if you wish, you can add suffixes to function names as much as you like.<br>You simply use nested namespaces like this:<br>// nested namespaces
namespace A{ // Equals to: namespace A::B::C{ }
	namespace B{
		namespace C{
			exampleFunc(){
				// ...
			}
			// Some functions here...
		}
	}
}
int main(){
	{ // using derectives
		using namespace A::B::C;
		exampleFunc();
	} // A using namespace scope with life time
	A::B::C::exampleFunc(); // Same
	return 0;
}
<br><br>No denying, using the using namespace directive can be convenient. However, it can also bring issues that are not easy to identify, especially as the project grows larger.<br>// lib.hpp
namespace A{
	int sum(int a, int b){ // A::sum()
		return a + b;
	}
}
namespace B{
	int sum(int a, int b){ // B::sum()
		return a + b;
	}
}
<br>// main.cpp
#include "lib.hpp"
using namespace A; // gloabl namespace
using namespace B; // global namespace in another file
int main(){

	sum(1, 2); // which sum() would it call?
}
<br>In this simple example, try to guess which function it would call. You might think, "Well, I could just use the scope resolution operator B:: in this case, right?" But in a large project built by a team of people, this sum() call becomes ambiguous. Which one does it call? Even the compiler won't know, leading to compilation errors and potential big problems in the future.<br>Warning!!!
NEVER EVER WRITE using namespace AT GLOABL SCOPE IN A HEADER FILE
<br>So a good practice is as follows:<br>// main.cpp
#include "lib.hpp"

// No global namespace directives are allowed.

int function_using_lib_a(int a, int b) {
    using namespace A;
    return sum(a, b); // Calls A::sum
}
int main() {
    function_using_lib_a(1, 2);
    { // Samll scope
        using namespace B;
        sum(1, 2); // Calls B::sum
    }
    
    // Or like this:
    B::sum(1, 2); // Calls B::sum, even cleaner...
    return 0;
}
<br>Make the scope of using namespace as small as possible, or try not to use it at all.<br><br><br>Remember we had a example look like this? Every time we wanted to use exampleFunc(), we had to add the long suffix A::B::C::, this can be annoying. So, we can use namespace alias to define a alternate name for a namespace.<br>// nested namespaces
namespace A{ // Equals to: namespace A::B::C{ }
	namespace B{
		namespace C{
			exampleFunc(){
				// ...
			}
			// Some functions here...
		}
	}
}

namespace ABC = A::B::C; // namespace alias

int main(){
	A::B::C::exampleFunc();
	ABC::exampleFunc(); // Same
	return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/namespaces-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Namespaces in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 21 Feb 2025 02:13:06 GMT</pubDate></item><item><title><![CDATA[Networking - CS model]]></title><description><![CDATA[ 
 <br>在 Computer Networking: A Top-Down Approach 课程中，我们学习了数据是如何从 application layer 经由 transport layer 和 network layer 的两层封装，将数据传送到另一台主机上的特定端口号进程上的。在这个过程中，底层的网络如同一道道传送门，我们开发人员是不需要知道其中的实现细节的。当我们要将数据传送给另一台主机上的 application layer 进程时。我们只需要告诉网络目标主机的IP地址和端口号就能够使用网络进行数据的传输了。<br><br>在TCP实现的C/S原型模型中，我们实现的功能极为简单：服务器进程一直检测来自客户端进程的连接，一旦检测到有客户端“敲门”，就创建客户端Socket并给客户端发送"hello world"字符串，然后客户端回发，服务器显示。<br>//server
#include &lt;iostream&gt;
#include &lt;WinSock2.h&gt;	//声明
#include &lt;WS2tcpip.h&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;       //时间头函数
#pragma comment(lib, "ws2_32.lib")	//实现

const u_int BACKLOG = 128;
u_int link_count = 0;
const char* msg = "hello world";

//若当前socket连接数量小于BACKLOG，则每隔一秒打印一次打印监听信息。
void printListeningStatus() {
    while (link_count &lt; BACKLOG) {
        std::cout &lt;&lt; "Server is listening on port 2345...\tWe now can connect " 
                  &lt;&lt;BACKLOG - link_count&lt;&lt;" hosts." &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(2));
    }
}
//管理客户端进程
int clientHandle(SOCKET* servSock, SOCKET*clntSock) {

    // 打印客户端信息
    link_count++;
    sockaddr_in clntAddr;
    int clntAddrSize = sizeof(clntAddr);
    getpeername(*clntSock, (sockaddr*)&amp;clntAddr, &amp;clntAddrSize);
    char clntIP[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &amp;clntAddr.sin_addr, clntIP, INET_ADDRSTRLEN);
    std::cout &lt;&lt; "Client connected from IP: " &lt;&lt; clntIP &lt;&lt; " and port: " 
              &lt;&lt; ntohs(clntAddr.sin_port) &lt;&lt; std::endl;
    
    //处理与client的会话
    char recvBuf[128]{};
    if (send(*clntSock, msg, strlen(msg), 0) == -1) {
        std::cout &lt;&lt; "Sending fail!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        closesocket(*servSock);
        closesocket(*clntSock);
        WSACleanup();
        return -1;
    }
    int recvRet = recv(*clntSock, recvBuf, 128, 0);
    if (recvRet == 0) {
        std::cout &lt;&lt; "Client drop the connection gracefully." &lt;&lt; std::endl;
    }
    else if (recvRet &lt; 0) {
        int ErrNum = WSAGetLastError();
        if (ErrNum == 10054) {
            std::cout &lt;&lt; "Client drop the connection forcefully." &lt;&lt; std::endl;
        }
        else {
            std::cout &lt;&lt; "Receiving fail!\tError number is:" &lt;&lt; ErrNum &lt;&lt; std::endl;
            closesocket(*servSock);
            closesocket(*clntSock);
            WSACleanup();
            return -1;
        }
    }
    std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;
    closesocket(*clntSock);
    link_count--;
    std::cout &lt;&lt; "Client from IP: " &lt;&lt; clntIP &lt;&lt; " Port:" &lt;&lt; ntohs(clntAddr.sin_port) 
              &lt;&lt;" has been disconnected."&lt;&lt; std::endl;
    return 0;
}
int main() {
    //初始化WSADATA结构。
    WSADATA data{};
    if (WSAStartup(MAKEWORD(2, 2), &amp;data) == SOCKET_ERROR) {
        std::cout &lt;&lt; "WSAStart failed! \tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        WSACleanup();
        return -1;
    }
    //为服务器进程创建用于TCP/IP通信的套接字。
    SOCKET servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (servSock == INVALID_SOCKET) {
        std::cout &lt;&lt; "Server socket creation fail!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        WSACleanup();
        return -1;
    }
    /*定义一个sockaddr_in(Socket address internet)的结构体变量用来存储IP地址、端口号信息。
    之后将进程的“地址信息”一律转换成网络字节序（大端序）。*/
    sockaddr_in servAddr;
    servAddr.sin_family = AF_INET;      //设置地址族为IPv4
    servAddr.sin_port = htons(2345);	//将port号转换成网络字节序
    inet_pton(AF_INET, "127.0.0.1", &amp;servAddr.sin_addr.S_un.S_addr);//将IP地址转换成网络字节序

    //将服务器进程和特定的端口号进行绑定
    if (bind(servSock, (sockaddr*)&amp;servAddr, sizeof(sockAddr)) == SOCKET_ERROR) {
        std::cout &lt;&lt; "Binding fail!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        closesocket(servSock);
        WSACleanup();
        return -1;
    }

    //服务器socket状态从closed转换成listening。
    if (listen(servSock, BACKLOG) == -1) {
        std::cout &lt;&lt; "Listen function fail!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        closesocket(servSock);
        WSACleanup();
        return -1;
    }

    // 启动一个线程来打印监听状态
    std::thread statusThread(printListeningStatus);

    //当有client进程“敲门”，服务器进程就创建一个client socket线程来与客户端进程进行通信。
    while(link_count &lt; BACKLOG){
        SOCKET clntSock = accept(servSock, nullptr, nullptr);
        if (clntSock == INVALID_SOCKET) {
            std::cout &lt;&lt; "Client socket creation fail!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
            closesocket(servSock);
            WSACleanup();
            return -1;
        }
        // 创建一个线程来处理客户端通信
        std::thread clientThread(clientHandle, &amp;servSock, &amp;clntSock);
        //分离线程，让线程单独执行
        clientThread.detach();
    }

    // 等待线程结束
    statusThread.join(); 
    
    closesocket(servSock);

    WSACleanup();

    system("pause");
    return 0;
}
<br>// client
#include &lt;WinSock2.h&gt;
#include &lt;WS2tcpip.h&gt;
#include &lt;iostream&gt;
#pragma comment(lib, "ws2_32.lib")

int main() {
    // 初始化 WSADATA 结构。
    WSADATA data{};
    if (WSAStartup(MAKEWORD(2, 2), &amp;data) == SOCKET_ERROR) {
        std::cout &lt;&lt; "WSAStartup failed! \tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        return -1;
    }

    // 为客户端进程创建用于 TCP/IP 通信的套接字。
    SOCKET servSock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (servSock == INVALID_SOCKET) {
        std::cout &lt;&lt; "Client socket creation failed!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        WSACleanup();
        return -1;
    }

    // 定义一个 sockaddr_in 结构体变量用来存储服务器的 IP 地址和端口号信息。
    sockaddr_in servAddr;
    servAddr.sin_family = AF_INET;      // 设置地址族为 IPv4
    servAddr.sin_port = htons(2345);    // 将端口号转换成网络字节序
    inet_pton(AF_INET, "127.0.0.1", &amp;servAddr.sin_addr.S_un.S_addr); // 将 IP 地址转换成网络字节序

    // 连接到服务器
    if (connect(servSock, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) {
        std::cout &lt;&lt; "Connection failed!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        closesocket(servSock);
        WSACleanup();
        return -1;
    }

    // 接收服务器发送的数据
    char recvBuf[128]{};
    int recvRet = recv(servSock, recvBuf, 128, 0);
    if (recvRet == 0) {
        std::cout &lt;&lt; "Server dropped the connection gracefully." &lt;&lt; std::endl;
    }
    else if (recvRet &lt; 0) {
        int ErrNum = WSAGetLastError();
        if (ErrNum == 10054) {
            std::cout &lt;&lt; "Server dropped the connection forcefully." &lt;&lt; std::endl;
        }
        else {
            std::cout &lt;&lt; "Receiving failed!\tError number is:" &lt;&lt; ErrNum &lt;&lt; std::endl;
            closesocket(servSock);
            WSACleanup();
            return -1;
        }
    }

    // 发送数据到服务器
    if (send(servSock, recvBuf, recvRet, 0) == SOCKET_ERROR) {
        std::cout &lt;&lt; "Sending failed!\tError number is:" &lt;&lt; WSAGetLastError() &lt;&lt; std::endl;
        closesocket(servSock);
        WSACleanup();
        return -1;
    }

    closesocket(servSock);
    WSACleanup();
    system("pause");
    return 0;
}
<br><br>
void fileDirMnagr::listDir(int depth = 0)
{
	DIR *dir = opendir(currDir.c_str());
	if (!dir)
	{
		formattedMesg == "Cannot open " + currDir + ".\n";
		perror("Fail to open directory");
		return;
	}
	dirent *pDirent = nullptr;
	while ((pDirent = readdir(dir)) != nullptr)
	{
		const std::string filename = pDirent-&gt;d_name;
		if (filename == "." || filename == "..")
		{
			continue;
		}
		for (int i = 0; i &lt; depth; ++i)
		{
			formattedMesg += "    ";
		}
		formattedMesg += "|---" + filename;
		if (pDirent-&gt;d_type == DT_DIR)
		{
			formattedMesg += "/\n";
			std::string previousDir = currDir;
			currDir = currDir + "/" + filename;
			listDir(depth + 1);
			currDir = previousDir;
		}
		else
		{
			formattedMesg += "\n";
		}
	}
	if (closedir(dir) != 0)
	{
		perror("Fail to close directory");
	}
}

]]></description><link>https://congzhi.wiki/c-plus-plus/networking-cs-model.html</link><guid isPermaLink="false">C Plus Plus/Networking - CS model.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:20 GMT</pubDate></item><item><title><![CDATA[Noexcept in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>I believe most of us will question what noexpct keyword does when we start learning "the rule of five". The move constructor and the move assignment operator often have a specifier noexcept, what for? Why do we always need to make the move constructor noexcept?<br>class myClass{
private:
	// data members
public:
	myClass(){}
	~myClass(){}
	myClass(const myClass&amp; obj){} // Copy constructor
	myClass&amp; operator=(const myClass&amp; obj){} // Copy assignment operator
	myClass(myClass&amp;&amp; obj) noexcept {} // Move constructor
	myClass&amp; operator=(myClass&amp;&amp; obj) noexcept {} // Move assignment operator
};
<br>If you go to the reference, you will get a simple answer. It's for two purposes: one is for the compiler to generate better code, and the other is for better readability for the user. Every function in C++ is either&nbsp;non-throwing&nbsp;or&nbsp;potentially throwing, and you could specify them explicitly:<br>void funcA() noexcept {} // non-throwing, which means the function guarantees that it won't throw any exceptions
void funcB() noexcept(true) {} // non-throwing, more explicitly stating that the function guarantees it won't throw any exceptions

void funcA() {} // potentially throwing, meaning the function might throw exceptions
void funcB() noexcept(false) {} // potentially throwing, explicitly stating that the function might throw exceptions
<br>You see, every time you specify noexcept(noexcept(true)) , you are simply telling the compiler that the function will not throw errors at run-time, so that the compiler will do its best to optimize the code. Additionally, users can immediately understand that the function will not throw errors by seeing noexcept.<br>noexcept is a promise to the compiler and the runtime that the function will not throw exceptions, and breaking this promise will lead to program termination.<br>The noexcept specifier doesn't make the compiler check for potential exceptions at compile-time. It simply means that if an exception occurs within a function marked noexcept, the program will call std::terminate and terminate abruptly since the promise is broken. <br><br>Then back to our question, why do we need a noexcept with the move constructor? The real reason lies in STL containers. Functions marked with noexcept can enable move semantics, while without noexcept, they fallback to copy operations.<br>Normally, during a move operation, there should only be ownership transfers (just pointer evaluations). So you cannot really have anything fail happening there.<br>Is this a must? Well, it's not a must. If you call some potentially throwing function inside a noexcept specified function, there would be an error. It's easy to understand because you break the promise. Here’s an example illustrating a bad practice:<br>#include &lt;utility&gt;
class myClass {
private:
    // data members
public:
    // other member functions
    void throwing() {
        throw 20;
    } // not marked as noexcept
    myClass(){}
    myClass(myClass&amp;&amp; obj) noexcept(true) {
        // data moves
        throwing();
    } // this would be an error because the throwing function is not noexcept
};
int main(){

    myClass obj;
    myClass obj2(std::move(obj)); // throw an exception
    return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/noexcept-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Noexcept in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 09 Mar 2025 08:47:56 GMT</pubDate></item><item><title><![CDATA[Object Oriented Programming in C++]]></title><description><![CDATA[ 
 <br><br>在课堂中，我们学过 OOP 的三大特征，即封装、继承和多态。但时过境迁，OOP 的编程范式随着各种新技术的出现而不断更新。在这个文档中，我们会概述现代的 OOP 编程(A best practice)。<br><br>
Separation from interface and implementation.
<br><br>我们先从最基本的封装性谈起。C++&nbsp;用 “类类型&nbsp;(class&nbsp;types)” 来对数据进行封装。封装很好理解，即将类内成员变量和函数与外界分开。不像在&nbsp;C&nbsp;语言中，函数的实现光溜溜地暴露在全局范围&nbsp; (global&nbsp;scope)&nbsp;。在&nbsp;C++&nbsp;中，我们可以用类类型将这些函数的实现封装起来，只暴露使用的接口。<br>C++提供三种类类型：class、struct、union，而只有前两者提供对数据的有效封装性，我们忽略union类型。<br><br>
Don’t inherit for code reuse. Inherit, when you want to express a logical structure.
<br><br>继承是对一个类的继承。当我们继承一个类得到新的类时，我们需要明白，在不同的继承访问控制修饰符下，成员变量的可见性和访问权限是怎么样的。<br>class Account{
public:
  int pub{0};
protected:
  int prot{0};
private:
  int pri{0};
};
class PubAccount: public Account{
public:
  PubAccount(){
    pub + prot;  // public + protected
  }
};
class ProtAccount: protected Account{
public:
  ProtAccount(){
    pub + prot;  // protected + protected
  }
};
class PriAccount: private Account{
public:
  PriAccount(){
    pub + prot;  // private + private
  }
};

int main(){
  PubAccount pubAccount;
  ProtAccount proAccount;
  PriAccount priAccount;
  pubAccount.pub;
}
<br>为了封装性，基类的私有成员是不可以被继承到派生类中的。上面的例子中，展示了基类的不同成员的访问权限在不同继承方式下的访问权限。<br><br>在C++中，class 和 struct 的区别就是 struct 因为C兼容的缘故，默认的成员变量和成员函数是 public 的，而不像 class 中的 private。还有一个区别就是继承时，struct 默认的继承方式为 public ，而 class 默认的继承方式是 private 。这就是它们的区别。<br><br>Make every class in your hierarchy either a base-only or leaf only. <br><br>
The separation of the interface and its implementation is one of the crucial ideas of modern software design.
<br><br>多-态，即一种物体的多种状态。多态分为编译时多态性和运行时多态性。在OOP中，通常指后者。<br><br>也称为静态多态性，主要通过函数的重载和模板实现。C语言并不支持相同函数名的重载，C++通过将参数类型也作为符号名的一部分来支持函数的重载。如plus(int i)的符号名可能是_Z4plusi，最后面的i就表示有一个int类型的参数。如果在类中可能是这样的_ZN5Class4plus<br>由于这种多态性在编译期就确定下来了，所以效率要高一点。由于这种在编译时就确定的多态性，有时并不将静态多态性看作是真正意义上的多态。我们用模板的代码简单演示一下。<br>#include &lt;iostream&gt;

template&lt;typename T&gt;
T plus(T x){
    return x+1;
}
int main(){
    auto y = plus(20);
    auto z = plus(3.14);
    auto e = plus('c');
    return 0;
}
<br>由于模板只有在调用相应类型的时候才会实例化，所以在这段代码中，我们在编写代码时就能说出来编译后会相应地产生三个关于 plus 的函数符号。而且这三个符号是独立的，链接时并不将其看作一个函数看待。<br>编译完成后查看符号表，我们确实看到了三个不同的函数符号：<br>du@DVM:~/Desktop/DSA$ nm -n stat_poly
                 U __cxa_atexit
                 U __dso_handle
                 U _GLOBAL_OFFSET_TABLE_
                 U _ZNSt8ios_base4InitC1Ev
                 U _ZNSt8ios_base4InitD1Ev
0000000000000000 T main
0000000000000000 W _Z4plusIcET_S0_
0000000000000000 W _Z4plusIdET_S0_
0000000000000000 W _Z4plusIiET_S0_
0000000000000000 b _ZStL8__ioinit
0000000000000047 t _Z41__static_initialization_and_destruction_0ii
000000000000009d t _GLOBAL__sub_I_main

<br><br>也称动态多态性，通过虚函数和继承来实现。由于虚多态只有在程序运行时才能确定实际调用的时哪个函数，所以效率较低。（存储虚表造成的空间复杂度和虚指针索引导致的时间复杂度增加）<br>相关请参阅<a data-href="Virtual Dispatch in C++" href="https://congzhi.wiki/c-plus-plus/virtual-dispatch-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Virtual Dispatch in C++</a>。<br><br>
OOP is a programming paradigm in C++ using polymorphism based on runtime function dispatch using virtual functions.
<br><br>在OOP范式中，由于派生类是基类派生而来的，所以它们的库所用的API是相同的。通过创建对象将派生类实例化，每个对象可以具有不同的状态和行为。这种特性就是由"virtual"所提供的动态多态性。即基类定义的API可以被派生类对象重写，从而在不同对象中表现出不同的实现。在编译期(compile time)，确定派生对象的类型。在运行时(runtime)，我们才能知道派生类的状态。]]></description><link>https://congzhi.wiki/c-plus-plus/object-oriented-programming-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Object Oriented Programming in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 28 Feb 2025 04:41:31 GMT</pubDate></item><item><title><![CDATA[Operator Overloading in C++ (ENG)]]></title><description><![CDATA[ 
 <br>We introduce operator overloading mainly to address situations where the existing operators do not align with the unique properties of a class. Besides the concept, you will also learn some in-depth details about how it works. Here is what you will learn in this note:<br>
<br><a data-tooltip-position="top" aria-label="Overloading Syntaxes" data-href="#Overloading Syntaxes" href="https://congzhi.wiki/about:blank#Overloading_Syntaxes" class="internal-link" target="_self" rel="noopener nofollow">Overloading Syntaxes</a>

<br><a data-tooltip-position="top" aria-label="Overloading Syntaxes > Binary Operators" data-href="#Overloading Syntaxes#Binary Operators" href="https://congzhi.wiki/about:blank#Overloading_Syntaxes#Binary_Operators" class="internal-link" target="_self" rel="noopener nofollow">Binary Operators</a>
<br><a data-tooltip-position="top" aria-label="Overloading Syntaxes > Unary Operators" data-href="#Overloading Syntaxes#Unary Operators" href="https://congzhi.wiki/about:blank#Overloading_Syntaxes#Unary_Operators" class="internal-link" target="_self" rel="noopener nofollow">Unary Operators</a>
<br><a data-tooltip-position="top" aria-label="Overloading Syntaxes > Special Operators" data-href="#Overloading Syntaxes#Special Operators" href="https://congzhi.wiki/about:blank#Overloading_Syntaxes#Special_Operators" class="internal-link" target="_self" rel="noopener nofollow">Special Operators</a>
<br><a data-tooltip-position="top" aria-label="Overloading Syntaxes > Operator Matters" data-href="#Overloading Syntaxes#Operator Matters" href="https://congzhi.wiki/about:blank#Overloading_Syntaxes#Operator_Matters" class="internal-link" target="_self" rel="noopener nofollow">Operator Matters</a>


<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples" data-href="#Finally, Easy Examples" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples" class="internal-link" target="_self" rel="noopener nofollow">Finally, Easy Examples</a>

<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > This is about Static Polymorphism, Right?" data-href="#Finally, Easy Examples#This is about Static Polymorphism, Right?" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#This_is_about_Static_Polymorphism,_Right" class="internal-link" target="_self" rel="noopener nofollow">This is about Static Polymorphism, Right?</a>
<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > Overloading `+`" data-href="#Finally, Easy Examples#Overloading `+`" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#Overloading_`+`" class="internal-link" target="_self" rel="noopener nofollow">Overloading `+`</a>
<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > Overloading `++`" data-href="#Finally, Easy Examples#Overloading `++`" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#Overloading_`++`" class="internal-link" target="_self" rel="noopener nofollow">Overloading `++`</a>
<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > Overloading `<<`" data-href="#Finally, Easy Examples#Overloading `<<`" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#Overloading_`<<`" class="internal-link" target="_self" rel="noopener nofollow">Overloading `&lt;&lt;`</a>
<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > Overloading `new` and `delete`" data-href="#Finally, Easy Examples#Overloading `new` and `delete`" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#Overloading_`new`_and_`delete`" class="internal-link" target="_self" rel="noopener nofollow">Overloading `new` and `delete`</a>
<br><a data-tooltip-position="top" aria-label="Finally, Easy Examples > `inline` Overloading for Comparison Operators" data-href="#Finally, Easy Examples#`inline` Overloading for Comparison Operators" href="https://congzhi.wiki/about:blank#Finally,_Easy_Examples#`inline`_Overloading_for_Comparison_Operators" class="internal-link" target="_self" rel="noopener nofollow">`inline` Overloading for Comparison Operators</a>


<br><br>C++ provides us a lot of operators, and some special operators like new and new[], delete and delete[], as well as co_await since C++20. Before we go under the hood, let's first take a look at the kinds of operators we have in C++.<br><br>Binary operators operate on two operands. Here are the binary operators in your list:<br>
<br>+, -, *, /, % (Arithmetic operators)<br>

<br>^, &amp;, | (Bitwise operators)<br>

<br>=, +=, -=, *=, /=, %=, ^=, &amp;=, |=, &lt;&lt;=, &gt;&gt;= (Assignment operators)<br>

<br>&lt;, &gt;, &lt;=, &gt;=, ==, !=, &lt;=&gt; (Comparison operators)<br>

<br>&amp;&amp;, || (Logical operators)<br>

<br>&lt;&lt;, &gt;&gt; (Bitwise shift operators)<br>

<br>, (Comma operator)<br>

<br>-&gt;*, -&gt; (Member access operators)<br>

<br>[], () (Subscript and function call operators)
<br><br>Unary operators operate on a single operand. Here are the unary operators in your list:<br>
<br>~ (Bitwise NOT)<br>

<br>! (Logical NOT)<br>

<br>++, -- (Increment and Decrement operators)
<br><br>Such as new, new[] etc...<br><br>Later, we will create an overloaded operator ourselves. Before that, it's important to understand that different operators play a significant role in operator overloading. We categorized these operators into binary and unary operators, their signatures can vary depending on the operator.<br>Those signatures match the following:<br><br>And be aware, the operators =, (), [], and -&gt; cannot be non-member functions for specific reasons, Copilot says this is because those operators need direct access to the object.<br><br><br>We use the keyword operator to define operator overloading, which allows us to provide custom implementations for operators in user-defined types or classes. When you overload an operator, it behaves exactly like a function with a special name, different parameter means different function symbol. And yes, this is a familiar concept we known as <a data-tooltip-position="top" aria-label="Static Dispatch in C++ (ENG)" data-href="Static Dispatch in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/static-dispatch-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">static polymorphism</a>.<br><br>#include &lt;iostream&gt;
#include &lt;cstring&gt;
struct vector {
    float x, y, z;

    vector operator+(const vector&amp; rhs) const {
        vector result;
        result.x = this-&gt;x + rhs.x;
        result.y = this-&gt;y + rhs.y;
        result.z = this-&gt;z + rhs.z;
        return result;
    }
};
struct string{
	char* str;
    int str_len;
	string(const char* s = "") {
        str_len = std::strlen(s);
        str = new char[str_len + 1];
        for(int i = 0; i &lt; str_len + 1; i++)
            str[i] = s[i];
    }
    ~string() {
        delete[] str;
    }
	string operator+(const string&amp; other) const {
        int new_length = str_len + other.str_len;
        char* new_str = new char[new_length];
        std::strcpy(new_str, str);
        std::strcat(new_str, other.str);
        return string(new_str);
    
    }
};

int main() {
    vector v1 = {1.0, 2.0, 3.0};
    vector v2 = {4.0, 5.0, 6.0};
    vector v3 = v1 + v2;

    std::cout &lt;&lt; "Result: (" &lt;&lt; v3.x &lt;&lt; ", " &lt;&lt; v3.y &lt;&lt; ", " &lt;&lt; v3.z &lt;&lt; ")" &lt;&lt; std::endl;
    string s1 = string("hello, ");
    string s2 = string("world!");
    string s3 = s1 + s2;
    std::cout &lt;&lt; "Result: " &lt;&lt; s3.str &lt;&lt; std::endl;
    return 0;
}
<br><br><br><br><br>For operators that are simple to implement, we usually use the inline keyword to instruct the compiler to inline the overloaded operator. We can get several benefits after this:<br>
<br>Performance Improvement
<br>Code Optimization
]]></description><link>https://congzhi.wiki/c-plus-plus/operator-overloading-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Operator Overloading in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:33 GMT</pubDate></item><item><title><![CDATA[Parameter Pack in C++ (ENG, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/parameter-pack-in-c++-(eng,-nc).html</link><guid isPermaLink="false">C Plus Plus/Parameter Pack in C++ (ENG, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 27 Feb 2025 08:54:30 GMT</pubDate></item><item><title><![CDATA[Part1：C++11 (Abandoned)]]></title><description><![CDATA[ 
 <br><br>const(ant)，望文生义就是"常值"的意思。在C++中，我们使用 const 修饰符用来表示修饰后的数值或字符串是不可改动的，如：<br>const int i = 20;//int const i = 20;一个道理
const char ch = 'a';
const char* s = "hello world";
const int* p = 100;//指针p指向的数字100是常值，但是指针可以变
int* const p = 100;//定义了一个常指针指向数值为100的区域，这里的数值是可以改变的
const int* const p = 100;//定义了一个指向常量100的常指针
<br>const修饰的变量和常量是不一样的。常量常常会放到.text段或.rodata段，但是const修饰的变量不一定放在.rodata段。如果变量是局部变量，它的生命周期会随着函数的返回、栈帧的销毁一同消逝。但是如果const修饰的是全局变量，则一般会将这个全局变量放在.rodata段中。<br>我们在下面的例子中进一步学习。我们定义了全局变量和许多局部变量。其中 const_global 会放到.rodata段中，global 会放在bss/data段中。在函数中，字符串"hello world"是一个常字符串，会被放到.rodata段中，其余函数内用const修饰局部变量的生命周期都会随着栈帧的摧毁而消逝。<br>const int const_global = 0;
int global = 20;

int constFunc(const char** d,const int** e) {
	const char* s = "hello world";
	const int i = 5;
	*d = s;
	*e = &amp;i;
	return 0;
}
int main() {
	int x = 30;
	int y = 40;
	const char* a;
	const int* b;
	constFunc(&amp;a, &amp;b);
	return 0;
}
<br><br>auto 是C++11新加入的关键字，用于自动推导变量的类型。它可以让编译器根据初始化表达式自动确定变量的类型，从而简化代码编写和提高代码的可读性。但是要注意，在使用 auto 时要清楚编译器会给 auto 什么类型。我们可以使用 boost库 来判断变量的具体类型。<br>在使用auto时，我们要注意以下几点：<br>
<br>auto只能推断出类型，而引用不是类型，所以auto无法推断出引用，要引用只能自己加引用符号。代码演示如下：
<br>int i = 100;
auto i2 = i;//i2为 int 类型
auto&amp; refI = i;//refI 为 int&amp; 类型
/*
我们看到，只有自己加入引用类型后 refI 才能变成 int&amp;。
*/
<br>
<br>auto关键字在推断引用的类型时，会直接将引用替换为引用指向的对象。引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。
<br>int i = 100;
int&amp; refI = i;
auto i2 = refI;//相当于 auto i2 = i;  i2 类型为 int
auto&amp; i3 = refI;//相当于auto&amp; i3 = i;  i3 类型为 int&amp;
<br>
<br>auto关键字在推断带const关键字的类型时，若没有引用符号，则会忽略const的修饰。而保留指向对象的const，典型的就是指针。
<br>const int i = 100;
auto i2 = i;//i2 为 int 类型

int j = 100;
const int* const p = &amp;j;//定义了一个指向常量 int 的常指针p
auto p2 = p;//p2的类型为const int*，是指向常量 int 的指针。

static int k = 100;
auto k2 = k;//k2 为 int 类型
<br>请留意：在这行代码中const int* const p = &amp;j;//定义了一个指向常量 int 的常指针p，j&nbsp;并没有被设置为常量。p&nbsp;是一个指向&nbsp;const int&nbsp;的常指针，但这并不改变&nbsp;j&nbsp;的本质。只是说不能通过&nbsp;p&nbsp;来修改&nbsp;j&nbsp;的值。<br>
4. 在auto关键字推断类型时，如果带引用符号则会保留值类型。<br>const int i = 100;
auto&amp; i2 = i;//i2 为 const int 类型

int j = 100;
const int *const p = &amp;j;//定义了一个指向常量 int 的常指针p
auto&amp; p2 = p;//p2的类型为const int* const&amp;。

static int k = 100;
auto&amp; k2 = k;//k2 为 int&amp; 类型
<br>
<br>如果在auto前面加上const，就会永远有const的含义。
<br>int i = 100;
const auto i2 = i;//i2 为 const int 类型
<br><br>全局变量和静态变量都是存放在.data/.bss段中的，这些变量在编译过程中就已经被赋予地址，在执行时不会再次调用。我们用代码做简单的演示。<br>int global_1 = 100;//.data
int global;//.bss

void test(){
	static int i;//.bss，在程序启动时自动初始化为0
	static int i2 = 0;//.data，且这行代码不会再进程运行时执行
	++i;
}

int main(){
	test();
	test();
}
<br><br>C++的表达式一般有两部分对象组成，如int i = 100;。在表达式中，左值(lvalue) 就是能够取地址的那部分（有地址属性，表达式结束后依然存在的持久对象），而不能够取地址的我们称之为右值(rvalue)（表达式结束后就不再存在的对象）。在上面的表达式中，变量对象i就是左值，10这样的字面量（字符字面量除外）对象就是右值。<br>左值来源于C语言的说法，即可以放在等号左边的就叫左值，左值也可以放在等号右边。但右值只能放到赋值操作符的右边，这是因为右值没有持久的存储位置（临时对象），所以不能作为赋值操作的目标。<br><br>
<br>普通左值引用：一个对象的别名，只能绑定左值，无法绑定右值。
<br>int i = 100;
int&amp; ref = i;//lvalue reference, no mistake

const int i2 = 100;
int&amp; ref2 = i2;//错误：非常量引用不能绑定到常量
const int&amp; ref2 = i2;//正确
ref2 = 200;//如果绑定后就会违反常量的不可变原则

int&amp; ref3 = 100;//错误：非常量引用不能绑定到右值
<br>
<br>const左值引用：可以对常量起别名，可以绑定左值和右值。
<br>const int i =100;
const int&amp; ref = i;//正确

const int&amp; ref = 100;//正确
<br>
<br>右值引用：右值引用只能绑定到右值。右值引用的主要用途是实现移动语义和优化性能。
<br>int i = 100;
int&amp;&amp; rref = 200;//正确
int&amp;&amp; rref2 = (i+1);//正确
int&amp;&amp; rref3 = i++;//正确，i++是一个右值表达式，因为它返回 i 的旧值（临时对象）

int&amp;&amp; rref4 = i;//错误，i是右值
int&amp;&amp; rref5 = ++i;//错误，++i是左值，因为它返回的是 i 的引用类型
<br>
<br>万能引用：属于模板的部分：万能引用、引用折叠、完美转发。在学习模板时再学习。
<br><br>在上节课中，我们看到，在使用右值引用时不能绑定左值。在C++11中，我们可以通过move函数来将左值转换为右值引用。<br><br>
<br>右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值看待。
<br>当我们使用了move函数后，操作对象就失去了其地址属性。因此，我们有义务保证之后避免使用该变量的地址属性，也就是不再使用该变量，因为再次使用该变量不可避免地会使用到变量的地址属性。在后面移动语义时会体现move函数意义。
<br>#include&lt;utility&gt;
int i = 100;
int&amp;&amp; rref = i;//错误，因为 i 是左值，不能绑定到右值引用

int&amp;&amp; rref2 = std::move(i);//正确，std::move 将 i 转换成右值引用
int&amp;&amp; rref3 = srd::move(++i);//正确，++i 是左值，std::move 将 ++i 转换成右值引用
<br><br>临时对象是程序执行时生成的中间对象，所有的临时对象都是右值对象，因为临时对象产生后很快就会被销毁。常见的临时对象有：<br>
<br>函数返回值：当函数返回一个对象时，会创建一个临时对象来存储返回值，如：
<br>int get20(){
	return 20;//返回一个临时对象
}
int&amp;&amp; i = get20();
<br>
<br>类型转换：当需要进行类型转换时，编译器会创建临时对象。如：
<br>double d = 3.14;
int i = static_cast&lt;int&gt;(d);//临时对象存储转换后的值，然后赋给 i 。
<br>
<br>表达式中的中间结果：在复杂表达式中，临时对象用于存储中间结果。
<br>int a = 5, b = 10;
int result = (a + b) * 2; // 临时对象存储 a + b 的结果   
<br><br>如果一个对象可以使用调用运算符"()"，()里面可以放参数。那么这个对象就是可调用对象。可调用对象的分类有：<br> Lambda表达式：也称为匿名函数，是一种需要一个函数但不想命名它的情况下使用的简便方法。基本语法是：[capture list] (parameter list) -&gt; return_type { function body }	<br>
<br>捕获列表 []：指定Lambda表达式可以访问的外部变量，可以按值（=）或按引用（&amp;）捕获。

<br>[ ]表示不捕获任何变量。
<br>[=]表示按值捕获所有变量。
<br>[&amp;]表示按照引用捕获所有变量。
<br>[=,&amp; i]除了 i 按引用传递，其他所有变量按值转递。
<br>[&amp;, i]表示除了 i 按值传递，其他变量按引用传递。
<br>也可以捕获单独变量，如[i]，[&amp;i]。


<br>参数列表（parameter list）：与普通函数的参数列表类似，可以为空。
<br>返回类型（return type）：可以省略，由编译器推导，也可以显式指定。
<br>函数体（function body）：Lambda表达式的具体逻辑。
]]></description><link>https://congzhi.wiki/c-plus-plus/part1：c++11-(abandoned).html</link><guid isPermaLink="false">C Plus Plus/Part1：C++11 (Abandoned).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:39 GMT</pubDate></item><item><title><![CDATA[Part2：Class (Abandoned)]]></title><description><![CDATA[ 
 <br><br>在C语言中，我们常用struct关键字来定义我们想要的数据类型，但结构体中不能包含函数。这是因为结构体中的变量存储在数据段（如.bss、.data）或堆栈上，而函数存储在代码区（.text）。我们要对结构体的数据进行操作，只能在结构体外定义各种函数，这不仅不利于数据的封装性，而且独立的函数也容易让人一头雾水。（C++中，struct和class的唯一区别就是默认类内/结构体中的属性不同，还有继承）<br>以下是一个面向过程的“把大象放进冰箱”的操作示例：<br>#include &lt;stdio.h&gt;

typedef struct {
    unsigned int height;
    unsigned int weight;
    unsigned int age;
} person;

typedef struct {
    unsigned int volume;
} elephant;

typedef struct {
    unsigned int volume;
} fridge;

void person_cutting_elephant(person p, elephant e) {
    /*
    cutting operations
    */
    printf("Elephant has been cut\n");
}

void person_fill_fridge(person p, elephant e, fridge f) {
    /*
    filling operations
    */
    printf("Fridge has been filled\n");
}

int main() {
    person p = {180, 70, 24};
    elephant e = {5};
    fridge f = {6};
    person_cutting_elephant(p, e);
    person_fill_fridge(p, e, f);
    return 0;
}
<br>在这个例子中，我们定义了人、大象和冰箱三个结构体，并在结构体外编写了相关函数。虽然这样可以完成任务，但数据和操作分离的形式并不直观。当使用结构体，操作函数描述起来的着重点是函数，如：人把大象切开了，其中人是p、大象是e（有了类，我们就可以说p人把e大象切开了）。<br>而C++提供了class类描述符，可以将对象的操作（方法函数）放到类内，不仅提升了数据元素的封装性，还使整个过程的思维流程更加通顺易懂。在开发大型项目时，海量的操作函数并不利于项目迭代和操作不同的对象。而类能做什么，只需查看类内成员函数就一目了然了。在写一个面向对象的“把大象放进冰箱”的操作示例之前，我们先学习类的构造函数和析构函数。<br><br><br>类相当于一个新类型，该类型的成员变量可以放在数据段或堆栈上，同样成员函数会存储在代码区（.text段）。构造函数就是在类对象创建时就在对应内存将数据初始化的成员函数。<br><br>
<br>默认构造函数：没有参数的构造函数。我们可以定义自己的默认构造函数来初始化不带参数的对象。如果我们没有定义默认构造函数，编译器会自动生成一个默认构造函数，这个默认构造函数什么都不干。
<br>普通构造函数：带参数的构造函数。普通构造函数是用于初始化对象的构造函数。
<br>复制构造函数：用于创建对象的副本。该对象是通过复制现有对象来初始化的。它接受一个同类对象的引用作为参数。
<br>移动构造函数：移动构造函数用于创建一个新对象，它接受一个右值引用（&amp;&amp;）作为参数。移动构造函数会将右值引用对象资源移动到新对象，并”人工地“将源对象的成员变量重置。
<br>class person
{
public:
	unsigned int height;
	unsigned int weight;
	unsigned int age;
public:
	//默认构造函数
	person() :height(0), weight(0), age(0) {
		std::cout &lt;&lt; "Default constructor has been called." &lt;&lt; std::endl;
	}
	//普通构造函数
	person(unsigned int height_, unsigned int weight_, unsigned int age_)
		:height(height_), weight(weight_), age(age_) {
		std::cout &lt;&lt; "A person object is constructed." &lt;&lt; std::endl;
	}
	//复制构造函数
	person(const person&amp; other_person)
		:height(other_person.height), weight(other_person.weight), age(other_person.age) {
		std::cout &lt;&lt; "Copy constructor has been called." &lt;&lt; std::endl;
	}
	//移动构造函数
	person(person&amp;&amp; other_person)
		noexcept:height(other_person.height), weight(other_person.weight), age(other_person.age) {
		other_person.height = 0;
		other_person.weight = 0;
		other_person.age = 0;
		std::cout &lt;&lt; "Move constructor has been called." &lt;&lt; std::endl;
	}
		~person() {}
};
<br><br>析构函数（Deconstructor）是C++中的一种特殊成员函数，用于在对象的生命周期结束时执行清理操作。析构函数的名称与类名相同，但前面有一个波浪号（~），并且没有返回类型和参数，所以不能够重载。<br>析构函数的作用是释放类对象的资源，只有当类内成员申请内存才需要在析构函数中显式定义delete操作，否则析构函数不需要释放什么资源。如果类管理其他资源（如文件句柄、网络连接、数据库连接等），需要在析构函数中释放这些资源。<br><br>我们忽略大象类、冰箱类的实现和操作的实现细节，以下是一个面向对象的“把大象放进冰箱”的操作示例：<br>#include&lt;iostream&gt;
class person;
class elephant;
class fridge;

class person
{
public:
	unsigned int height;
	unsigned int weight;
	unsigned int age;
public:
	//默认构造函数
	person() :height(0), weight(0), age(0) {
		std::cout &lt;&lt; "Default constructor has been called." &lt;&lt; std::endl;
	}
	//普通构造函数
	person(unsigned int height_, unsigned int weight_, unsigned int age_)
		:height(height_), weight(weight_), age(age_) {
		std::cout &lt;&lt; "A person object is constructed." &lt;&lt; std::endl;
	}
	//复制构造函数
	person(const person&amp; other_person)
		:height(other_person.height), weight(other_person.weight), age(other_person.age) {
		std::cout &lt;&lt; "Copy constructor has been called." &lt;&lt; std::endl;
	}
	//移动构造函数
	person(person&amp;&amp; other_person)
		noexcept:height(other_person.height), weight(other_person.weight), age(other_person.age) {
		other_person.height = 0;
		other_person.weight = 0;
		other_person.age = 0;
		std::cout &lt;&lt; "Move constructor has been called." &lt;&lt; std::endl;
	}
		~person() {}
		void person_cut_elephant(const person p, elephant e) ;
		void person_fill_fridge(const person p, elephant e, fridge f) ;
};
int main() {
	person p(180, 70, 24);
	elephant e(5);
	fridge f(6);
	p.person_cut_elephant();
	p.person_fill_fridge();
	return 0;
}
<br>这样，我们能明显的感受到前面“人把大象切开了，其中人是p、大象是e（有了类，我们就可以说p人把e大象切开了）。”这句话的含义。<br><br><br>this 是&nbsp;C++&nbsp;中的一个关键字，也是一个 const&nbsp;指针，它指向当前对象，通过它可以访问当前对象的所有成员。所谓当前对象，是指正在使用的对象。this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。this的简单用法如下：<br>#include &lt;iostream&gt;

class person {
	int height;
	int weight;
	int age;
public:
	person(int h, int w, int a) :height(h), weight(w), age(a) {
		std::cout &lt;&lt; "A person object has been added." &lt;&lt; std::endl;
	}
	~person() {}
	void getter() {
		std::cout &lt;&lt; "Height: " &lt;&lt; this-&gt;height &lt;&lt; std::endl &lt;&lt; "Weight: "
			&lt;&lt; this-&gt;weight &lt;&lt; std::endl &lt;&lt; "Age: " &lt;&lt; this-&gt;age &lt;&lt; std::endl;
	}
	void setter(int height, int weight, int age) {
		this-&gt;height = height;// 使用 this-&gt;height 表示成员变量
		this-&gt;weight = weight;
        this-&gt;age = age; 
    }
};

int main() {
	person Pa(160, 50, 22);
	person Pb(175, 60, 20);
	Pa.getter();
	Pb.getter();
	return 0;
}
<br>编译器将this关键字解释为指向函数所作用的对象的指针。 C++类的本质就是C语言的结构体外加几个类外的函数，C++最后都要转化为C语言来实现，类外的函数就是通过this来指向这个类的。上面的类在 C 语言中的实现如下：<br>#include &lt;stdio.h&gt;

typedef struct {
    int height;
    int weight;
    int age;
} Person;

void initPerson(Person *this, int height, int weight, int age) {
    this-&gt;height = height;
    this-&gt;weight = weight;
    this-&gt;age = age;
    printf("A person object has been added.\n");
}

void getter(const Person *this) {
    printf("Height: %d\nWeight: %d\nAge: %d\n", 
    this-&gt;height, this-&gt;weight, this-&gt;age);
}

void setter(Person *this, int height, int weight, int age) {
    this-&gt;height = height; // 使用 p-&gt;height 表示成员变量
    this-&gt;weight = weight;
    this-&gt;age = age;
}

int main() {
    Person Pa, Pb;
    initPerson(&amp;Pa, 160, 50, 22);
    initPerson(&amp;Pb, 175, 60, 20);
    getter(&amp;Pa);
    getter(&amp;Pb);
    return 0;
}

<br>this有很多功能是单纯的指针无法满足的。比如每个类函数的参数根本没有名叫this的指针。这是编译器赋予的功能。<br><br>const除了修饰变量，还可以用来修饰类内函数。用 const 修饰的函数我们称为常成员函数。C++规定常成员函数在调用时不会修改类的成员变量。<br>class MyClass {
public:
    int getValue() const { // 常成员函数
        return value;
    }
    void setValue(int val) {
        value = val;
    }
private:
    int value;
};
<br>函数括号后的const实际上是为了修饰this，常成员函数会隐式地转换为：<br>void outPut(const myClass* const myThis){
	std::cout &lt;&lt; myThis-&gt;name &lt;&lt; std::endl;
}
<br>但由于this是隐式的，所以将const放到括号外。<br><br>同样，加入const关键字就可以定义一个常对象。理解起来也很方便，常对象的对象变量是不可改变的。这样一来，常对象和普通对象可以使用的类内函数就有一些区别。即 常对象只能使用常成员函数。在函数重载的情况下，普通对象只能使用普通成员函数，常对象只能使用常成员函数。我们举例说明一下：<br>#include &lt;iostream&gt;

class person {
	int height;
	int weight;
	int age;
public:
	person(int h, int w, int a) :height(h), weight(w), age(a) {
		std::cout &lt;&lt; "A person object has been added." &lt;&lt; std::endl;
	}
	~person() {}
	void getter() {
		std::cout &lt;&lt; "Height: " &lt;&lt; height &lt;&lt; std::endl &lt;&lt; "Weight: "
			&lt;&lt; weight &lt;&lt; std::endl &lt;&lt; "Age: " &lt;&lt; age &lt;&lt; std::endl &lt;&lt; this &lt;&lt; std::endl;
	}
	void getter()const {
		std::cout &lt;&lt; "Height: " &lt;&lt; height &lt;&lt; std::endl &lt;&lt; "Weight: "
			&lt;&lt; weight &lt;&lt; std::endl &lt;&lt; "Age: " &lt;&lt; age &lt;&lt; std::endl &lt;&lt; this &lt;&lt; std::endl;
		std::cout &lt;&lt; "this is a const func" &lt;&lt; std::endl;
	}
};

int main() {
	person Pa(160, 50, 22);
	const person Pb(175, 60, 20);
	Pa.getter();
	Pb.getter();
	return 0;
}
<br><br><br>我们用&nbsp;inline&nbsp;关键字来指定某一个函数为内联函数。我们知道，当函数被调用时，会在栈空间里生成栈帧。函数的调用和返回对应着栈帧的生成与销毁，这往往意味着开销。内联函数就是让调用函数将被调用函数看作自身的一部分（即被调用函数不需要生成栈帧，空间换时间），节省了调用其他函数时生成和销毁栈帧的时间开销。因此，内联函数往往设置为较为短小的函数，因为当函数很大时，内联会导致代码膨胀，增加指令缓存的压力，反而可能降低性能。<br>我们在使用inline关键字时需要有以下几点注意：<br>
<br>关键字必须与函数定义放在一起才能使函数成为内联，放在函数声明前不起作用。
<br>函数在类内实现时，默认是内联的。
<br>内联函数只是对编译器的一种建议，只有符合内联的情况编译器才会采纳将函数设置为内联。
<br>#include&lt;iostream&gt;

class test {
public:
	inline void print();
	void print2();
	void print3(){
		std::cout &lt;&lt; "print3" &lt;&lt; std::endl;
	}
};
void test::print() {
	std::cout &lt;&lt; "hello" &lt;&lt; std::endl;
}
inline void test::print2(){
	std::cout &lt;&lt; "print2" &lt;&lt; std::endl;
}
int main() {
	test test1;
	test1.print(); //test1.print(); 不是内联函数
	test1.print2();//test1.print2();是内联函数
	test1.print3();//是内联函数
}
<br><br>mutable可变的，这个关键字与const相对。const关键字突出的是“常”而mutable关键字突出的是“变”。我们延续上面的例子来看看mutable可以做什么：<br>#include&lt;iostream&gt;

class test {
	mutable unsigned int print_Count;
public:
	test(unsigned int Count_init) :print_Count(Count_init) {}
	inline void print()const;
};
void test::print()const {
	std::cout &lt;&lt; "hello" &lt;&lt; std::endl;
	print_Count++;
	std::cout &lt;&lt; print_Count &lt;&lt; std::endl;
}
int main() {
	test test1(20);
	test1.print();
	test1.print();
}
<br>我们看到，即使我们定义了一个常成员函数，我们依然可以因为变量是mutable修饰的而修改print_Count的值。<br>mutable关键字一般万不得已才会使用，为了提高程序设计应当避免使用mutable关键字。另外注意，mutable不能修饰静态成员变量和常成员变量。<br><br>提高代码的可读性。<br><br>delete关键字最基本的用途就是释放掉申请的堆内存，如：<br>//删去单个对象
int* ptr = new int;
delete ptr;

//删去对象数组
int* ptr = new int[10];
delete[] ptr;
<br>但在C++ 11，delete关键字可以用于disable特定函数，用于阻止某些特定操作。比如，我们就可以在类内disable复制构造函数，delete关键字也可以用于disable类外的函数。<br><br>C++提供friend关键字来声明友元函数和友元类。如：<br>#include &lt;iostream&gt;
class person;
class dog;
void gym(person&amp; p);

class person {
	int height;
	int weight;
	int age;
public:
	friend class dog;
	friend void gym(person&amp; p);
	person(int h, int w, int a) :height(h), weight(w), age(a) {
		std::cout &lt;&lt; "A person object has been added." &lt;&lt; std::endl;
	}
	~person() {}
	void getter()const {
		std::cout &lt;&lt; "Height: " &lt;&lt; height &lt;&lt; std::endl &lt;&lt; "Weight: "
			&lt;&lt; weight &lt;&lt; std::endl &lt;&lt; "Age: " &lt;&lt; age &lt;&lt; std::endl &lt;&lt; this &lt;&lt; std::endl;
	}
};
class dog {
public:
	void bark_person(person&amp; p) {
		p.age = 0;
		p.height = 0;
		p.weight = 0;
		p.getter();
	}
};
void gym(person&amp; p) {
	p.weight -= 5;
	p.getter();
}
int main() {
	person Pa(160, 50, 22);
	person Pb(175, 65, 30);
	dog D;
	D.bark_person(Pb);
	gym(Pa);
	return 0;
}
<br>我们看到，友元函数和友元类可以任意操作person类中的任意成员，无论成员是什么属性。这样会破坏类的封装性，使得类内私有成员在友元函数和友元类下一览无余，而友元函数和友元类可能只是需要访问类内的某几个私有成员。我们可以用getter来代替友元对象，但也各有利弊。有些运算符的重载必须用到友元的功能，我们下节课会介绍。<br><br><br>在C++程序设计课程中，我们就听到多C++面向对象的三大特征——封装、继承和多态。这节课，我们来简单了解一下继承。<br>我们先试想一个场景，假如我们要开发一款游戏，主人公需要使用法杖来过五关斩六将。火之杖、水之杖、冰之杖、土之杖......这么多法杖我们开发时需要如下这样做么？<br>class fire_wand{...};
class water_wand{...};
class ice_wand{...};
class earth_wand{...};
class air_wand{...};
...
<br>我们显然不会这也做，将法杖一个个枚举起来既延长了开发时长，也不利于后面的拓展。C++提供了子类对父类的继承派生，这就大大减少了我们的工作量。假如父类法杖有3个属性，加入继承后，子类只需要实现子类法杖的属性，有关父类的各种属性只需要继承就好了。代码如下：<br>class wand {
	char name[10];
	char element[10];
	unsigned int length;
};
class fire_wand :public wand {//子类fire_wand继承父类wand的所有成员变量
    unsigned char* elem_paricle;
    int particle_width;
    int particle_height;
};
...
<br>接着我们来演示一下父子类的构造和析构函数。在此之前，我们需要注意：<br>
<br>C++的继承是在创建子类成员对象前先创建父类的成员变量，也就是先调用父类的构造函数构造父类成员变量，之后再调用子类的构造函数。
<br>析构函数的调用顺序是先调用子类的析构函数，再调用父类析构函数。
<br>父类的指针是可以指向子类对象的。这在C++中也叫向上转型，这是由于子类对象包含了父类对象的所有成员。
<br>#include &lt;iostream&gt;
#include &lt;cstring&gt;
class wand {
	std::string name;
	std::string element;
	unsigned length;
public:
	wand(std::string name_, std::string element_, unsigned length_) 
	:name(name_), element(element_), length(length_) {
		std::cout &lt;&lt; "Father class constructor." &lt;&lt; std::endl;
	}
	~wand() {
		std::cout &lt;&lt; "Father class deconstrutor." &lt;&lt; std::endl;
	}
};
class fire_wand :public wand {
	unsigned char* elem_paricle;
	int particle_width;
	int particle_height;
public:
	fire_wand(std::string name_, std::string element_, unsigned length_,
		unsigned char* elem_particle_, int parti_width_, int parti_height_)
		:wand(name_, element_, length_), elem_paricle(elem_particle_),
		particle_width(parti_width_), particle_height(parti_height_) {
		std::cout &lt;&lt; "Child class constructor." &lt;&lt; std::endl;
	}
	~fire_wand() {
		std::cout &lt;&lt; "Child class deconstructor" &lt;&lt; std::endl;
	}

};
int main() {
	unsigned char parti_data[2 * 35] = { 0 };
	fire_wand fw("Blacken blast", "Fire", 20, parti_data, 2, 35);
	wand* w = &amp;fw;//父类指针指向子类对象
	return 0;
}
<br><br><br>
polymorphism — providing a single interface to entities of different types. virtual functions provide dynamic (run-time) polymorphism through an interface provided by a base class. Overloaded functions and templates provide static (compile-time) polymorphism.     
<br>多态(Polymorphism)是面向对象编程(OOP)的一个核心概念。它允许同一个接口调用不同类型的对象，并根据对象的实际类型执行相应的操作。多态性可以分为两种类型：编译时多态性（静态多态性）和运行时多态性（动态多态性）。<br><br>编译时多态性通过函数重载(Overload) 和模板实现。在编译期间，编译器根据函数的参数类型和数量来确定调用哪个函数。这种多态性在编译时就已经确定了函数调用的地址，因此称为早绑定（early binding）。<br>重载函数虽然函数名是相同的，但由于不同的参数列表（不同的参数类型和数量）使得编译器能够区分这些函数。编译器在编译时根据传递的参数类型和数量来确定调用哪个重载函数。<br><br>运行时多态性通过虚函数实现。虚函数允许子类重写(Override) 基类中的函数。当通过基类指针或引用调用虚函数时，实际调用的是子类的实现。这种多态性在运行时才确定函数调用的地址，因此称为晚绑定（late binding）。<br><br><br>虚函数实现了运行时(Run-time) 的多态性。函数的多态性就意味着父类对象可以调用子类对象中的成员函数。我们之前说过，因为子类对象包含父类的所有成员变量，所以父类对象的指针是可以指向子类对象的。这样父类的析构函数就必须是虚函数，不然就可能会造成内存泄漏。<br><br>每个有虚函数的类都会有一个虚函数表，对象其实就是指向虚函数表的指针，编译时编译器只告诉了程序会在运行时查找虚函数表的对应函数。每个类都会有自己的虚函数表，所以当父类指针引用的是子类虚函数表时，自然调用的就是子类的函数。<br><br>override&nbsp;关键字用于在子类中重写基类中的虚函数。它告诉编译器该函数是用来重写基类中的虚函数的，如果没有正确匹配基类中的虚函数，编译器会报错。这有助于避免由于拼写错误或参数不匹配而导致的意外行为。<br>我们举例说明：<br>class wand {
public:
	wand(){}
	virtual ~wand() {}
	virtual void test() {}
};
class fire_wand : public wand {
public:
	fire_wand(){}
	virtual ~fire_wand()override {}
	virtual void test()override{}//标准写法
	virtual void teste(){}//，函数名写错了，但不会报错
	virtual void teste()override{}//报错，因为父类中没有能够匹配的虚函数
};

int main() {
	return 0;
}
<br><br>由于父类中并没有申请任何堆内存，我们就将父类析构函数的提示输出给注释掉。我们让父类的test函数输出一串字符串，让子类test函数申请一段堆内存。由于父类test是虚函数，所以子类中的test函数即使不加virtual关键字，编译器也会隐式地认为这个函数是虚函数。一旦父类对象调用了子类的test函数，就会动态申请一段堆内存。所以父类的析构函数必须也是虚函数，不然会造成内存泄漏。<br>#include &lt;iostream&gt;
#include &lt;cstring&gt;

class wand {
	std::string name;
	std::string element;
	unsigned length;
public:
	wand(std::string name_, std::string element_, unsigned length_)
		:name(name_), element(element_), length(length_) {
		std::cout &lt;&lt; "Father class constructor." &lt;&lt; std::endl;
	}
	virtual ~wand() { // 虚析构函数
		//std::cout &lt;&lt; "Father class destructor." &lt;&lt; std::endl;
	}
	virtual void test() {
		std::cout &lt;&lt; "Base class" &lt;&lt; std::endl;
	}
};

class fire_wand : public wand {
	unsigned char* elem_paricle;
	int particle_width;
	int particle_height;
	fire_wand* fw_ptr = NULL;
public:
	fire_wand(std::string name_, std::string element_, unsigned length_,
		unsigned char* elem_particle_, int parti_width_, int parti_height_)
		: wand(name_, element_, length_), elem_paricle(elem_particle_),
		particle_width(parti_width_), particle_height(parti_height_) {
		std::cout &lt;&lt; "Child class constructor." &lt;&lt; std::endl;
	}
	virtual ~fire_wand()override {
		if (fw_ptr == NULL) {
			std::cout &lt;&lt; "Child class destructor" &lt;&lt; std::endl;
		}
		else {
			delete fw_ptr;
			std::cout &lt;&lt; "Heap space freed." &lt;&lt; std::endl;
		}
	}
	void test(){
		unsigned char parti_data[2 * 35] = { 0 };
		fw_ptr = new fire_wand("Blacken blast", "Fire", 20, parti_data, 2, 35);
		std::cout &lt;&lt; "Derived class" &lt;&lt; std::endl;
	}
};

int main() {
	unsigned char parti_data[2 * 35] = { 0 };
	wand* wand_ptr = new fire_wand("Blacken blast", "Fire", 20, parti_data, 2, 35);
	wand_ptr-&gt;test();
	delete wand_ptr;
	return 0;
}
<br>代码执行后结果如下：<br>Father class constructor.
Child class constructor.
Father class constructor.
Child class constructor.
Derived class
Child class destructor
Heap space freed.
<br><br>该函数为虚函数：父类指针调用的是子类的成员函数。<br>
该函数不是虚函数：父类指针调用的是父类的成员函数。<br><br><br>之前说过，如果静态变量未初始化就会载入bss.段并在程序加载时初始化为0。但是静态成员变量必须在类外进行初始化。这是因为静态成员变量属于整个类。无论创建多少个对象，静态成员变量在内存中也只有一份拷贝，存储在静态存储区中，而不在堆栈区。在类外初始化可以避免静态成员变量多次初始化，保证了静态成员变量的唯一性。（不能用构造函数初始化）<br>而且由于静态成员变量为整个类所共享的特性，所以它可以通过类名来调用，当然也能用类对象调用。创建一个静态成员变量如下所示：<br>#include &lt;iostream&gt;

class Test {
public:
	static int var;
	static const int vari = 10;//可以
};
int Test::var = 0;

int main() {
	Test t;
	std::cout &lt;&lt; Test::var &lt;&lt; std::endl;
	std::cout &lt;&lt; t.var &lt;&lt; std::endl;
	return 0;
}
<br><br>静态成员函数和静态成员变量一样，可以用类名调用Test::static_func();，同样可以用类对象调用。静态成员函数只能访问静态成员变量，由于没有this指针，所以也不能访问非静态成员变量。也由于静态的特性，使得静态成员函数不需要生成对象就可调用。<br>虽然静态成员函数和普通成员函数都可以访问静态成员变量，但是由于静态成员函数可以在不创建类对象的情况下被调用，所以多用静态成员函数调用静态成员变量。<br>代码示例：<br>#include &lt;iostream&gt;

class Test {
	static int var;
public:
	static void getter() {
		std::cout &lt;&lt; var &lt;&lt; std::endl;
	}
};
int Test::var = 0;

int main() {
	Test::getter();//没有创建实例对象。
	return 0;
}
<br><br>父类子类继承中，父类唯一的作用就是被子类继承。父类不产生任何对象，父类的虚函数实现过程也是没有意义的，唯一的作用就是为子类重写。为了不让这些无意义的代码占用内存空间，纯虚函数的语法就诞生了。<br>纯虚函数是一种特殊的虚函数，它没有实现，只提供接口。纯虚函数的语法是将函数声明为&nbsp;= 0。包含纯虚函数的类称为抽象类，不能实例化对象。抽象类的主要作用是作为其他类的基类，提供一个接口框架。<br>在法杖的例子中，我们用virtual void test() = 0;将test()函数定义成纯虚函数，这样，这条语句就不会产生任何的函数对象，编译器会忽略之。由于子类还是需要父类构造函数和析构函数，所以构造函数和析构函数不能声明成纯虚函数。<br>class wand {
	std::string name;
	std::string element;
	unsigned length;
public:
	wand(std::string name_, std::string element_, unsigned length_)
		:name(name_), element(element_), length(length_) {
		std::cout &lt;&lt; "Father class constructor." &lt;&lt; std::endl;
	}
	virtual ~wand() { // 虚析构函数
		std::cout &lt;&lt; "Father class destructor." &lt;&lt; std::endl;
	}
	virtual void test() = 0;
};
<br>
<br>纯虚函数：virtual void test() = 0;&nbsp;声明了一个纯虚函数，这意味着&nbsp;wand&nbsp;类是一个抽象类，不能实例化对象。
<br>抽象类：由于&nbsp;wand&nbsp;类包含纯虚函数，它被认为是抽象类，不能直接创建&nbsp;wand&nbsp;类的对象。

<br>在上面的例子中，由于类内包含纯虚函数test()，所以下面的语句都会是错误的。


<br>	  wand* wand_ptr = new fire_wand("Blacken blast", "Fire", 20,); 
	  wand* wand_ptr("Blacken blast", "Fire", 20);
<br>
<br>实现纯虚函数：fire_wand&nbsp;类实现了&nbsp;wand&nbsp;类中的纯虚函数&nbsp;test()，因此&nbsp;fire_wand&nbsp;类可以实例化对象。
]]></description><link>https://congzhi.wiki/c-plus-plus/part2：class-(abandoned).html</link><guid isPermaLink="false">C Plus Plus/Part2：Class (Abandoned).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 24 Feb 2025 05:20:18 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part I, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-i,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part I, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:50 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part II, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-ii,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part II, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:54 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part III, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-iii,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part III, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:57:58 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part IV, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-iv,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part IV, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:58:11 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part V, NC)]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-v,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part V, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:58:04 GMT</pubDate></item><item><title><![CDATA[Preprocessor in C++ (Part VI, NC)]]></title><description><![CDATA[ 
 <br>__line__<br>std::source_location (since C++20)]]></description><link>https://congzhi.wiki/c-plus-plus/preprocessor-in-c++-(part-vi,-nc).html</link><guid isPermaLink="false">C Plus Plus/Preprocessor in C++ (Part VI, NC).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:58:15 GMT</pubDate></item><item><title><![CDATA[Program Arguments Handling in C++]]></title><description><![CDATA[ 
 <br><br>main() 函数作为我们的程序入口，我们可以在启动程序的时候传入许多参数。偷懒的 main() 写法是这样的，但这样，你不能从外界给你的程序传入参数：<br>int main(){

	return 0;
}
<br>而如果你想在程序启动的时候传入数组参数，你可以使用如下的写法：<br>int main(int argc, char* argv[]) {

    return 0;
}
<br>如果你的程序需要特定的环境才能运行，你还可以接受 envp 参数用于访问环境变量。但请注意，这并不属于 C++ 标准：<br>int main(int argc, char* argv[], char* envp[]) {

    return 0;
}
<br>下面，我们就来逐步解释每个参数的含义。<br><br>argc 是传入参数的数量，这是隐式提供的。当程序启动时，操作系统会将传入字符串参数的数量隐式地提供给 main() 函数。假如我们将下面的程序编译并运行：<br>#include &lt;iostream&gt;
int main(int argc, char* argv[]
) {

    for (int i = 0; i &lt; argc; ++i) {
        std::cout &lt;&lt; "Argument " &lt;&lt; i &lt;&lt; ": " &lt;&lt; argv[i] &lt;&lt; std::endl;
    }
    return 0;
}
<br>./test argv1 "hello world" # use "this is one string" to pass a string
<br>提问，这里我们提供的参数数 argc 有多少个？答案是三个。观察输出结果：<br>Argument 0: ./test
Argument 1: argv[1]
Argument 2: hello world
<br><br>上面在学习 argc 的时候，我们实际上已经学到了 argv 。这是一个字符串参数列表，是这三个参数中我们唯一能够提供给程序的参数。其余的 argc 和 envp 都是操作系统隐式提供给 main() 函数的。<br><br>环境变量也是系统隐式提供的。通过获取环境变量，我们能够知道我们程序的运行环境。对于依赖某些环境才能运行的程序来说，获取环境变量可以帮助此程序动态地配置运行参数。此外，环境变量可能存储一些系统相关的信息，这对于跨平台的程序而言是极其重要的。<br>我们可以遍历打印所有的环境变量：<br>#include &lt;iostream&gt;

int main(int argc, char* argv[], char* envp[]) {
    for (int i = 0; envp[i] != nullptr; ++i) {
        std::cout &lt;&lt; "Environment Variable " &lt;&lt; i &lt;&lt; ": " &lt;&lt; envp[i] &lt;&lt; std::endl;
    }
    return 0;
}
<br>在 C++ 中，标准地获取环境变量的方式是 std::getenv 。]]></description><link>https://congzhi.wiki/c-plus-plus/program-arguments-handling-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Program Arguments Handling in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 10 Mar 2025 06:52:01 GMT</pubDate></item><item><title><![CDATA[RAII and Scope in C++]]></title><description><![CDATA[ 
 <br><br><br>在C++中，资源是程序管理的各类资源，比如内存、POSIX文件、可合并的进程和互斥锁等。我们能够通过某些表达（系统调用、库函数等）来获取(require)资源，同样，我们也能通过某些表达来释放(dispose)资源。<br>资源的正确管理十分重要，错误的资源的管理会导致资源的泄漏，比如内存的泄漏（可能导致系统崩溃）、文件句柄的泄漏（可能导致无法创建文件）、持续上锁的互斥锁（可能导致死锁）等。除此，还可能造成资源的双重释放、释放后使用等问题。<br><br>C++中，对象的生命周期是可以被定义的，对象生命的开始与结束都相应的会对应一个事件。这些事件背后的代码会在对象生命的开始与结束自动的执行对象初始化和对象消逝的代码。这些代码也被称作构造函数(constructors) 和析构函数(destructors)。<br>当我们需要创建对象时，我们通过构造函数初始化对象。而当对象需要销毁时我们则需要考虑额外的因素。对于局部变量对象而言，当期超出作用域时，就会自动地调用析构函数。而对于哪些动态分配内存的对象，使用delete或delete[]显式地释放内存时，析构函数才会被调用。<br><br>The RAII class is said to "own" the resource. It is responsible for cleaning up that resource at the appropriate time.<br><br>Resource&nbsp;acquisition&nbsp;is&nbsp;initialization（RAII），或称为&nbsp;Constructor&nbsp;Acquires,&nbsp;Destructor&nbsp;Releases (CADRe)，即构造函数获取资源，析构函数释放资源。这是最初用于C++的编程惯用法，旨在通过对象的生命周期来管理资源的获取和释放。<br>通过RAII，我们可以显式地定义相应的构造函数和析构函数，在对象生命周期的开始通过构造函数自动初始化并获取资源，并在对象超出作用域或删除对象时自动调用析构函数来释放资源，避免资源泄漏。需要显式定义的函数包括析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符，这被称为"The&nbsp;Rule&nbsp;of&nbsp;Five"。<br>标准库中大量使用RAII和The&nbsp;Rule&nbsp;of&nbsp;Five，从而达到自动释放资源的目的。通过使用标准库和RAII，我们能够尽量避免手动管理资源，从而简化代码，提高安全性和可维护性。<br><br><br>局部对象就是在栈上创建的对象。当你在栈上创建对象时，它会自动调用构造函数。这是因为栈上的对象具有自动存储期（automatic storage duration），它们的生命周期由作用域(scope) 控制。当执行到 '}' 时，就会自动调用析构函数，随之栈帧销毁、函数返回。<br>#include &lt;iostream&gt;

class scope
{
public:
	scope(){
		std::cout &lt;&lt; "scope constructor" &lt;&lt; std::endl;
	}
	~scope(){
		std::cout &lt;&lt; "scope deconstructor" &lt;&lt; std::endl;
	}
};
struct test
{
	test(){
		std::cout &lt;&lt; "test constructor" &lt;&lt; std::endl;
	}
	~test(){
		std::cout &lt;&lt; "test deconstructor" &lt;&lt; std::endl;
	}
};

int main(){

	scope s;
	test t;
	return 0;
} // &lt;- End of scope
<br>du@DVM:~/Desktop/Cpp$ ./scope 
scope constructor
test constructor
test deconstructor
scope deconstructor
<br><br>由于堆上对象的生命周期通常比栈上对象的生命周期更长，因此堆上对象的构造和析构通常与&nbsp;new&nbsp;和&nbsp;delete&nbsp;关键字的使用相关联。当你使用&nbsp;new&nbsp;关键字创建一个新的对象时，会调用该对象的构造函数；而当你使用&nbsp;delete&nbsp;关键字销毁对象时，会自动调用该对象的析构函数。<br><br>malloc 和 free 函数改变为 new 和 delete 关键字的使用是从C语言过渡到C++内存管理方式的改进。虽然 new 和 delete 关键字在底层还是会调用 malloc 和 free，但是使用 new 和 delete 会调用对象的构造函数和析构函数，这是 malloc 和 free 所不具有的。<br>也就是说，new和delete提供RAII这种机制。这也是 new、delete 和 malloc、free 的最主要的差别。以下展示 new 和 delete的底层实现：<br>#include &lt;iostream&gt;
#include &lt;cstdlib&gt; // for malloc and free

void* operator new(size_t size) {
    void* ptr = std::malloc(size);
    if (!ptr) {
        throw std::bad_alloc();
    }
    return ptr;
}

void operator delete(void* ptr) noexcept {
    std::free(ptr);
}

class Entity {
public:
    Entity() {
        std::cout &lt;&lt; "Entity created" &lt;&lt; std::endl;
    }
    ~Entity() {
        std::cout &lt;&lt; "Entity destroyed" &lt;&lt; std::endl;
    }
};

int main() {
    Entity* e = new Entity();
    delete e;
    return 0;
}
<br><br>
<br>智能指针：C++11 引入了&nbsp;std::unique_ptr&nbsp;和&nbsp;std::shared_ptr&nbsp;智能指针。它们在构造时获取动态内存，在析构时自动释放内存。
<br>互斥锁：在多线程编程中，std::lock_guard&nbsp;和&nbsp;std::unique_lock&nbsp;利用 RAII 管理互斥锁的获取和释放。
<br>文件操作：C++ 标准库中的&nbsp;std::ifstream&nbsp;和&nbsp;std::ofstream&nbsp;也使用 RAII 来管理文件的打开和关闭。
<br><br>当我们想要申请堆内存资源时，我们会用 new 和 delete 关键字来申请和释放我们的内存资源。这两者总是成对出现，即当我们使用 new ，就不要忘记使用 delete。但是智能指针为我们提供了省去使用 delete 的便利。<br>智能指针有三种：<br>
<br>Unique pointers：是最简单的智能指针。unique_ptr可以看作一种作用域指针(scoped pointer)，在超出作用域时会自动销毁所管理的对象。（RAII）
<br>Shared pointer：引用计数，多个shared_ptr可以共享同一个对象。当引用数为0，自动释放堆内存资源。（RAII）
<br>Weak pointer：不增加引用计数，解决shared_ptr之间循环引用的问题。辅助 shared_ptr 防止循环计数导致的内存资源泄漏。
<br>智能指针实际上就是对裸指针的封装，实际上两个关键字仍然成对出现。其中规定 unique_ptr 所指向的堆对象只能有一个引用，不可以拷贝，也就是为什么叫做 unique pointer。例如：<br>std::unique_ptr&lt;Entity&gt; entity0 = std::make_unique&lt;Entity&gt;();
auto entity1 = entity0; // error
<br>unique_ptr 还提供异常安全性（exception safety）。也就是说它能够在异常发生时确保资源的正确释放，避免资源泄漏。具体来说，unique_ptr&nbsp;通过 RAII机制管理动态分配的内存，确保在对象生命周期结束时自动释放内存。<br>#include &lt;iostream&gt;
#include &lt;memory&gt;

class Entity
{
public:
	Entity(){
		std::cout &lt;&lt; "Entity created" &lt;&lt; std::endl;
	}
	~Entity(){
		std::cout &lt;&lt; "Entity destroyed" &lt;&lt; std::endl;
	}
	
};

template&lt;class T&gt;
class scopedPointer
{
private:
	T* m_ptr;
public:
	scopedPointer(const T* other_ptr) = delete;
	scopedPointer(T* other_ptr) = delete;
	scopedPointer&amp; operator=(const scopedPointer&amp; other) = delete;
	scopedPointer(T* ptr)
		: m_ptr(ptr)
	{
	}
	~scopedPointer(){
		delete m_ptr;
	}
    scopedPointer&amp; operator=(scopedPointer&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            delete m_ptr;
            m_ptr = other.m_ptr;
            other.m_ptr = nullptr;
        }
        return *this;
	}
};
int main(){
	{
		scopedPointer* s_ptr = new Entity();

	}//&lt;--s_ptr销毁的时刻
	{
		std::unique_ptr&lt;Entity&gt; entity(new Enity()); 
		std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();
	}
	std::cin.get();
	return 0;
}
<br>Copyable? NO! Movable? YES! 由于unique_ptr可移动不可拷贝，所以我们应当删去拷贝构造函数和对拷贝赋值运算符的重载。]]></description><link>https://congzhi.wiki/c-plus-plus/raii-and-scope-in-c++.html</link><guid isPermaLink="false">C Plus Plus/RAII and Scope in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 05 Mar 2025 16:39:54 GMT</pubDate></item><item><title><![CDATA[Smart Pointers in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="RAII and Scope in C++" href="https://congzhi.wiki/c-plus-plus/raii-and-scope-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">RAII and Scope in C++</a><br><br>在C++中，我们使用 new 和 delete/delete[] 在堆上实例化和删除对象。当你使用裸指针时，同一个作用域中的 new 和 delete 的数量总是需要匹配的，不然就可能引起内存泄漏。在使用裸指针删除对象时，你还需要注意类型的匹配（single-object form using delete, array using delete[]），不然就可能引起未定义行为。<br>尽管裸指针的使用强大且高效，但是人为地管理这些资源的释放是容不得一点粗心的。C++的标准库（C++11/C++14标准）中，我们有四种类型的智能指针，分别是：<br>
<br>auto_ptr<br>
C++98:&nbsp;初次引入。<br>
C++11:&nbsp;被标记为过时（Deprecated）。<br>
C++17:&nbsp;被移除。
<br>unique_ptr<br>
C++11:&nbsp;引入作为&nbsp;auto_ptr&nbsp;的替代品，独占所有权的智能指针。<br>
C++14:&nbsp;添加了&nbsp;make_unique&nbsp;工厂函数。
<br>shared_ptr<br>
C++11:&nbsp;引入引用计数智能指针，伴随&nbsp;make_shared&lt;T&gt;&nbsp;的使用。<br>
C++20:&nbsp;添加了对&nbsp;make_shared&lt;T[]&gt;&nbsp;的支持。
<br>weak_ptr<br>
C++11:&nbsp;引入“弱”引用智能指针，用于解决循环引用问题。
<br>这些智能指针通过对裸指针的包装，使得我们可以放心地申请资源而不担心发生任何的资源泄漏。这些智能指针会管理动态申请对象的生命周期，并在合适的适合销毁对象（包括异常事件）。<br>C++程序的编写目标就是去除所有的 raw pointer, raw new and raw delete。所以我们会用工厂函数来创建自己需要的智能指针。<br><br>当我们有使用智能指针的需求时，std::unique_ptr该是我们第一个想到的。作为一种scoped pointer，如我们在 <a data-href="RAII and Scope in C++" href="https://congzhi.wiki/c-plus-plus/raii-and-scope-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">RAII and Scope in C++</a> 中展示的一样，std::unique_ptr的大小和裸指针的大小是一样的。当你使用std::unique_ptr时，所使用的指令和使用裸指针的指令是一样的。<br><img alt="Pasted image 20241023154500.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023154500.png"><br><br>std::unique_ptr&nbsp;提供独占所有权的特性，也就是说在任何时候，std::unique_ptr&nbsp;都能保证只能有一个指针拥有资源。因此我们不能进行复制/拷贝操作，只能实现移动操作。试想，如果我们对&nbsp;std::unique_ptr&nbsp;进行了复制，就会有两个拥有对象所有权的指针，这与其的设计初衷相悖。当&nbsp;std::unique_ptr&nbsp;移动时，所有权转移，原来的指针会丢失对资源的所有权（nullptr），从而保持独占所有权的特性。<br><img alt="Pasted image 20241023153930.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023153930.png"><br>std::unique_ptr移动的操作示例：<br>#include &lt;memory&gt;
// Create a unique pointer using make_unique factory function.
std::unique_ptr&lt;Entity&gt; uptr1 = std::make_unique&lt;Entity&gt;();
// or `std::unique_ptr&lt;Entity&gt; uptr1 = std::unique_ptr&lt;Entity&gt;(new Entity);`

// Change ownership to uptr2.
std::unique_ptr&lt;Entity&gt; uptr2 = std::move(upre1);
<br><br>当你需要一个指向数组的&nbsp;unique&nbsp;pointer&nbsp;时，我们就要用到&nbsp;std::unique_ptr&lt;T[]&gt;。这种智能指针在析构时会调用&nbsp;delete[]，以正确释放数组内存。<br><img alt="Pasted image 20241023154839.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023154839.png"><br><br>除了模板参数T之外，std::unique_ptr也一直有第二个模板参数，我们称之为Deleter，即删除器。删除器的作用是什么呢？智能指针难道不应该接管一切么？智能指针让我们免于资源泄漏，但是我们需要删除器来释放这些资源。通过智能指针管理非常见的资源（非堆上资源）时，我们就需要定义一个自己的删除器。<br><img alt="Pasted image 20241023155605.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023155605.png"><br>如果不定义任何的Deleter，unique_ptr就会使用默认的删除器std::default_delete。默认的删除器负责对堆上动态资源进行释放。<br>template&lt;class T, class Deleter = std::default_delete&lt;T&gt;&gt;
class unique_ptr {
    T *p_ = nullptr;
    Deleter d_;
public:
    explicit unique_ptr(T* p = nullptr, Deleter d = Deleter()) : p_(p), d_(d) {}
    ~unique_ptr() {
        if (p_) d_(p_);
    }
    // Copy is not allowed.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    // Object is movable.
    unique_ptr(unique_ptr&amp;&amp; other) noexcept : p_(other.p_), d_(std::move(other.d_)) {
        other.p_ = nullptr;
    }
    unique_ptr&amp; operator=(unique_ptr&amp;&amp; other) noexcept {
        if (this != &amp;other) {
            if (p_) d_(p_);
            p_ = other.p_;
            d_ = std::move(other.d_);
            other.p_ = nullptr;
        }
        return *this;
    }
    T* get() const { return p_; }
    T* release() { T* tmp = p_; p_ = nullptr; return tmp; }
    void reset(T* p = nullptr) {
        if (p_ != p) {
            if (p_) d_(p_);
            p_ = p;
        }
    }
};
template&lt;class T&gt;
struct default_delete {
    void operator()(T *p) const { delete p; }
};
<br>如果我们想在作用域内释放内存，我们可以使用reset()方法提前释放内存。<br><br>文件句柄、网络连接、设备句柄等这些资源可能并不是在堆上分配的，我们并不能用delete删除这些资源。Deleter的作用就显现出来了，对那些不能delete的资源进行管理。智能指针可以通过自定义删除器来正确释放它们。假设我们有一个数据库连接：<br>struct DBConnection{
// All kinds of resources.
// All kinds of methods.
};
struct DBDeleter{
	void operator()(DBConnection* db){
		std::cout &lt;&lt; "Closing Database Connection.\n";
		dbClosing(db);
	}
};
class DBManager{
	std::unique_ptr&lt;DBConnection, DBDeleter&gt; dbConnect_;
public:
	explicit DBManager(DBConnection* dbConnect) : dbConnect_(dbConnect){}
	void query(const std::string&amp; q){
		if(dbConnect_){
			db_query(dbConnection_.get(), q.c_str());
		}
	}
	void close(){
		dbConnection_.reset();
	}
};

int main(){
	DBConnection* db = dbOpen("example.db");
	DBManager dbManager(db);
	dbManager.query("SELECT * FROM Student");
	// dbManager.close(); // &lt;-Close the database now.
	return 0;
} // &lt;- Close the database by using DBDeleter.
<br><br>std::shared_ptr&nbsp;是最接近裸指针的智能指针。不同于上一节中的&nbsp;std::unique_ptr，使用&nbsp;std::shared_ptr&nbsp;创建的对象的所有权是由所有指向该对象的&nbsp;std::shared_ptr&nbsp;共享的。只有当最后一个&nbsp;std::shared_ptr&nbsp;停止指向对象时，对象的资源才会被释放。<br><br>std::shared_ptr&nbsp;的这种&nbsp;共享&nbsp;特性是通过&nbsp;引用计数&nbsp;来实现的。通过引用计数，shared_ptr 就能知道当前有多少个指针在共享资源。这种对对象资源的控制使得&nbsp;std::shared_ptr&nbsp;需要额外的控制块来管理对象资源的释放。那么控制块放到哪里？<br>控制块通常会放在堆上，与对象一起分配。这样做的好处是确保控制块的生命周期与对象的生命周期一致。当所有指向对象的&nbsp;shared_ptr&nbsp;被销毁时（并且这时如果weak ref count = 0），控制块也会被自动释放。如果控制块放在栈上，当函数返回或栈帧被销毁时，控制块就会被销毁，而不管是否还有&nbsp;shared_ptr&nbsp;指向对象。这将导致引用计数失效，可能在某些情况下导致对象被提前销毁，或者造成资源泄漏。<br>因而，std::make_shared工厂函数总会创建一个控制块，并且 std::shared_ptr的大小是裸指针大小的两倍大（一个指针指向对象，一个指针指向控制块）。而且控制块的内存必须在堆上动态分配。当std::unique_ptr转换为std::shared_ptr时，构造函数也是会生成相应的控制块。<br><img alt="Pasted image 20241024004507.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241024004507.png"><br>
要实现引用计数，我们在构造函数中加入reference_count++;，并在拷贝操作时做同样的事情来增加引用计数。并且要在引用计数为0时释放掉对象资源。在对引用计数（弱引用计数同）进行操作时，由于++、--是read-modify-write操作指令，所以对引用计数的操作必须是原子性的。<br>下面我们对std::shared_ptr进行拷贝时，我们拷贝了ptr to T和ptr to control block，并使得引用计数增加1。但当我们进行移动操作时，我们不需要对引用计数进行操作，这是因为所有权转移了。<br><img alt="Pasted image 20241024005717.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241024005717.png"><br><br>我们已经有一个指向对象的指针了，为什么控制块中还有指向执行对象的指针？假设我有这几个类<br>struct Fruit { int juice; }; 
struct Vegetable { int fiber; }; 
struct Tomato : Fruit, Vegetable { int sauce; };
<br>当我创建了：<br>std::shared_ptr&lt;Tomato&gt; tomato = make_shared&lt;Tomato&gt;;
std::shared_ptr&lt;Fruit&gt; fruit = tomato;
std::shared_ptr&lt;Vegetable&gt; fruit = tomato;
<br>当我们创建一个指向&nbsp;Tomato&nbsp;实例的&nbsp;std::shared_ptr&lt;Fruit&gt;&nbsp;或&nbsp;std::shared_ptr&lt;Vegetable&gt;，这些指针会指向&nbsp;Tomato&nbsp;对象内的&nbsp;Fruit&nbsp;或&nbsp;Vegetable&nbsp;部分。由于控制块仍然是共享的，它们最终管理的是同一个&nbsp;Tomato&nbsp;实例，所以控制块会指向这个完整的对象。<br><br>和&nbsp;std::unique_ptr&nbsp;一样，std::shared_ptr&nbsp;也使用&nbsp;delete&nbsp;作为其默认的资源销毁机制（Resource-destruction&nbsp;mechanism）。但是不同的是，每个&nbsp;std::unique_ptr&nbsp;独立持有对所指对象的控制权，而&nbsp;std::shared_ptr&nbsp;的控制权是共享的。对象资源的控制由控制块来完成。<br><img alt="Pasted image 20241024015023.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241024015023.png"><br>这种由于控制权的不同，就使得std::unique_ptr本身有权力来管理对象。所以std::unique_ptr中，deleter是智能指针的一部分。<br>struct CustomDeleter {
    void operator()(int* p) const {
        delete p;
    }
};
// Deleter type is part of the smart pointer.
std::unique_ptr&lt;int, CustomDeleter&gt; p1(new int); 
<br>而std::shared_ptr不同，没有指针真正拥有对象的ownership，ownership由控制块管理管理。因此，在std::shared_ptr中，deleter并不作为智能指针的一部分。而控制块又只有一个，所以即使我们有两个std::shared_ptr，只要指向资源相同，Deleter就是相同的：<br>struct CustomDeleter {
    void operator()(int* p) const {
        delete p;
    }
};
// Deleter is not part of the smart pointer.
std::shared_ptr&lt;int&gt; p(new int, CustomDeleter()); 
std::shared_ptr&lt;int&gt; p2 = p; 
<br><br>当我们用工厂函数创建好std::shared_ptr了之后，我们在堆上会存在两块空间，我们可以将这两块空间合并起来，以避免外部碎片的产生。大多数的库都支持下面这种实现方式。<br><img alt="Pasted image 20241024145414.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241024145414.png"><br>由于我们的控制块和对象资源在同一块内存块中，我们甚至能够将控制块中的指针优化掉。<br><img alt="Pasted image 20241024145703.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241024145703.png"><br><br>在shared_ptr中，我们用ref count来控制对象的生命周期。然而，当两或多个shared_ptr相互持有对方的shared_ptr时，就可能发生循环引用，导致引用计数永远不会降到0，从而导致内存泄漏。为了避免循环引用的情况，我们可以使用weak_ptr，它不会增加引用计数，允许对象正常销毁。<br>prevent dangling pointer<br>循环XX<br><img alt="Pasted image 20241214224127.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241214224127.png"><br>shared_ptr共享controlled object，因此其指向对象的生命周期由shared_ptr所控制。而weak_ptr之间共享控制块。当对象已经被销毁，如果这时weak ref count为0，控制块就会被销毁。<br><img alt="Pasted image 20241214224219.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241214224219.png"><br><br>weak_ptr 的内存结构和 shared_ptr 是相同的。在学习shared_ptr时，我们实际上并没有用到weak reference，而这个结构的存在和控制块的生命周期是息息相关的。weak_ptr并不和shared_ptr一样共享其指向的对象，也就是说，你并不能解引用一个weak_ptr，你必须用lock()方法先将其转换成一个shared_ptr，这个方法是线程安全的。<br>#include &lt;iostream&gt;
#include &lt;memory&gt;

struct test {
    int a = 10;
};

int main() {
    std::shared_ptr&lt;test&gt; t1 = std::make_shared&lt;test&gt;();
    std::weak_ptr&lt;test&gt; t2 = t1;

    if (auto t2_shared = t2.lock()) {
        std::cout &lt;&lt; t1-&gt;a &lt;&lt; " " &lt;&lt; t2_shared-&gt;a &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "t2 is expired" &lt;&lt; std::endl;
    }
    return 0;
}
<br><br>CRTP]]></description><link>https://congzhi.wiki/c-plus-plus/smart-pointers-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Smart Pointers in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 24 Mar 2025 12:40:56 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023154500.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241023154500.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Standard Array Basics (ENG)]]></title><description><![CDATA[ 
 <br>This note is not about std::array at the first place. We are going to talk about the C-style array.<br><br>Array is a homogeneous data structure where you store all items of same kind together. The data is stored in a contiguous block of memory (Virtual Memory in particular). In programming languages, you could often see something like int id[100];, which basically means an array named id that can store 100 integers. <br>This type of data structure offers many advantages. It is easy to use, simple to index, and changes are quite straightforward. Moreover, if you are familiar with the memory layout of the operating system, you would notice that arrays allow for efficient memory usage and provide fast access to elements due to their contiguous memory allocation. (Caching and buffering)<br>When you want to index an element, you basically indicate the offset of the element, which starts at [0]. If you want to iterate through the entire id array, you can do it like this:<br>#include &lt;iostream&gt;

int main(){
	int id[100]; // Assuming the array is already initialized
	for(int i = 0; i &lt; 100; i++){
		std::cout &lt;&lt; id[i];
	}
}
<br>But with the help of standard library, it could be like this, we would talk this later:<br>#include &lt;iostream&gt;
#include &lt;array&gt;

int main() {
    std::array&lt;int, 100&gt; id; // Assuming the array is already initialized
    for(const int&amp; element : id) {
        std::cout &lt;&lt; element &lt;&lt; std::endl;
    }
    return 0;
}
<br>This also be called range-based for loop, we will also cover this later on.<br><br>C++ standard library provides a wealth of algorithms to use. We could use this function iota help us initialize our array with sequential values starting from a specified value. Below is a example of how you can do about this: <br>#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;iterator&gt; 

int main() {
    int ids[100];
    std::iota(std::begin(ids), std::end(ids), 0);
    for(int i = 0; i &lt; 100; i++) {
        std::cout &lt;&lt; ids[i] &lt;&lt; std::endl;
    }
    return 0;
}
<br>Because this iterates the array, you may should include the &lt;iterator&gt; for a good practice.<br>Everything looks good so far, but there is one limitation: the size of an array is fixed, and you cannot resize it. In the example above, we have ids[100];, which is a raw array. The array size is decided only at compile time only, you cannot change this at runtime, this 100 element size is all you can get.<br>If you try to index an element beyond the size limit of an array, you will likely encounter an error. So, what if you want an array with a bigger range? What machine can really do for you is allocate another new piece of memory, copy the data to it, and then free the current array. And we have so called dynamic array std::vector is actually following this pattern internally, managing memory allocation and resizing automatically for you.<br><br>The standard array is still a fixed-size array provided by the C++ Standard Library (STL). It offers the same semantics as a struct type holding a C-style array T[N] as its only non-static data member, but it doesn't decay to T* automatically.<br>template&lt;  
    class T,  
    std::size_t N  
&gt; struct array;
<br>Standard array can be initialized like this:<br>std::array&lt;int, 3&gt; a = {1, 2, 3};
<br>And alone with this data type, STL provides tons of member functions you can use. Now you can access the element using at function with a bound checking.<br>#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;iterator&gt; // because &lt;array&gt; library covered the &lt;iterator&gt;, you dont really need this explicitly...
#include &lt;array&gt;

int main() {
    std::array&lt;int, 100&gt; ids = {};
    std::iota(std::begin(ids), std::end(ids), 0);
    // std::iota(ids.begin(), ids.end(), 0);
    ids.at(1) = 5; // ok
    ids.at(1000) = 0; //You will get a error instead of a segmentation fault.
    for(int i = 0; i &lt; 100; i++) {
        std::cout &lt;&lt; ids[i] &lt;&lt; std::endl;
    }
    return 0;
}
/*
You can also use std::fill() to initialize your array with a specific value.
#include &lt;algorithm&gt;
	std::fill(ids.begin(), ids.end(), 0); // Fill every element in array ids to 0
*/
<br><br>#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;iterator&gt; 
#include &lt;array&gt;

int main() {
    std::array&lt;int, 100&gt; ids = {};
    std::iota(std::begin(ids), std::end(ids), 0);
    ids.at(1) = 5; // ok
    ids.at(1000) = 0; //You will get a error instead of a segmentation fault.
    for(int element: ids) {
        std::cout &lt;&lt; elememt &lt;&lt; std::endl;
    }
    for(auto element: ids){
	    std::cout &lt;&lt; element &lt;&lt; std::endl;
    }
    return 0;
}
<br><br>We talk about Big-Oh in computer science. We know that array operations have different time complexities based on the type of operation being performed. When we traverse an array, we have a time complexity of O(n). On the other hand, tree structures, for example, searching for an element in a balanced binary search tree has a time complexity of O(log n).<br>It looks like trees are somehow better for certain traversals than arrays. However, on modern machines, we have something called cache. In this case, arrays can be quicker when the size n is not excessively large. Due to arrays' contiguous memory layout, they can benefit from spatial locality, which means more cache hits. Tree structures, on the other hand, may experience a lot of cache misses due to their non-contiguous layout.]]></description><link>https://congzhi.wiki/c-plus-plus/standard-array-basics-(eng).html</link><guid isPermaLink="false">C Plus Plus/Standard Array Basics (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 19 Mar 2025 15:49:41 GMT</pubDate></item><item><title><![CDATA[Standard Variant in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Unions in C++" href="https://congzhi.wiki/c-plus-plus/unions-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Unions in C++</a><br><br>在联合体的小节中，我们谈到由于联合体的特性，每次只能有一个成员处于 active 的活跃状态，而其他的成员会处于 inactive 的非活跃状态（也就是未定义状态）。这就导致了我们对这些未定义数据成员的访问都算是未定义行为。而大多数的编译器并不会阻止我们对这些非活跃成员的访问。<br>而 std::variant 是一个对 union 的封装，它不允许用户访问那些可能引起未定义行为的非活跃成员。它提供 std::get() 的接口给用户来访问某个类型或索引的值。当用户访问到非活跃的成员时，就会抛出一个异常。我们用下面这个例子说明一下：<br>#include &lt;iostream&gt;
#include &lt;variant&gt;

int main() {
    std::variant&lt;short, int, float, double&gt; U;
    
    U = 7; // assigns 7, which is interpreted as int
    std::cout &lt;&lt; std::get&lt;short&gt;(U) &lt;&lt; std::endl; // not okay, U currently holds int, throw std::bad_variant_access type exception
    std::cout &lt;&lt; std::get&lt;int&gt;(U) &lt;&lt; std::endl; // okay
    
	U = 7.5; // assigns 7.5, which is interpreted as double
	std::cout &lt;&lt; std::get&lt;double&gt;(U) &lt;&lt; std::endl; // okay
	std::cout &lt;&lt; std::get&lt;float&gt;(U) &lt;&lt; std::endl; // not okay
    return 0;
}
<br>此外，我们还可以通过 std::get_if() 来获取 std::variant 中存储的值（指针）。和上面的 std::get() 不同的是， std::get_if() 并不会抛出异常，如果类型不匹配或者提供的索引是无效的，它会返回一个 nullptr。如果类型是匹配的，就会返回指向存储值的指针。<br>std::variant&lt;short, int&gt; U = 42;
if (int* pval = std::get_if&lt;int&gt;(&amp;U)) {
    std::cout &lt;&lt; "Value: " &lt;&lt; *pval &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Type mismatch or invalid access." &lt;&lt; std::endl;
}
<br><br>为了实现类型安全， std::variant 额外用一个 4 字节的 index 值来存储当前处于活跃状态成员变量的索引值。这也就是为什么当你用 sizeof() 查看大小时，你会发现 std::variant 类型往往比相同结构的 union 大四个字节。<br>std::variant 实际上就相当于：<br>namespace std {
    template&lt;typename... Types&gt;
    class variant {
    private:
        union Storage {
            std::aligned_union_t&lt;0, Types...&gt; data; // aligned storage for the largest type
        } storage;
        int type_index; // keeps track of the current active type
    public:
        // Constructors, destructors, assignment operators, and member functions would be implemented here
        // Example accessor function
        int index() const {
            return type_index;
        }
    };
}
<br>每个值都能够对应着一个 union 里面的类型，通过当前保存的 index 值，std::variant 就能够知道哪个数据成员是活跃的，从而保证了类型安全。我们用 index() 函数来获取当前活跃类型的索引值。<br>#include &lt;iostream&gt;
#include &lt;variant&gt;

int main() {
    std::variant&lt;short, int, float, double&gt; U;
    
    U = static_cast&lt;short&gt;(7); // assigns to short type, which index is 0
    std::cout &lt;&lt; U.index() &lt;&lt; std::endl; // 0
    
    U = static_cast&lt;int&gt;(7); //  assigns to short type, which index is 0 1
    std::cout &lt;&lt; U.index() &lt;&lt; std::endl; // 1
    
	U = static_cast&lt;float&gt;(7.5); //  assigns to float type, which index is 2
    std::cout &lt;&lt; U.index() &lt;&lt; std::endl; // 2
    
	U = static_cast&lt;double&gt;(7.5); //  assigns to double type, which index is 3
    std::cout &lt;&lt; U.index() &lt;&lt; std::endl; // 3
    
    return 0;
}
<br>既然索引对应着唯一的类型，我们实际上也可以直接用 index 值对数据成员进行访问。同样的，如果访问的索引并不是活跃成员的索引，也会抛出一个异常。如：<br>#include &lt;iostream&gt;
#include &lt;variant&gt;

int main() {
    std::variant&lt;short, int, float, double&gt; U = 7; // int type, index = 1
    std::cout &lt;&lt; std::get&lt;1&gt;(U) &lt;&lt; std::endl; // 7
    std::cout &lt;&lt; std::get&lt;0&gt;(U) &lt;&lt; std::endl; // throw std::bad_variant_access
    return 0;
}
<br><br>当抛出异常时，我们可以对其进行捕获并处理。<br>#include &lt;iostream&gt;
#include &lt;variant&gt;

int main(){
	std::variant&lt;short, int&gt; U = 7; // int type, index = 1
    try {
        std::cout &lt;&lt; std::get&lt;short&gt;(U) &lt;&lt; std::endl;
	} catch (const std::bad_variant_access&amp; ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
    }
    return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/standard-variant-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Standard Variant in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 03 Mar 2025 14:49:24 GMT</pubDate></item><item><title><![CDATA[Static Dispatch in C++ (ENG)]]></title><description><![CDATA[ 
 <br>Static Dispatch has nothing to do with <a data-href="Static Keyword in C++" href="https://congzhi.wiki/c-plus-plus/static-keyword-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Static Keyword in C++</a>.<br><br>Static dispatch, or you might be more familiar with the term "static polymorphism." In C++, static polymorphism is achieved using templates and function overloading. It allows polymorphism in compile-time, meaning the function to be called is determined at compile time. To make that happen, there has to be some way to distinguish overloaded functions.<br>What static polymorphism does is make the parameter a part of the function signature. In the following example, although we call the function print twice, because the parameter type is different, we actually call different functions:<br>// Achieve static polymorphism with function overloading:

#include &lt;iostream&gt;

void print(int x) {
    std::cout &lt;&lt; "Called print(int): " &lt;&lt; x &lt;&lt; std::endl; // _Z5printi
}

void print(double x) {
    std::cout &lt;&lt; "Called print(double): " &lt;&lt; x &lt;&lt; std::endl; // _Z5printd
}

int main() {
    print(4);   // Calls print(int)
    print(4.5); // Calls print(double)
    return 0;
}
<br>This demonstrates how static polymorphism allows the compiler to determine the correct function to call based on the parameter types at compile time, ensuring efficient and type-safe code.<br>In C, static polymorphism is not allowed because the name mangling is different between C and C++. In C, the function name generated by the compiler is unique and does not include any parameter information. As a result, function overloading is not supported:<br>void print(int x){} // The compiler generates the symbol _print
void print(double x){} // Error: void print(int x) already exists
<br>This is why you often see extern "C" used when incorporating a C library into a C++ project. It tells the C++ compiler to disable name mangling for the specified code, ensuring the function names remain compatible with the naming conventions in C.<br><br>Static polymorphism is always achieved using templates, allowing you to write generic code that works with any type. The template will help you generate the actual function code at compile time. In the code below, we only define one single function template, and the compiler will generate print&lt;int&gt;(int) and print&lt;double&gt;(double) for us automatically, which allows you to write flexible and reusable code.<br>// Achieve static polymorphism with templates:

#include &lt;iostream&gt;

template &lt;typename T&gt;
void print(T t) {
    std::cout &lt;&lt; "Called print: " &lt;&lt; t &lt;&lt; std::endl;
}

int main() {
    print(4);   // Calls print&lt;int&gt;(int)
    print(4.5); // Calls print&lt;double&gt;(double)
    return 0;
}
<br>This concept can also be applied to class member function overloading:<br>#include &lt;iostream&gt;

template &lt;typename T&gt;
void show(T t) {
    t.show(); // Static dispatch
}

class Base {
public:
    void show() const {
        std::cout &lt;&lt; "Base class show" &lt;&lt; std::endl;
    }
};

class Derived {
public:
    void show() const {
        std::cout &lt;&lt; "Derived class show" &lt;&lt; std::endl;
    }
};

int main() {
    Base b;
    Derived d;
    show(b); // Calls Base::show
    show(d); // Calls Derived::show
    return 0;
}
<br>Now, you're welcomed here: <a data-href="Operator Overloading in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/operator-overloading-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Operator Overloading in C++ (ENG)</a>]]></description><link>https://congzhi.wiki/c-plus-plus/static-dispatch-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Static Dispatch in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Mar 2025 17:01:36 GMT</pubDate></item><item><title><![CDATA[Static Keyword in C++]]></title><description><![CDATA[ 
 <br><br>当变量或者函数被声明为 static 后，我们就称其为静态变量/函数。那么静态代表了什么？在进程的虚拟内存空间里，我们看到，当变量被声明为 static 后，它会被放在数据段（初始化非 0 ）或 BSS 段（初始化为 0 /未初始化）中。这意味着静态变量的生命周期会一直持续到程序结束。也被称作 static storage duration 。<br>#include &lt;iostream&gt;

int global_var; // Un-initialized, will be placed in the BSS segment
static int static_var; // Un-initialized, also placed in the BSS segment

static void static_func() {
    global_var++;
    static_var++;
}

// Non-static function accessible from other translation units
// Increments static_var
void func() {
    static_var++;
}

int main() {
    int local_var; // Un-initialized local variable, will be placed on the stack

    std::cout &lt;&lt; global_var &lt;&lt; std::endl
              &lt;&lt; static_var &lt;&lt; std::endl;
    return 0;
}
<br>那静态函数有什么用呢？这就不得不提到 static 的另一个特性：内部链接性。<br><br>我们说被声明为 static 的静态函数和变量具有内部链接性，什么意思呢？就是说我们定义的静态变量/函数只在定义它们的翻译单元（translation unit）内可见。一个翻译单元是由一个源文件及其直接或间接包含的所有头文件组成。编译器会独立编译每个翻译单元，最后链接器会将这些编译好的翻译单元合并成一个可执行程序。<br>我们用一个例子说明：<br>// main.cpp
#include &lt;iostream&gt;
#include "static_unit.hpp"

int main() {
    // static_unit_func(); // ld error, no function definition
    static_func(); // Calls static_func() defined in static_unit.hpp
    func(); // Calls func() which is defined in static_unit.cpp
    return 0;
}
<br>// static_unit.hpp
extern int global_var; // Declares that global_var is defined in another translation unit.

static int static_var; // Declaration

// Function declarations
static void static_unit_func();
static void static_func();
void func();

static void static_func(){ // No naming conflict, no linker error
	global_var += 10;
	static_var += 10;
	std::cout &lt;&lt; "global_var shared by all the tranlation unit : " &lt;&lt; global_var &lt;&lt; std::endl
              &lt;&lt; "static_var specific owning by main.cpp       : " &lt;&lt; static_var &lt;&lt; std::endl;
}
<br>在这个例子中， main.cpp 和 static_unit.hpp 是一个翻译单元。 #include 预编译指令的作用就是把被 included 的文件全部复制到源文件中。这里的 static_unit.hpp 作为 static_unit.cpp 的接口。包含一些变量和函数的声明，在编译的时候提醒编译器我们有这个变量/函数。<br>static_unit.cpp 是另外一个翻译单元。待会当你运行程序后，你会发现静态变量/函数只能在相同的翻译单元中被使用。<br>// static_unit.cpp
#include &lt;iostream&gt;
// #include "static_unit.cpp" // Be commented

int global_var; // Uninitialized, will be placed in the BSS segment.
static int static_var = 0; // Definition

static void static_unit_func(){ // A static_unit.cpp specific function
}

static void static_func() {
    global_var++;
    static_var++;
}

// Non-static function accessible from other translation units. (An interface)
// Increments both global_var and static_var.
void func() {
    global_var++;
    static_var++;
    std::cout &lt;&lt; "global_var shared by all the tranlation unit : " &lt;&lt; global_var &lt;&lt; std::endl
              &lt;&lt; "static_var specific owning by static_unit.cpp: " &lt;&lt; static_var &lt;&lt; std::endl;
}
<br>运行上面的代码，你会发现尽管我们在不同的翻译单元内同时定义了一个 static_func() 函数，但链接时并没有引发任何的命名冲突。而且每个翻译单元中的静态变量只能由翻译单元内的函数进行访问。不难发现，内部链接性能够规避不同单元之间的命名冲突，确保变量或函数在其他翻译单元中不可见。<br>运行结果如下：<br>global_var shared by all the tranlation unit : 10
static_var specific owning by main.cpp       : 10
global_var shared by all the tranlation unit : 11
static_var specific owning by static_unit.cpp: 1
<br><br>在类中，我们还有静态成员变量和静态成员函数。和前面我们了解到的 static 语义不同，在类中，static 关键字用于声明这些成员并不受类实例的约束。换言之，静态成员变量/函数是被所有实例所共享的。<br>比如，我们有下面的例子：<br>// example.hpp

class Example{
public:
	static int s_var;
	static int get_s_var();
	Example();
	~Example();
};
<br>// main.cpp
#include &lt;iostream&gt;
#include "example.hpp"
int main(){
	Example e1;
	Example e2;
	{
		Example e3;
		Example e4;
		std::cout &lt;&lt; "We now have " &lt;&lt; Example::get_s_var() &lt;&lt; " instance." &lt;&lt; std::endl;
	}
	std::cout &lt;&lt; "We now have " &lt;&lt; Example::get_s_var() &lt;&lt; " instance." &lt;&lt; std::endl;
	std::cout &lt;&lt; "I can read the static data member: " &lt;&lt; Example::s_var &lt;&lt; std::endl;
}
<br>// example.cpp
#include "example.hpp"

int Example::s_var = 0;
int Example::get_s_var(){
	return s_var; // Equals return Example::s_var;
}
Example::Example(){
	s_var++;
}
Example::~Example(){
	s_var--;
}
<br>输出结果：<br>We now have 4 instance.
We now have 2 instance.
<br>我们发现，即使类成员变量/函数的定义在 example.cpp 这个文件域(file scope)中，和 main.cpp 是独立的翻译单元，但是我们仍然能在 main.cpp 中访问得到静态的成员变量和成员函数。也就是说，静态的成员函数和成员变量并不具有内部链接性(internal linkage)。<br><br>静态成员函数只能访问静态成员变量。因为静态成员函数没有 this 指针，所以不能访问非静态的成员变量。这是一个例子：<br>class Example{
public:
	int var;
	static int s_var;
	static int s_func();
};
int Example::s_var = 0;
int Example::s_func(){
	var++; // invalid use of member 'Example::var' in static member function
	s_var++; 
	return s_var;
}
int main(){

	return 0;
}
<br>由于 var 不是静态成员变量，所以编译会出错。<br><br>静态成员变量相当于一个带有访问属性的全局静态变量，namespace 是类的类名。和类外的静态变量一样，它们都具有 static storage duration 。静态成员变量存储在静态存储区（通常是 .data 段或 .bss 段），但它的作用域仍然是类的作用域（命名空间）。<br>因为静态成员变量是在类的所有实例之间共享的，而类的定义通常在头文件中。如果在类内部初始化静态成员变量，这样的初始化将在每个包含这个头文件的翻译单元中重复进行，从而导致链接时出现多重定义错误。<br><br>在 local scope {} 内定义的局部 static 变量的生命周期和全局 static 变量一样。但它也具有局部的访问属性，也就是说，只有在 local scope 内部才能访问到这个静态变量。<br><br>class Singleton
{
public:
	static Singleton&amp; Get
	{
		static Singleton* s_Instance = nullptr;
		return *s_Instance; 
	}
};
]]></description><link>https://congzhi.wiki/c-plus-plus/static-keyword-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Static Keyword in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sat, 15 Mar 2025 10:34:34 GMT</pubDate></item><item><title><![CDATA[STL Container - Standard Array in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Standard Array Basics (ENG)" href="https://congzhi.wiki/c-plus-plus/standard-array-basics-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Standard Array Basics (ENG)</a><br>at有bound checking<br>
[] 没有bound checking]]></description><link>https://congzhi.wiki/c-plus-plus/stl-container-standard-array-in-c++.html</link><guid isPermaLink="false">C Plus Plus/STL Container - Standard Array in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 19 Mar 2025 15:55:59 GMT</pubDate></item><item><title><![CDATA[STL Container - Standard Span Since C++20]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/stl-container-standard-span-since-c++20.html</link><guid isPermaLink="false">C Plus Plus/STL Container - Standard Span Since C++20.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 19 Mar 2025 16:04:29 GMT</pubDate></item><item><title><![CDATA[STL Container - Standard Vector in C++]]></title><description><![CDATA[ 
 ]]></description><link>https://congzhi.wiki/c-plus-plus/stl-container-standard-vector-in-c++.html</link><guid isPermaLink="false">C Plus Plus/STL Container - Standard Vector in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Wed, 19 Mar 2025 16:08:13 GMT</pubDate></item><item><title><![CDATA[STL in C++ (Pre-Part)]]></title><description><![CDATA[ 
 <br><br>STL，全称标准模板库（Standard Template Library），是 C++ 中最为重要的部件之一，也是 C++ 如此强大的一大因素。STL 的架构思想主要由 Alexander Stepanov 所创建，他也是最早提出泛型编程概念的人之一。<br>C++ STL 最早由 Alexander Stepanov 在 1992 年向 ANSI/ISO C++ 标准委员会提交，并在 1994 年被正式采纳，最终在 C++98 标准中成为 C++ 标准库的一部分。自此，STL 经过多次改进和扩展，并在 C++11 和后续版本中增加了更多功能和优化（移动语义等）。<br><br>STL 提供了四大部件：算法、容器、函数和迭代器。并且这四大部件彼此分离，使得 STL 的可扩展性非常好，你可以实现自己的容器或迭代器等来匹配标准模板库中的其他部件。<br>STL 容器包括泛型的序列容器和关联容器。容器是存储数据的对象，通过模板，你可以用 STL 容器存储任何内置类型或是用户自定义类型。常见的容器有：<br>
<br><a data-tooltip-position="top" aria-label="STL Container - Standard Array in C++" data-href="STL Container - Standard Array in C++" href="https://congzhi.wiki/c-plus-plus/stl-container-standard-array-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">std::array</a>
<br><a data-tooltip-position="top" aria-label="STL Container - Standard Vector in C++" data-href="STL Container - Standard Vector in C++" href="https://congzhi.wiki/c-plus-plus/stl-container-standard-vector-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">std::vector</a>
<br>std::deque: A double-ended queue providing fast insertion and deletion at both ends.
<br>std::list: A doubly circular linked list that allows bidirectional traversal.
<br>std::forward_list :A singly forward linked list that supports only forward traversal.
<br>std::set: An ordered container that stores unique elements and uses a balanced binary search tree.
<br>std::map: An ordered container that stores key-value pairs with unique keys, using a balanced binary search tree.
<br>std::unordered_map
<br>std::unordered_set
<br>迭代器是 STL 中访问容器的方式。迭代器是对裸指针的封装，相当于指向当前位置的指针。与裸指针相比，迭代器通常包含边界检查(bound checking)、统一性和可扩展性。不同的迭代器还会提供不同访问容器的语义。在 STL 中，我们有五种类型的迭代器：<br>
<br>输入迭代器：只能读
<br>输出迭代器：只能写
<br>前向迭代器：可读可写，向前移动
<br>双向迭代器：可读可写，双向移动
<br>随机访问迭代器
<br>算法提供了对容器进行操作的方法。这些算法是通用的，可以与任何容器和迭代器配合使用。常见的算法有：<br>
<br>std::sort
<br>std::find
<br>std::accumulate
<br>std::copy
<br>std::transform
<br>std::for_each
<br>函数对象是可以像函数一样使用的对象。它们通常用于算法中来提供灵活的操作。常见的函数对象有：<br>
<br>std::less
<br>std::greater
<br>std::plus
<br>std::minus
]]></description><link>https://congzhi.wiki/c-plus-plus/stl-in-c++-(pre-part).html</link><guid isPermaLink="false">C Plus Plus/STL in C++ (Pre-Part).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 23 Mar 2025 09:29:00 GMT</pubDate></item><item><title><![CDATA[String Library in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Character Literal &amp; String Literal in C++" href="https://congzhi.wiki/c-plus-plus/character-literal-&amp;-string-literal-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Character Literal &amp; String Literal in C++</a><br><br>template&lt;
    class CharType,  
    class Traits = std::char_traits&lt;CharType&gt;,  
    class Allocator = std::allocator&lt;CharType&gt;  
&gt; class basic_string;
<br><br>实际上，字符串 string 就是关于不同字符的数组。在 C++ 中，我们有 std::array 的标准库容器，我们还需要 std::basic_string 干嘛？主要是字符串用得太广泛了，许多语言也都有专门的字符串库，甚至在 C++ reference 上，字符串库也被单独罗列了出来。 std::basic_string 是个特别的容器，它只和字符打交道，而且提供许多专门处理字符串的方法。<br>对于不同的字符，我们使用不同的 string 类。我们最常见的 string 类是 std::string，但实际上 std::string 只处理 char 类型的字符串。要想让字符串显示更多的信息，我们还有其他的类如 std::wstring 和 std::u32string 等。而这些不同的 string 类实际上就是：<br>typedef std::basic_string&lt;char&gt; std::string;
typedef std::basic_string&lt;char8_t&gt; std::u8string; // Since C++20
typedef std::basic_string&lt;wchar_t&gt; std::wstring;
typedef std::basic_string&lt;char16_t&gt; std::u16string;
typedef std::basic_string&lt;char32_t&gt; std::u32string;
<br>不同的 string 类中只是字符类型不同，它们的操作都是一样的。我们下面以 std::string 为例来进行讲解。<br><br>上面，我们看到 std::string 实际上就是 std::basic_string&lt;char&gt;。在这小节，我们将依托 std::basic_string&lt;char&gt; 学习 std::basic_string 库中的一些成员函数。<br>std::string 并不仅仅包括字符串数据，它还存储了字符串数据长度和字符串数组容量的信息。这些信息用于支持简便好用的库成员函数能够发挥作用。<br>举个例子，在下面的代码中，我们用了一个一个字符串字面量 hello, world!\n （ const char*, 即一个 C 类型字符串）来初始化一个 std::string 类型的变量。这里，我们先是输出了变量 s 的地址，后面再用 s.data() 选择输出字符串所在的地址。你会发现它们输出的地址并不会相同。<br>#include &lt;iostream&gt;
#include &lt;string&gt;

int main(){
	std::string s = "hello, world!\n";
	std::cout &lt;&lt; &amp;s &lt;&lt; std::endl;
	std::cout &lt;&lt; (void*)s.data() &lt;&lt; std::endl;
	return 0;
}
<br><br>namespace pmr {  
template&lt;  
    class CharType,  
    class Traits = std::char_traits&lt;ChatType&gt;
&gt; using basic_string =  
    std::basic_string&lt;CharT, Traits, std::pmr::polymorphic_allocator&lt;CharType&gt;&gt;;
}
<br>待补充......<br><br>按值传递：拷贝发送<br>按引用传递+const:避免了拷贝的发生同时避免了修改<br>但如果原值是一个 const char*呢<br>void allocPrint(std::string&amp; str){ // A string allocation on heap is made

}
void noAllocPrint(std::string_view&amp; str){ // No heap allocation is made

}
int main(){
	const str* = "hello, world!";
	printStr(str);
	noAllocPrint(str);
}
<br>实现仅为一个CharType指针和string大小]]></description><link>https://congzhi.wiki/c-plus-plus/string-library-in-c++.html</link><guid isPermaLink="false">C Plus Plus/String Library in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Mar 2025 17:04:40 GMT</pubDate></item><item><title><![CDATA[The pIMPL Idiom in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>In many code design patterns, people make all the declarations in the hpp file and definitions in the cpp file. This is called separating the interface and the implementation. Here’s an example:<br>// myLib.hpp
#ifndef MYLIB_HPP
#define MYLIB_HPP

class myLib {
private:
    int num;
public:
    myLib(int n); // Constructor taking an int parameter
    ~myLib() = default; // Destructor doing nothing
    int add(int n); // Method taking an int parameter
    int sub(int n); // Method taking an int parameter
};
#endif

// myLib.cpp
#include "myLib.hpp"

myLib::myLib(int n) : num{n} {}
int myLib::add(int n) {
    num += n;
    return num;
}
int myLib::sub(int n) {
    num -= n;
    return num;
}
<br>After compilation, the user will not see any implementation details of the library, that is, our cpp file. This approach has several benefits, such as encapsulation and ease of use. But, sometimes it is better not to expose any interface details about the implementation. In such cases, we can introduce the pimpl idiom.<br><br>We will demonstrate how our last code example above applies the pimpl idiom. With the pimpl idiom, the example above will look like:<br>// myLib.hpp

#ifndef MYLIB_HPP
#define MYLIB_HPP

class myLibImpl; // Forward declaration of the implementation class

class myLib {
private:
    myLibImpl* pImpl; // Pointer to the implementation class
public:
	void operation(int n);
    myLib(int n); // Constructor taking an int parameter
    ~myLib();
    int add(int n);
    int sub(int n);
// Rule of five...
};
#endif

// myLib.cpp
#include "myLib.hpp"
#include &lt;iostream&gt;

// Implementation of the myLibImpl class
class myLibImpl {
public:
    int num;
    myLibImpl(int n) : num{n} {}

    int add(int n) {
        num += n;
        return num;
    }
    int sub(int n) {
        num -= n;
        return num;
    }
    void operation(int n) {
        std::cout &lt;&lt; "Operation with value: " &lt;&lt; n &lt;&lt; std::endl;
    }
};

// Constructor
myLib::myLib(int n) : pImpl{new myLibImpl(n)} {}
// Destructor
myLib::~myLib() {
    delete pImpl;
}
// Operation method
void myLib::operation(int n) {
    pImpl-&gt;operation(n);
}

// Rule of five implementations...
<br>We see, everything about the implementation is in one translation unit, and what we have in myLib.hpp is really an interface to myLibImpl.<br>You can see the code is now safer to use, but one level of indirection is added, which may impact performance.<br><br>I am not done with the pIMPL design pattern.]]></description><link>https://congzhi.wiki/c-plus-plus/the-pimpl-idiom-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/The pIMPL Idiom in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 03 Mar 2025 16:23:35 GMT</pubDate></item><item><title><![CDATA[The Rule of Five in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Move Semantics in C++" href="https://congzhi.wiki/c-plus-plus/move-semantics-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Move Semantics in C++</a><br><br>假设我们有这样一个类，类内只有一个 std::string 类型的成员变量和一个负责打印的成员函数。我们将他们的访问权限都变为 public，这样，我们就可以对类内的成员变量进行赋值操作了。这时，我们对类内成员变量的构造简单而直接。如下：<br>#include &lt;iostream&gt;
#include &lt;string&gt;

class Name{
public:
	std::string m_name;
	void printName(){
		std::cout &lt;&lt; m_name &lt;&lt; std::endl;
	}
};

int main(){
	Name alice;
    alice.m_name = "Alice";
    alice.printName();
	return 0;
}
<br>但为了保证类内数据的封装性，我们一般将成员变量的访问权限设置为 private。这个时候我们就不能对这些变量直接进行操作了，现在的规则是：“你只能通过类内一些特殊的函数初始化类内私有的成员变量”。在面向对象程序设计中，我们将这些特殊的函数称为构造函数。同时，我们还有一种特殊的函数叫析构函数，它会在对象的生命周期结束后自动调用用于清理对象（见<a data-tooltip-position="top" aria-label="RAII and Scope in C++" data-href="RAII and Scope in C++" href="https://congzhi.wiki/c-plus-plus/raii-and-scope-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">RAII</a>）。<br><br>在将成员变量设为私有后，我们需要一些特殊的函数来初始化和清理这些变量。构造函数会在类实例化对象时自动调用，用于初始化成员变量。而析构函数则会在对象的生命周期结束时自动调用，用于清理资源。通常而言，我们加入 const 是为了避免对原对象的修改。<br>#include &lt;iostream&gt;
#include &lt;string&gt;

class Name {
private:
    std::string m_name{"NO NAME"};
public:
    Name() = default;

    // Constructor that accepts std::string
    Name(const std::string&amp; name) : m_name(name) {}
    void printName() const {
        std::cout &lt;&lt; m_name &lt;&lt; std::endl;
    }
};

int main() {
    Name alice("Alice");
    Name alice2(alice); // compiler provided for free
    Name alice3 = alice;// compiler provided for free
    alice.printName();
    alice2.printName();
    alice3.printName();
    return 0;
}
<br>上面，我们添加了一个接受 std::string 类型的构造函数。但在下面的例子中，我们发现虽然我们没有显式添加接受 Name 类类型的拷贝构造函数和拷贝赋值运算符，但它们仍然能够正常工作。这是因为编译器为我们自动生成了默认的拷贝构造函数和赋值运算符。<br>    // Default copy constructor, copy assignment operator provided by compiler.
    Name(const Name&amp; other_name) : m_name(other_name.m_name){}
    Name&amp; operator=(const Name&amp; other_name) : m_name(other_name.m_name){}
<br>这些默认的拷贝构造函数和赋值运算符会逐个成员地复制对象中的每个成员，这种拷贝被称为浅拷贝。在含有成员指针的类中，这种浅拷贝可能会造成资源的二次释放。详见<a data-tooltip-position="top" aria-label="Copying and Copy Constructors in C++ > 2. Shallow Copying and Deep Copying" data-href="Copying and Copy Constructors in C++#2. Shallow Copying and Deep Copying" href="https://congzhi.wiki/c-plus-plus/copying-and-copy-constructors-in-c++.html#2._Shallow_Copying_and_Deep_Copying" class="internal-link" target="_self" rel="noopener nofollow">浅拷贝和深拷贝</a>。<br><br>在 C++11 前，C++ 没有移动语义的概念。因此，那时我们不需要考虑移动构造函数和移动赋值运算符。如果你要实现一个类，那你就应当实现所有的三个重要函数和一个析构函数，即构造函数、析构函数、拷贝构造函数和拷贝赋值运算符。这就是“三法则”（A best practice）。<br>如果类内资源不涉及内存分配，实际上你可以依赖编译器为你提供的默认的构造函数和赋值运算符重载。简化了类的设计和实现，这种原则叫做 the rule of zero 。<br>You may be curious about why we always pass an object by reference in C++, even in the copy constructor. You might know this is to avoid copying the object. While it's true that we need to copy the object in the copy constructor, the way we achieve this is different.<br>We use a reference to avoid creating a new copy of the object on the stack of the current function. By passing a reference (or a pointer) to the existing object, the function can operate directly on the original object without the overhead of making a copy. This method ensures that we're not creating unnecessary copies, which can be expensive in terms of CPU time and memory usage.<br>If you're still feeling confused, you're welcome to learn more <a data-tooltip-position="top" aria-label="Call Stack in C++ (ENG)" data-href="Call Stack in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/call-stack-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">here</a>.<br><br><br>自 C++11 引入移动语义之后，一个类可以通过移动构造函数和重写移动赋值运算符来构造对象。"The Rule of Five" 或 “五法则” 是 C++11 后定义构造函数的指导原则。五法则规定要实现一个类，你不仅需要实现三法则（即定义析构函数、拷贝构造函数和拷贝赋值运算符），还需要在类中添加移动构造函数和移动赋值运算符，以支持移动语义。<br><br>Rule of Zero旨在简化类的设计和实现。它的核心思想是：如果一个类不需要自定义的析构函数、拷贝构造函数、拷贝赋值运算符、移动构造函数或移动赋值运算符，那么就不应该定义这些函数。相反，应该信任并依赖编译器生成的默认实现。<br>#include &lt;string&gt;
#include &lt;memory&gt;

class Widget {
private:
    int i{0};
    std::string s{};
    std::unique_ptr&lt;int&gt; pi{nullptr};

public:
    Widget() = default;
    ~Widget() = default;
    Widget(const Widget&amp;) = default;
    Widget&amp; operator=(const Widget&amp;) = default;
    Widget(Widget&amp;&amp;) = default;
    Widget&amp; operator=(Widget&amp;&amp;) = default;
};
]]></description><link>https://congzhi.wiki/c-plus-plus/the-rule-of-five-in-c++.html</link><guid isPermaLink="false">C Plus Plus/The Rule of Five in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:58:53 GMT</pubDate></item><item><title><![CDATA[This Keyword in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>If you're a C++ newbie, the this keyword in a class can definitely be confusing, and you might find yourself asking, "What the heck is this?"<br>According to <a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/cpp/language/this" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/cpp/language/this" target="_blank">cppreference</a>, the this expression is a pure rvalue expression, which represents the address value of the implicit object parameter. Simply put, you can consider this as a pointer points to the current instance of the object.<br>When you use this in a member function, it allows you to refer to the calling object itself. In this example down below, the this pointer inside the showAddr function points to the object obj. The this expression provides a way for member functions to refer to the instance of the class they were called on.<br>class MyClass {
public:
    void showAddr() {
        std::cout &lt;&lt; "Address of this object: " &lt;&lt; this &lt;&lt; std::endl;
    }
};

int main() {
    MyClass obj;
    obj.showAddr(); // Will print the address of the object `obj`
    return 0;
}

<br><br>You can see this in every implicit object member function body, including member initializer list and lambda expression body (you can capture this within a capture list).<br>class MyClass {
public:
	// implicit member function getValue()
    int getValue() const { // const member function
        return value; // implicit form of return this-&gt;value;
    }
private:
	int value;
};
<br>In any practice, explicitly using this is often considered a good practice for clarity. Consider a scenario where you have passed a parameter with the exact same name as a class member variable. In the function setValue, the use of this helps to avoid ambiguity.<br>#include &lt;iostream&gt;

class MyClass {
public:
    int getValue() const { // const member function
        return this-&gt;value;
    }
    void setValue(int value) {
        value = value; // parameter value will shadow the member with the same name
    }
private:
    int value = 50;
};

int main(){
    MyClass obj;
    obj.setValue(20);
    std::cout &lt;&lt; obj.getValue() &lt;&lt; std::endl; // print 50
    return 0;
}
<br><br>In the <a data-href="Const in C++" href="https://congzhi.wiki/c-plus-plus/const-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Const in C++</a> section, we talked about constant member functions in C++. const member functions are not allowed to mutate the member variables of the class. So what is happening under the hood? Let's imagine we have a class as follows:<br>class MyClass {
public:
    int getValue() const { // const member function
        return this-&gt;value;
    }
    void setValue(int value) {
        this-&gt;value = value;
    }
private:
    int value;
};
<br>What really happens is a implicit casting, as we will examine this process:<br>int getValue() const {
	return value;
}
// is the same as:
int getValue(const myClass* const this){
	return this-&gt;value;
	}
<br>Because this casting is implicit, the const is put on the outside of () to indicate that the member function cannot modify the object it is called on. Preserving the const-correctness of the function.<br><br>Because "this" was introduced into C++ before references were added.]]></description><link>https://congzhi.wiki/c-plus-plus/this-keyword-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/This Keyword in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 27 Feb 2025 14:19:56 GMT</pubDate></item><item><title><![CDATA[Typename Keyword in C++ (ENG)]]></title><description><![CDATA[ 
 <br><br>The typename keyword in C++ is used to introduce type template parameters and template template parameters (since C++17). It serves as an alternative to the class keyword in this context.<br>template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
// The code above is as the same as:
template &lt;class T&gt;
T add(T a, T b) {
    return a + b;
}
<br>In both cases, T is a type parameter that will be replaced by the actual data type when you call the function.<br><br>The typename keyword is also used to indicate that a dependent name(often means a class name) is a type. This helps the compiler understand that the name refers to a type, preventing ambiguity. This is particularly useful in templates where the type depends on a template parameter.<br>#include &lt;iostream&gt;

// Example of a class with a nested type
class Example {
public:
    using value_type = int; // Define 'Example::value_type' as 'int'
};
class Example2 {
public:
    using value_type = double; // Define 'Example2::value_type' as 'double'
};

template &lt;typename T&gt;
class MyClass {
    typename T::value_type member; // 'typename' tells the compiler that 'value_type' is a type inside 'T'
public:
    void setMember(typename T::value_type value) {
        member = value;
    }
    typename T::value_type getMember() const {
        return member;
    }
};

int main() {
    MyClass&lt;Example&gt; myObj; // 'Example' has 'value_type' defined as 'int'
    MyClass&lt;Example2&gt; myobj2; // 'Example2' has 'value_type' defined as 'double'
    return 0;
}
]]></description><link>https://congzhi.wiki/c-plus-plus/typename-keyword-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Typename Keyword in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Fri, 28 Feb 2025 04:38:03 GMT</pubDate></item><item><title><![CDATA[Unions in C++]]></title><description><![CDATA[ 
 <br><br>在 C++ 中，大多数人可能都知道 class 和 struct 的类类型，但是许多人会忽略 union 也是一种类类型，这是因为 C++ 中的联合体也可以拥有自己的成员函数（包括构造和析构函数）。但它的使用是特别的，因为其特性，联合体类 union 内每次只能有一个活跃的成员。<br>由于联合体需要保证类内任何一个成员都能够被访问到，所以联合体类型至少要和类内最大的数据成员的大小一样大，通常等于联合体类内最大的数据成员的大小。当我们访问联合体类时，其类内的每个数据成员都会像是类内唯一的数据成员。<br>union 的一个简单用例如下，我们用 union 定义了一个联合体类型 U。其中有三个数据成员：<br>#include &lt;iostream&gt;

union U{ // public access by default
	int u_i; // 4 bytes
	short u_s; // 2 bytes, hold integer number no bigger than 65535
	float u_f; // 4 bytes
}; // thus the size of U class is 4 bytes 

int main(){
	U u = {65536}; // initializes the first member u.u_i
	// U u.u_i = {65536};
	std::cout &lt;&lt; u_i &lt;&lt; std::endl 
			  &lt;&lt; u_s &lt;&lt; std::endl 
			  &lt;&lt; u_f &lt;&lt; std::endl;
	return 0;
}
<br>输出：<br>65536
0
9.18355e-41
<br>上面的代码中，我们定义了一个包含三个数据成员的 union 类。在 union 中，所有的数据变量都共享一个地址，但是它们访问数据的方式和大小各不相同。我们初始化了第一个成员 u_i，这意味着剩下的两个变量的状态在此时是未定义的。这也就不难理解为什么我们会得到如此奇怪的输出。<br>在一时刻， union 的内存布局如下所示：<br>
<img alt="member_union.png" src="https://congzhi.wiki/c-plus-plus/pics/member_union.png"><br>
因为 short 类型大小为两个字节，所以即使 short 和 int 都表示整型数，在赋值 65536 时，short 仍然不能访问高二字节地址的数据。而 float 数据的访问方式又与整型数有所不同，我们会得到不一样的结果。如果后面我们对 u_s 进行赋值，那么 u_i 的生命周期也就随之结束。<br>以上是联合体最常用的方式。这样做有什么好处？节省内存。<br><br>作为一种特殊的类， union 可以拥有自己的成员函数。但需要注意的是 union 不允许继承和派生，因此也不允许出现虚函数。union 中，拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符和析构函数默认会被删除。除非显式地定义这些函数。<br><br>匿名联合体是匿名的，它不能有任何成员函数、静态数据成员而且所有的数据成员都需要是公有的。匿名联合体必须定义在作用域 (scope) 中，而且其成员不能与作用域中已声明的名字冲突。接着上面的例子，它的匿名联合体会是这样的：<br>#include &lt;iostream&gt;
namespace U {
    long u_l;
    union { // public access by default
        int u_i; // 4 bytes
        short u_s; // 2 bytes, holds integer numbers no bigger than 65535
        float u_f; // 4 bytes
	    // long u_l; // not allowed
    } static; // anonymous unions at namespace scope must be static
}

int main() {
    U::u_i = 65536; // initializes the first member myspace::u_i
    std::cout &lt;&lt; U::u_i &lt;&lt; std::endl 
              &lt;&lt; U::u_s &lt;&lt; std::endl 
              &lt;&lt; U::u_f &lt;&lt; std::endl;
    return 0;
}
<br>如果在一个函数的作用域中，匿名函数就是这样的：<br>#include &lt;iostream&gt;

int main() {
	union { // public access by default
        int u_i; // 4 bytes
        short u_s; // 2 bytes, holds integer numbers no bigger than 65535
        float u_f; // 4 bytes
    };
    u_i = 65536; // initializes u_i
    std::cout &lt;&lt; u_i &lt;&lt; std::endl 
              &lt;&lt; u_s &lt;&lt; std::endl 
              &lt;&lt; u_f &lt;&lt; std::endl;
    return 0;
}
<br>]]></description><link>https://congzhi.wiki/c-plus-plus/unions-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Unions in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Thu, 20 Feb 2025 21:59:04 GMT</pubDate><enclosure url="https://congzhi.wiki/c-plus-plus/pics/member_union.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/c-plus-plus/pics/member_union.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Using Keyword in C++ (ENG)]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Namespaces in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/namespaces-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">Namespaces in C++ (ENG)</a><br><br>We will add some details about what happens behind the scenes in this section. Before that, make sure you have completed the <a data-tooltip-position="top" aria-label="Namespaces in C++ (ENG)" data-href="Namespaces in C++ (ENG)" href="https://congzhi.wiki/c-plus-plus/namespaces-in-c++-(eng).html" class="internal-link" target="_self" rel="noopener nofollow">namespace</a> part.<br>We use the using declaration to introduce namespace members into other namespaces and block scopes. Global functions and variables can also be introduced into other namespaces using using declarations. This might sound dizzying, but no hard to understand.<br>Without further ado, let's dive into some code:<br>#include &lt;iostream&gt;

void func(); // Global function declaration
int var; // Global variable
void func(){ // Global function difinition
    std::cout &lt;&lt; "In global func." &lt;&lt; std::endl;
}
namespace A {
    void A_func(); // A::A_func(), this is also global, but with a suffix name A
}
void A::A_func(){
    std::cout &lt;&lt; "In A::A_func." &lt;&lt; std::endl;
}

namespace B {
    using ::func; // Global func() is now visible as B::func
    using ::var; // Global var is now visible as B::var
    using A::A_func; // A::A_func() is now visible as B::A_func
}
int main() {

    var = 0;
    std::cout &lt;&lt; var &lt;&lt; std::endl;
    
    ::var = 10; // Modify the global variable to 10
    std::cout &lt;&lt; ::var &lt;&lt; std::endl;
    
    B::var = 20; // Okay
    std::cout &lt;&lt; ::B::var &lt;&lt; std::endl;
    
    B::func(); // Calls func() // as the same as ::func() or func()
    B::A_func(); // Calls A::A_func()
    
    return 0;
}
<br>This code demonstrates how you can introduce global variables and functions into a namespace using the using declaration. By doing this, you make global names accessible within the namespace B, allowing you to use them without fully qualifying their names.<br>And once you can do the step forward, you can do the backward. This is allowed as well:<br>namespace A {
    int var; // A::var
}
using A::var; // A::var is now available as ::var

int main() {
    ::var = 10; // This refers to A::var
    A::var = 30; // refers to A::var
    return 0;
}
<br>But when you introduce names from one namespace into another, you need to be cautious not to create ambiguities. If two namespaces have members with the same name, using declarations can lead to confusion and potential conflicts.<br><br>When you use a using declaration within a block scope, it's often referred to as a using directive within that block. Which we have seen as in using namespace blabla;.<br>This is a example from <a data-tooltip-position="top" aria-label="https://en.cppreference.com/w/cpp/language/namespace#Using-directives" rel="noopener nofollow" class="external-link" href="https://en.cppreference.com/w/cpp/language/namespace#Using-directives" target="_blank">cppreference</a>:<br>namespace A
{
    int i;
}
 
namespace B
{
    int i;
    int j;
 
    namespace C
    {
        namespace D
        {
            using namespace A;
            // Names from A are "injected" into D.
            // Unqualified lookup within D considers these names to have the same
            // scope as the global scope (e.g. for the purposes of name hiding).
            // Qualified lookup referring to D (D::name for some name)
            // will find the same name as unqualified lookup within D.
 
            int j;
            int k;
            int a = i;   // i is B::i, because A::i is hidden by B::i
            int b = ::i; // error: there is still no i in the global namespace
        }
 
        using namespace D; // names from D and A are injected into C
 
        int k = 89; // OK to declare name identical to one introduced by a using
        int l = k;  // ambiguous: C::k or D::k
        int m = i;  // ok: B::i hides A::i
        int n = j;  // ok: D::j hides B::j
    }
}
 
// These are all equivalent definitions:
int t0 = B::i;
int t1 = B::C::a;
int t2 = B::C::D::a;
<br><br>You can create type aliases with the using keyword, similar to typedef.<br>using cout = std::cout;

int my_variable = 0;
using var = my_variable; 
typedef my_variable = var; // same
<br>You can also create type aliases for template classes using using. This is true beast, which typedef cannot do.<br>template&lt;class T&gt; using myClass = myOriginalClass&lt;T&gt;;

// typedef syntax is not allowed with templates:
template&lt;class T&gt; typedef myOriginalClass&lt;T&gt; myClass; // error, this is not allowed
]]></description><link>https://congzhi.wiki/c-plus-plus/using-keyword-in-c++-(eng).html</link><guid isPermaLink="false">C Plus Plus/Using Keyword in C++ (ENG).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Tue, 04 Mar 2025 14:15:22 GMT</pubDate></item><item><title><![CDATA[Virtual Dispatch in C++]]></title><description><![CDATA[ 
 <br>Do this at first: <a data-href="Inheritance in C++" href="https://congzhi.wiki/c-plus-plus/inheritance-in-c++.html" class="internal-link" target="_self" rel="noopener nofollow">Inheritance in C++</a><br><br>类里面没有数据成员时，它的大小为1字节，如果定义virtual，它的大小就会为8字节（存放虚表指针<br>之前，我们学习了继承是怎么回事，还了解了派生类对基类同名函数的隐藏机制。<br>我们用虚函数就是为了动态多态（虚多态）即决定函数执行是在运行时完成的，而不在编译时决定<br>动态多态就是用基类指针来调用派生类对象函数的<br>#include &lt;iostream&gt;
class Base {
public:
    void func() {
        std::cout &lt;&lt; "Base::func()" &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void func() {
        std::cout &lt;&lt; "Derived::func()" &lt;&lt; std::endl;
    }
    void func1(){}
};

int main() {
    Base *b = new Derived;
    b-&gt;func();
    return 0;
}
<br>是对基类函数的重写，所以在派生类定义的函数用基类指针是访问不到的<br>只用声明基类函数为virtual就可以了<br>只能和指针或引用一起使用。指针的话，对象在堆上创建<br>引用对象在栈上创建<br>
<img alt="Pasted image 20250322232054.png" src="https://congzhi.wiki/lib/media/pasted-image-20250322232054.png"><br>基类的作用是制定一些规则（派生类可以重写哪些函数）但是基类不能干涉派生类重写函数的实现<br>
纯虚函数就是告诉派生类。。。。如果派生类不实现基类的纯虚函数，派生类也会变为抽象类（不可实例化<br><br>虚函数就是允许子类对该函数进行重写(override)，引入了动态多态/运行时多态的概念。函数重写和函数重载(overload)这两个概念很容易混淆，但它们不是一个概念。<br>在<a data-href="Part2：Class (Abandoned)" href="https://congzhi.wiki/c-plus-plus/part2：class-(abandoned).html" class="internal-link" target="_self" rel="noopener nofollow">Part2：Class (Abandoned)</a>中，我们了解了当我们在制作游戏法杖类时，派生类直接继承基类能为我们带来多少的便利。但是在那个例子中，我们没有考虑如何在派生类中对基类函数重新实现。虚函数就使得我们在子类中重写(overwrite) 函数。也引入了运行时多态的概念。<br>#include &lt;iostream&gt;
#include &lt;string&gt;

class wand{
    std::string name;
    std::string element;
    unsigned length;
public:
    wand(std::string name_, std::string element_, unsigned length_)
        : name(name_), element(element_), length(length_){
        std::cout &lt;&lt; "Father class constructor." &lt;&lt; std::endl;
    }
    ~wand(){
        std::cout &lt;&lt; "Father class deconstrutor." &lt;&lt; std::endl;
    }
    virtual void printName(){
        std::cout &lt;&lt; "This is a wand." &lt;&lt; std::endl;
    }
};
class fire_wand : public wand{
public:
    fire_wand(std::string name_, std::string element_, unsigned length_)
        : wand(name_, element_, length_){
        std::cout &lt;&lt; "Child class constructor." &lt;&lt; std::endl;
    }
    ~fire_wand(){
        std::cout &lt;&lt; "Child class deconstructor" &lt;&lt; std::endl;
    }
    void printName(){
        std::cout &lt;&lt; "This is a fire wand." &lt;&lt; std::endl;
    }
    /*
    int printName(){} // Incorrect
	int printName(int i){} // Correct, but it's no longer runtime polymorphism
	*/
};
int main(){
    fire_wand fw("Blacken blast", "Fire", 20);
    wand *w = &amp;fw; 
    w-&gt;printName();
    return 0;
}
<br>在上面的例子中，我们在 fire_wand 中重写了 printName() 函数，所以在调用函数的时候实际上调用的是派生类中实现的 printName()。但如果在派生类中没有给出重写实现，那就会调用基类默认的实现。<br>需要注意的是，派生类中重写的函数必须和基类中的虚函数类型相同（函数名、参数列表、常量性）。在派生类中重写虚函数的时候可以使用 virtual 和 override 关键字。override 关键字override&nbsp;关键字用于在子类中重写基类中的虚函数。它告诉编译器该函数是用来重写基类中的虚函数的，如果没有正确匹配基类中的虚函数，编译器就会报错。<br>例如：<br>class wand {
public:
    virtual void printName() {
        std::cout &lt;&lt; "This is a wand." &lt;&lt; std::endl;
    }
};

class fire_wand : public wand {
public:
    // In this case, the compiler will check if this function correctly overrides a virtual function in the base class
     virtual void printName() override {
        std::cout &lt;&lt; "This is a fire wand." &lt;&lt; std::endl;
    }

    // This will be incorrect because there is no virtual function with this name in the base class
    virtual void printLeng() override { // Error: 'printLeng' does not override any base class method
        std::cout &lt;&lt; "Length" &lt;&lt; std::endl;
    }
};

<br>如果不想派生类再重写虚函数，我们可以使用C++提供的 final 关键字。<br>class wand{
public:
    virtual void printName() final {
        std::cout &lt;&lt; "This is a wand." &lt;&lt; std::endl;
    }
};
class fire_wand : public wand{
public:
    void printName() override { // Incorrect, cannot override 'final' function
	    std::cout &lt;&lt; "This is a fire wand." &lt;&lt; std::endl;
    }
};
<br>如果想在继承时强制在派生类中定义基类中的虚函数，我们可以用 virtual void printName() = 0;，即纯虚函数。  <br><br>
After the base class guarantees the preconditions and postconditions of an operation, any derived class must respect those guarantees. An override can ask for less and provide more, but it must never require more or promise less because that would break the contrack that was promised to calling code.
<br>interface dont do something<br>
派生类中实现了基类中没有的方法还能使用动态多态么<br>接口是可以有函数体的：(但是抽象类不能实例化)<br>class Example{
	virtual void print() = 0;
};
void Example::print(){
	std::cout &lt;&lt; "test" &lt;&lt; std::endl;
}
<br>在C++中，我们称纯虚函数为接口（interface），这是因为纯虚函数定义了一组必须由派生类实现的函数，从而为派生类提供了一种规范和约束。<br>纯虚函数是在基类中声明但没有实现的函数，声明格式为&nbsp;virtual void functionName() = 0;。接口是一种只包含未实现方法的类，用于定义一组必须由派生类实现的函数。在C++中，接口通常通过包含纯虚函数的抽象类来实现。<br>当类中声明某函数为纯虚函数时，该类即为抽象类（abstract class），不能直接实例化。虽然你仍然可以在抽象类中给出纯虚函数的实现，但由于抽象类不能实例化，这种实现通常没有实际作用。继承抽象类的派生类必须在类中实现这些接口函数，正是这种对派生类的规范，所以称为接口。<br>#include &lt;iostream&gt;
#include &lt;string&gt;

class Printable {
public:
    virtual std::string getClassName() const = 0; // pure virtual
};

class Document : public Printable {
public:
    std::string getClassName() const override {
        return "Document";
    }
};

class Book : public Document {
public:
    std::string getClassName() const override {
        return "Book";
    }
};

void printClassName(const Printable&amp; obj) {
    std::cout &lt;&lt; obj.getClassName() &lt;&lt; std::endl;
}

int main() {
    Document doc;
    Book book;

    printClassName(doc);  // Document
    printClassName(book); // Book

    return 0;
}
<br><br>纯虚函数为代码提供了许多规范性和扩展性：<br>
<br>
规范和约束：

<br>纯虚函数强制派生类实现这些函数，从而确保所有派生类都具有相同的接口。这提供了一种规范和约束，使得代码更一致和可维护。


<br>
多态性：

<br>接口允许通过基类指针或引用调用派生类的实现，从而实现多态性。这使得代码更加灵活和可扩展。


<br>
设计模式：

<br>在面向对象设计中，接口用于定义一组相关的功能，而不关心具体的实现细节。这种设计模式在大型项目中尤为重要，因为它提高了代码的可扩展性和可维护性。


<br><br>在了解虚析构函数前，我们先写一段代码并观察其输出结果，我们会看到删除指向派生类对象的基类指针时，析构函数的调用是错误的。观察并思考一下为什么会出现这种现象。<br>#include &lt;iostream&gt;

class Base
{
public:
    Base(){ std::cout &lt;&lt; "Base constructor." &lt;&lt; std::endl; }
    ~Base(){ std::cout &lt;&lt; "Base deconstructor." &lt;&lt; std::endl; }
};
class Derived : public Base
{
public:
    Derived(){ std::cout &lt;&lt; "Derived constructor." &lt;&lt; std::endl; }
    ~Derived(){ std::cout &lt;&lt; "Derived deconstructor." &lt;&lt; std::endl; }
};

int main(){

    Base* base = new Base();
    delete base;
    std::cout &lt;&lt; "---------------------\n";
    Derived* derived = new Derived();
    delete derived;
    std::cout &lt;&lt; "---------------------\n";
    Base* poly = new Derived();
    delete poly;
    return 0;
}
<br>Base constructor.
Base deconstructor.
---------------------
Base constructor.
Derived constructor.
Derived deconstructor.
Base deconstructor.
---------------------
Base constructor.
Derived constructor.
Base deconstructor.
<br>输出很奇怪，当我们删除 poly 时，我们发现虽然我们new了一个 Derived 类对象，但是删除对象的时候确没有调用基类的析构函数。为什么？你可能会得到一个一头雾水的回答：因为基类的析构函数没有被声明为虚析构函数。<br><br>当基类的析构函数声明为虚函数时，C++的虚函数机制会确保在删除一个指向派生类对象的基类指针时，调用的是派生类的析构函数。这是因为虚函数表(vtable) 会在运行时动态绑定到正确的析构函数，从而确保派生类的析构函数被调用。<br><br>虚拟函数依赖于一个完整的对象布局，而在构造函数执行时，对象还处于不完全状态。此外，虚拟函数的机制依赖于 vtable 的初始化，但在调用构造函数时， vtable 还未完全建立或指向正确的类型。这就是为什么 C++ 设计者决定不允许构造函数是 virtual 的。<br><br>当我声明 Base::~Base() 纯虚析构函数，将 Base 类实例化过程删去。运行代码，gcc 告诉我们链接出错了。为什么？undefined reference to 'Base::~Base()' 不难理解，因为链接器没有找到 Base::~Base() 的定义。gcc 还说错误是在 Derived::Derived() 和 Derived::~Derived() 对 Base::~Base() 引用时没有找到定义而造成的。<br>/usr/bin/ld: /tmp/ccXCFzYQ.o: in function `Derived::Derived()':
stack2.cpp:(.text._ZN7DerivedC2Ev[_ZN7DerivedC5Ev]+0x67): undefined reference to `Base::~Base()'
/usr/bin/ld: /tmp/ccXCFzYQ.o: in function `Derived::~Derived()':
stack2.cpp:(.text._ZN7DerivedD2Ev[_ZN7DerivedD5Ev]+0x51): undefined reference to `Base::~Base()'
collect2: error: ld returned 1 exit status
<br>理解Derived::~Derived()中有对Base::~Base()的引用并不难，为什么&nbsp;Derived::Derived()&nbsp;中有对&nbsp;Base::~Base()&nbsp;的引用？<br>在我们定义纯虚函数的时候，一般而言并不需要给出实现，因为抽象类不能实例化，还有就是派生类也必须给出其实现。纯虚函数即便实现一般也不会调用，但纯虚析构函数是一个例外，纯虚析构函数必须有一个定义。因为在删除派生类对象时，基类的析构函数仍然需要被调用。<br><br>当我们使用 virtual 关键字时，C++就会帮我们创建一个vtable。vtable会被存放到类定义模块的数据段中，而且所有相同类型的 instances 共享同一个vtable。<br>可能上面的话我们并不好理解，没关系，我们先用一个例子说明。如下，我们让将基类 Animal 定义为了一个抽象类，为其他的动物提供函数/方法接口。我们定义基类 Animal 和三个派生类，然后在 main 里面用基类指针指向 new 的派生类对象，在运行时动态调用派生类的实现。这就是动态时多态(Dynamic dispatch) 。<br>#include &lt;iostream&gt;

class Animal{
public:
    virtual void Say() {
	    std::cout &lt;&lt; "Dingggg~" &lt;&lt; std::endl;
    }
    virtual void Whoami() {
	    std::cout &lt;&lt; "I am an animal." &lt;&lt; std::endl;
	}
};
class Cat : public Animal{
    void Say() override {
        std::cout &lt;&lt; "Meowwww~" &lt;&lt; std::endl;
    }
    void Whoami() override {
	    std::cout &lt;&lt; "I am a cat." &lt;&lt; std::endl;
    }
};
class Cow : public Animal{
public:
    void Say() override {
        std::cout &lt;&lt; "Moooooo~" &lt;&lt; std::endl;
    }
};
class Pig : public Animal{
public:
    void Say() override {
        std::cout &lt;&lt; "Oinnnnk~" &lt;&lt; std::endl;
    }
};
int main(){

    Animal* animal = new Cat();
    animal-&gt;Say();
    delete animal;
    Animal* animal = new Cow();
    animal-&gt;Whoami();
    delete animal;
    return 0;
}
<br>Meowwww~
I am an animal.
<br>派生类继承基类时，如果没有重载虚函数，虚表中的指针仍然指向基类的虚函数实现。也就造成了我们所看到的 I am an animal. 。虚表(vtable) 的存在是实现动态多态性和默认基类实现的核心所在。通过虚表，可以在运行时决定调用哪个具体的函数实现，我们现在就来了解它。<br><br>上面我们观察了一些现象，我们下面就来看看虚表和我们的代码在内存中是怎么样的。关于这个话题，暂时不会过于深入，我们仅用一张图来说明一下。<br><img alt="vtable.png" src="https://congzhi.wiki/c-plus-plus/pics/vtable.png"><br>在这个例子中，每个类都有一个自己的虚表，某个类的所有实例都会共享一个虚表，当类被实例化时，实例会有一个指向其类的虚指针（指向虚表的指针）。<br>虚表中包含类的所有虚函数的指针。我们的基类&nbsp;Animal&nbsp;有两个虚函数&nbsp;Say()&nbsp;和&nbsp;Whoami()，所以&nbsp;Animal&nbsp;类的虚表中会有两个指针分别指向&nbsp;Say()&nbsp;和&nbsp;Whoami()&nbsp;的实现。对于派生类中没有重载基类的某个虚函数，那么它的虚表中会包含指向基类&nbsp;Animal&nbsp;中相应虚函数的指针。<br>从上图中能清楚地看到：<br>
<br>Cat&nbsp;类的虚表会有指向&nbsp;Cat::Say()&nbsp;和&nbsp;Cat::Whoami()&nbsp;的虚指针。
<br>Cow&nbsp;类的虚表会有指向&nbsp;Cow::Say()&nbsp;和&nbsp;Animal::Whoami()&nbsp;的虚指针。
<br>Pig&nbsp;类的虚表会有指向&nbsp;Pig::Say()&nbsp;和&nbsp;Animal::Whoami()&nbsp;的虚指针。
<br>请留意：这里并没有画栈这个内存中极其重要的一部分。在堆中的实例需要通过栈上的指针来进行寻址，完整的寻址过程如下：栈上指针&nbsp;-&gt;&nbsp;堆上实例中的虚指针&nbsp;-&gt;&nbsp;虚表中的函数指针&nbsp;-&gt;&nbsp;虚函数。这也是动态多态性较慢的原因之一。<br>虚表的建立比模板特化早。所以虚函数不允许写成模板。<br><br>
解决菱形继承的代码重复问题。
<br>Virtual&nbsp;Base&nbsp;Class：这是在多重继承中用来避免重复继承的一种机制。假设我们有一个基类A，还有两个从A继承的类B和C。如果再创建一个类D，它同时继承自B和C，那么D将拥有A的两份副本。但在某些情况下，我们只希望有A的一份副本，这时就需要使用virtual&nbsp;base&nbsp;class。<br>class A {
    // Base class A
};

class B : virtual public A {
    // B is virtually inherited from class A
};

class C : virtual public A {
    // C is also virtually inherited from class A
};

class D : public B, public C {
    // D inherited from B and C
};
<br>Virtual&nbsp;Inheritance是为了实现上面说的virtual&nbsp;base&nbsp;class机制而引入的。通过virtual&nbsp;inheritance，派生类D将只拥有基类A的一份副本，避免了重复继承的问题。这在多重继承层次结构中尤其有用。<br>
<img alt="Pasted image 20241009225008.png" src="https://congzhi.wiki/c-plus-plus/pics/pasted-image-20241009225008.png"><br>
使用虚继承后，C++会确保无论多少个派生类，它们都共享同一个虚基类实例。编译器会在派生类的vtable中添加指向虚基类的指针，确保正确访问虚基类。<br>if not using virtual keyword, B and C both will point to their owning entity <br>points to the same entity using virtual keyword<br>ambiguous<br>
odr???????<br><br><br><br>why make destructor virtual?<br><br>avoid it]]></description><link>https://congzhi.wiki/c-plus-plus/virtual-dispatch-in-c++.html</link><guid isPermaLink="false">C Plus Plus/Virtual Dispatch in C++.md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Sun, 23 Mar 2025 13:27:49 GMT</pubDate><enclosure url="https://congzhi.wiki/lib/media/pasted-image-20250322232054.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://congzhi.wiki/lib/media/pasted-image-20250322232054.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Volatile Specifier in C++ (Questioning)]]></title><description><![CDATA[ 
 <br>volatile 的作用到底是什么？我知道 volatile 声明的变量不会被编译器优化到寄存器中去。意思说用 volatile 声明的变量只能从内存中取，然后放到内存中。然后使用 volatile 会 back-off 编译器的优化。C++ 经常把 const 和 volatile 称为 cv qualifier。<br>硬件开发的程序中，经常会出现 volatile 这个修饰符，网上给出的解释是告诉编译器该变量可能会在程序外被改变，因此不应该对变量进行优化？理解不了。]]></description><link>https://congzhi.wiki/c-plus-plus/volatile-specifier-in-c++-(questioning).html</link><guid isPermaLink="false">C Plus Plus/Volatile Specifier in C++ (Questioning).md</guid><dc:creator><![CDATA[Congzhi]]></dc:creator><pubDate>Mon, 03 Mar 2025 10:34:46 GMT</pubDate></item><item><title><![CDATA[Chapter 1: Computer Networks and the Internet]]></title><description/></item></channel></rss>