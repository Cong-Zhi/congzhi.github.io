<!DOCTYPE html> <html><head>
		<title>6. Processing The Processes</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 6. Processing The Processes">
		<meta property="og:title" content="6. Processing The Processes">
		<meta property="og:description" content="Congzhi's Notes Vault - 6. Processing The Processes">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/congzhi's-os-series/6.-processing-the-processes.html">
		<meta property="og:image" content="https://congzhi.wiki/congzhi's-os-series/pics/pasted-image-20241110161041.png">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-c.mjx-c47::before { padding: 0.705em 0.785em 0.022em 0px; content: "G"; }
mjx-c.mjx-c4C::before { padding: 0.683em 0.625em 0px 0px; content: "L"; }
mjx-c.mjx-c42::before { padding: 0.683em 0.708em 0px 0px; content: "B"; }
mjx-c.mjx-c41::before { padding: 0.716em 0.75em 0px 0px; content: "A"; }
mjx-c.mjx-c43::before { padding: 0.705em 0.722em 0.021em 0px; content: "C"; }
mjx-c.mjx-c79::before { padding: 0.431em 0.528em 0.204em 0px; content: "y"; }
mjx-c.mjx-c6C::before { padding: 0.694em 0.278em 0px 0px; content: "l"; }
mjx-c.mjx-c69::before { padding: 0.669em 0.278em 0px 0px; content: "i"; }
mjx-c.mjx-c6E::before { padding: 0.442em 0.556em 0px 0px; content: "n"; }
mjx-c.mjx-c64::before { padding: 0.694em 0.556em 0.011em 0px; content: "d"; }
mjx-c.mjx-c65::before { padding: 0.448em 0.444em 0.011em 0px; content: "e"; }
mjx-c.mjx-c72::before { padding: 0.442em 0.392em 0px 0px; content: "r"; }
mjx-c.mjx-c4E::before { padding: 0.683em 0.75em 0px 0px; content: "N"; }
mjx-c.mjx-c68::before { padding: 0.694em 0.556em 0px 0px; content: "h"; }
mjx-c.mjx-c61::before { padding: 0.448em 0.5em 0.011em 0px; content: "a"; }
mjx-c.mjx-c48::before { padding: 0.683em 0.75em 0px 0px; content: "H"; }
mjx-c.mjx-c63::before { padding: 0.448em 0.444em 0.011em 0px; content: "c"; }
mjx-c.mjx-c74::before { padding: 0.615em 0.389em 0.01em 0px; content: "t"; }
mjx-c.mjx-c6F::before { padding: 0.448em 0.5em 0.01em 0px; content: "o"; }
mjx-c.mjx-c53::before { padding: 0.705em 0.556em 0.022em 0px; content: "S"; }
mjx-c.mjx-c54::before { padding: 0.677em 0.722em 0px 0px; content: "T"; }
mjx-c.mjx-c5A::before { padding: 0.683em 0.611em 0px 0px; content: "Z"; }
mjx-msup { display: inline-block; text-align: left; }
mjx-c.mjx-c38::before { padding: 0.666em 0.5em 0.022em 0px; content: "8"; }
mjx-c.mjx-c39::before { padding: 0.666em 0.5em 0.022em 0px; content: "9"; }
mjx-c.mjx-c73::before { padding: 0.448em 0.394em 0.011em 0px; content: "s"; }
mjx-c.mjx-c1D448.TEX-I::before { padding: 0.683em 0.767em 0.022em 0px; content: "U"; }
mjx-c.mjx-c37::before { padding: 0.676em 0.5em 0.022em 0px; content: "7"; }
mjx-c.mjx-c1D438.TEX-I::before { padding: 0.68em 0.764em 0px 0px; content: "E"; }
mjx-c.mjx-c1D6FC.TEX-I::before { padding: 0.442em 0.64em 0.011em 0px; content: "α"; }
mjx-c.mjx-c1D463.TEX-I::before { padding: 0.443em 0.485em 0.011em 0px; content: "v"; }
mjx-c.mjx-c1D6FD.TEX-I::before { padding: 0.705em 0.566em 0.194em 0px; content: "β"; }
mjx-c.mjx-c7C::before { padding: 0.75em 0.278em 0.249em 0px; content: "|"; }
mjx-c.mjx-c1D43C.TEX-I::before { padding: 0.683em 0.504em 0px 0px; content: "I"; }
mjx-mtext { display: inline-block; text-align: left; }
mjx-mfrac { display: inline-block; text-align: left; }
mjx-frac { display: inline-block; vertical-align: 0.17em; padding: 0px 0.22em; }
mjx-frac[type="d"] { vertical-align: 0.04em; }
mjx-frac[delims] { padding: 0px 0.1em; }
mjx-frac[atop] { padding: 0px 0.12em; }
mjx-frac[atop][delims] { padding: 0px; }
mjx-dtable { display: inline-table; width: 100%; }
mjx-dtable > * { font-size: 2000%; }
mjx-dbox { display: block; font-size: 5%; }
mjx-num { display: block; text-align: center; }
mjx-den { display: block; text-align: center; }
mjx-mfrac[bevelled] > mjx-num { display: inline-block; }
mjx-mfrac[bevelled] > mjx-den { display: inline-block; }
mjx-den[align="right"], mjx-num[align="right"] { text-align: right; }
mjx-den[align="left"], mjx-num[align="left"] { text-align: left; }
mjx-nstrut { display: inline-block; height: 0.054em; width: 0px; vertical-align: -0.054em; }
mjx-nstrut[type="d"] { height: 0.217em; vertical-align: -0.217em; }
mjx-dstrut { display: inline-block; height: 0.505em; width: 0px; }
mjx-dstrut[type="d"] { height: 0.726em; }
mjx-line { display: block; box-sizing: border-box; min-height: 1px; height: 0.06em; border-top: 0.06em solid; margin: 0.06em -0.1em; overflow: hidden; }
mjx-line[type="d"] { margin: 0.18em -0.1em; }
mjx-mrow { display: inline-block; text-align: left; }
mjx-munderover { display: inline-block; text-align: left; }
mjx-munderover:not([limits="false"]) { padding-top: 0.1em; }
mjx-munderover:not([limits="false"]) > * { display: block; }
mjx-msubsup { display: inline-block; text-align: left; }
mjx-script { display: inline-block; padding-right: 0.05em; padding-left: 0.033em; }
mjx-script > mjx-spacer { display: block; }
mjx-c.mjx-c210E.TEX-I::before { padding: 0.694em 0.576em 0.011em 0px; content: "h"; }
mjx-c.mjx-c3A::before { padding: 0.43em 0.278em 0px 0px; content: ":"; }
mjx-c.mjx-c1D464.TEX-I::before { padding: 0.443em 0.716em 0.011em 0px; content: "w"; }
mjx-c.mjx-c1D45A.TEX-I::before { padding: 0.442em 0.878em 0.011em 0px; content: "m"; }
mjx-c.mjx-c1D446.TEX-I::before { padding: 0.705em 0.645em 0.022em 0px; content: "S"; }
mjx-c.mjx-c1D454.TEX-I::before { padding: 0.442em 0.477em 0.205em 0px; content: "g"; }
mjx-c.mjx-c1D453.TEX-I::before { padding: 0.705em 0.55em 0.205em 0px; content: "f"; }
mjx-c.mjx-c1D465.TEX-I::before { padding: 0.442em 0.572em 0.011em 0px; content: "x"; }
mjx-c.mjx-c2217::before { padding: 0.465em 0.5em 0px 0px; content: "∗"; }
mjx-c.mjx-c1D447.TEX-I::before { padding: 0.677em 0.704em 0px 0px; content: "T"; }
mjx-c.mjx-cA0::before { padding: 0px 0.25em 0px 0px; content: " "; }
mjx-c.mjx-c34::before { padding: 0.677em 0.5em 0px 0px; content: "4"; }
mjx-c.mjx-c36::before { padding: 0.666em 0.5em 0.022em 0px; content: "6"; }
mjx-c.mjx-c2248::before { padding: 0.483em 0.778em 0px 0px; content: "≈"; }
mjx-c.mjx-c1D449.TEX-I::before { padding: 0.683em 0.769em 0.022em 0px; content: "V"; }
mjx-c.mjx-c1D43F.TEX-I::before { padding: 0.683em 0.681em 0px 0px; content: "L"; }
mjx-c.mjx-c1D436.TEX-I::before { padding: 0.705em 0.76em 0.022em 0px; content: "C"; }
mjx-c.mjx-c2265::before { padding: 0.636em 0.778em 0.138em 0px; content: "≥"; }
mjx-c.mjx-c7B::before { padding: 0.75em 0.5em 0.25em 0px; content: "{"; }
mjx-c.mjx-c7D::before { padding: 0.75em 0.5em 0.25em 0px; content: "}"; }
mjx-c.mjx-c1D443.TEX-I::before { padding: 0.683em 0.751em 0px 0px; content: "P"; }
mjx-c.mjx-c2211.TEX-S1::before { padding: 0.75em 1.056em 0.25em 0px; content: "∑"; }
mjx-container[jax="CHTML"] { line-height: 0; }
mjx-container [space="1"] { margin-left: 0.111em; }
mjx-container [space="2"] { margin-left: 0.167em; }
mjx-container [space="3"] { margin-left: 0.222em; }
mjx-container [space="4"] { margin-left: 0.278em; }
mjx-container [space="5"] { margin-left: 0.333em; }
mjx-container [rspace="1"] { margin-right: 0.111em; }
mjx-container [rspace="2"] { margin-right: 0.167em; }
mjx-container [rspace="3"] { margin-right: 0.222em; }
mjx-container [rspace="4"] { margin-right: 0.278em; }
mjx-container [rspace="5"] { margin-right: 0.333em; }
mjx-container [size="s"] { font-size: 70.7%; }
mjx-container [size="ss"] { font-size: 50%; }
mjx-container [size="Tn"] { font-size: 60%; }
mjx-container [size="sm"] { font-size: 85%; }
mjx-container [size="lg"] { font-size: 120%; }
mjx-container [size="Lg"] { font-size: 144%; }
mjx-container [size="LG"] { font-size: 173%; }
mjx-container [size="hg"] { font-size: 207%; }
mjx-container [size="HG"] { font-size: 249%; }
mjx-container [width="full"] { width: 100%; }
mjx-box { display: inline-block; }
mjx-block { display: block; }
mjx-itable { display: inline-table; }
mjx-row { display: table-row; }
mjx-row > * { display: table-cell; }
mjx-mtext { display: inline-block; }
mjx-mstyle { display: inline-block; }
mjx-merror { display: inline-block; color: red; background-color: yellow; }
mjx-mphantom { visibility: hidden; }
mjx-assistive-mml { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; padding: 1px 0px 0px !important; border: 0px !important; display: block !important; width: auto !important; overflow: hidden !important; }
mjx-assistive-mml[display="block"] { width: 100% !important; }
mjx-math { display: inline-block; text-align: left; line-height: 0; text-indent: 0px; font-style: normal; font-weight: normal; font-size: 100%; letter-spacing: normal; border-collapse: collapse; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; direction: ltr; padding: 1px 0px; }
mjx-container[jax="CHTML"][display="true"] { display: block; text-align: center; margin: 1em 0px; }
mjx-container[jax="CHTML"][display="true"][width="full"] { display: flex; }
mjx-container[jax="CHTML"][display="true"] mjx-math { padding: 0px; }
mjx-container[jax="CHTML"][justify="left"] { text-align: left; }
mjx-container[jax="CHTML"][justify="right"] { text-align: right; }
mjx-mi { display: inline-block; text-align: left; }
mjx-c { display: inline-block; }
mjx-utext { display: inline-block; padding: 0.75em 0px 0.2em; }
mjx-msub { display: inline-block; text-align: left; }
mjx-texatom { display: inline-block; text-align: left; }
mjx-mo { display: inline-block; text-align: left; }
mjx-stretchy-h { display: inline-table; width: 100%; }
mjx-stretchy-h > * { display: table-cell; width: 0px; }
mjx-stretchy-h > * > mjx-c { display: inline-block; transform: scaleX(1); }
mjx-stretchy-h > * > mjx-c::before { display: inline-block; width: initial; }
mjx-stretchy-h > mjx-ext { overflow: clip visible; width: 100%; }
mjx-stretchy-h > mjx-ext > mjx-c::before { transform: scaleX(500); }
mjx-stretchy-h > mjx-ext > mjx-c { width: 0px; }
mjx-stretchy-h > mjx-beg > mjx-c { margin-right: -0.1em; }
mjx-stretchy-h > mjx-end > mjx-c { margin-left: -0.1em; }
mjx-stretchy-v { display: inline-block; }
mjx-stretchy-v > * { display: block; }
mjx-stretchy-v > mjx-beg { height: 0px; }
mjx-stretchy-v > mjx-end > mjx-c { display: block; }
mjx-stretchy-v > * > mjx-c { transform: scaleY(1); transform-origin: left center; overflow: hidden; }
mjx-stretchy-v > mjx-ext { display: block; height: 100%; box-sizing: border-box; border: 0px solid transparent; overflow: visible clip; }
mjx-stretchy-v > mjx-ext > mjx-c::before { width: initial; box-sizing: border-box; }
mjx-stretchy-v > mjx-ext > mjx-c { transform: scaleY(500) translateY(0.075em); overflow: visible; }
mjx-mark { display: inline-block; height: 0px; }
mjx-mn { display: inline-block; text-align: left; }
mjx-c::before { display: block; width: 0px; }
.MJX-TEX { font-family: MJXZERO, MJXTEX; }
.TEX-B { font-family: MJXZERO, MJXTEX-B; }
.TEX-I { font-family: MJXZERO, MJXTEX-I; }
.TEX-MI { font-family: MJXZERO, MJXTEX-MI; }
.TEX-BI { font-family: MJXZERO, MJXTEX-BI; }
.TEX-S1 { font-family: MJXZERO, MJXTEX-S1; }
.TEX-S2 { font-family: MJXZERO, MJXTEX-S2; }
.TEX-S3 { font-family: MJXZERO, MJXTEX-S3; }
.TEX-S4 { font-family: MJXZERO, MJXTEX-S4; }
.TEX-A { font-family: MJXZERO, MJXTEX-A; }
.TEX-C { font-family: MJXZERO, MJXTEX-C; }
.TEX-CB { font-family: MJXZERO, MJXTEX-CB; }
.TEX-FR { font-family: MJXZERO, MJXTEX-FR; }
.TEX-FRB { font-family: MJXZERO, MJXTEX-FRB; }
.TEX-SS { font-family: MJXZERO, MJXTEX-SS; }
.TEX-SSB { font-family: MJXZERO, MJXTEX-SSB; }
.TEX-SSI { font-family: MJXZERO, MJXTEX-SSI; }
.TEX-SC { font-family: MJXZERO, MJXTEX-SC; }
.TEX-T { font-family: MJXZERO, MJXTEX-T; }
.TEX-V { font-family: MJXZERO, MJXTEX-V; }
.TEX-VB { font-family: MJXZERO, MJXTEX-VB; }
mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c { font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A !important; }
@font-face { font-family: MJXZERO; src: url("lib/fonts/mathjax_zero.woff") format("woff"); }
@font-face { font-family: MJXTEX; src: url("lib/fonts/mathjax_main-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-B; src: url("lib/fonts/mathjax_main-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-I; src: url("lib/fonts/mathjax_math-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-MI; src: url("lib/fonts/mathjax_main-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-BI; src: url("lib/fonts/mathjax_math-bolditalic.woff") format("woff"); }
@font-face { font-family: MJXTEX-S1; src: url("lib/fonts/mathjax_size1-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S2; src: url("lib/fonts/mathjax_size2-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S3; src: url("lib/fonts/mathjax_size3-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S4; src: url("lib/fonts/mathjax_size4-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-A; src: url("lib/fonts/mathjax_ams-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-C; src: url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-CB; src: url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-FR; src: url("lib/fonts/mathjax_fraktur-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-FRB; src: url("lib/fonts/mathjax_fraktur-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SS; src: url("lib/fonts/mathjax_sansserif-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSB; src: url("lib/fonts/mathjax_sansserif-bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSI; src: url("lib/fonts/mathjax_sansserif-italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-SC; src: url("lib/fonts/mathjax_script-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-T; src: url("lib/fonts/mathjax_typewriter-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-V; src: url("lib/fonts/mathjax_vector-regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-VB; src: url("lib/fonts/mathjax_vector-bold.woff") format("woff"); }
mjx-c.mjx-c1D437.TEX-I::before { padding: 0.683em 0.828em 0px 0px; content: "D"; }
mjx-c.mjx-c1D452.TEX-I::before { padding: 0.442em 0.466em 0.011em 0px; content: "e"; }
mjx-c.mjx-c1D459.TEX-I::before { padding: 0.694em 0.298em 0.011em 0px; content: "l"; }
mjx-c.mjx-c1D44E.TEX-I::before { padding: 0.441em 0.529em 0.01em 0px; content: "a"; }
mjx-c.mjx-c1D466.TEX-I::before { padding: 0.442em 0.49em 0.205em 0px; content: "y"; }
mjx-c.mjx-c1D45B.TEX-I::before { padding: 0.442em 0.6em 0.011em 0px; content: "n"; }
mjx-c.mjx-c1D45C.TEX-I::before { padding: 0.441em 0.485em 0.011em 0px; content: "o"; }
mjx-c.mjx-c1D451.TEX-I::before { padding: 0.694em 0.52em 0.01em 0px; content: "d"; }
mjx-c.mjx-c3D::before { padding: 0.583em 0.778em 0.082em 0px; content: "="; }
mjx-c.mjx-c1D45D.TEX-I::before { padding: 0.442em 0.503em 0.194em 0px; content: "p"; }
mjx-c.mjx-c1D45F.TEX-I::before { padding: 0.442em 0.451em 0.011em 0px; content: "r"; }
mjx-c.mjx-c1D450.TEX-I::before { padding: 0.442em 0.433em 0.011em 0px; content: "c"; }
mjx-c.mjx-c2B::before { padding: 0.583em 0.778em 0.082em 0px; content: "+"; }
mjx-c.mjx-c1D45E.TEX-I::before { padding: 0.442em 0.46em 0.194em 0px; content: "q"; }
mjx-c.mjx-c1D462.TEX-I::before { padding: 0.442em 0.572em 0.011em 0px; content: "u"; }
mjx-c.mjx-c1D461.TEX-I::before { padding: 0.626em 0.361em 0.011em 0px; content: "t"; }
mjx-c.mjx-c1D460.TEX-I::before { padding: 0.442em 0.469em 0.01em 0px; content: "s"; }
mjx-c.mjx-c2212::before { padding: 0.583em 0.778em 0.082em 0px; content: "−"; }
mjx-c.mjx-c1D441.TEX-I::before { padding: 0.683em 0.888em 0px 0px; content: "N"; }
mjx-c.mjx-c28::before { padding: 0.75em 0.389em 0.25em 0px; content: "("; }
mjx-c.mjx-c29::before { padding: 0.75em 0.389em 0.25em 0px; content: ")"; }
mjx-c.mjx-c1D445.TEX-I::before { padding: 0.683em 0.759em 0.021em 0px; content: "R"; }
mjx-c.mjx-c1D440.TEX-I::before { padding: 0.683em 1.051em 0px 0px; content: "M"; }
mjx-c.mjx-c1D456.TEX-I::before { padding: 0.661em 0.345em 0.011em 0px; content: "i"; }
mjx-c.mjx-c31::before { padding: 0.666em 0.5em 0px 0px; content: "1"; }
mjx-c.mjx-c2C::before { padding: 0.121em 0.278em 0.194em 0px; content: ","; }
mjx-c.mjx-c32::before { padding: 0.666em 0.5em 0px 0px; content: "2"; }
mjx-c.mjx-c33::before { padding: 0.665em 0.5em 0.022em 0px; content: "3"; }
mjx-c.mjx-c2E::before { padding: 0.12em 0.278em 0px 0px; content: "."; }
mjx-c.mjx-c1D439.TEX-I::before { padding: 0.68em 0.749em 0px 0px; content: "F"; }
mjx-c.mjx-c2F::before { padding: 0.75em 0.5em 0.25em 0px; content: "/"; }
mjx-c.mjx-c1D44F.TEX-I::before { padding: 0.694em 0.429em 0.011em 0px; content: "b"; }
mjx-c.mjx-c35::before { padding: 0.666em 0.5em 0.022em 0px; content: "5"; }
mjx-c.mjx-c30::before { padding: 0.666em 0.5em 0.022em 0px; content: "0"; }
mjx-c.mjx-c1D43E.TEX-I::before { padding: 0.683em 0.889em 0px 0px; content: "K"; }
mjx-c.mjx-c1D43B.TEX-I::before { padding: 0.683em 0.888em 0px 0px; content: "H"; }
</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> OS</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="6. Processing The Processes"><ol start="6">
<li dir="auto">Processing The Processes</li>
</ol></h1><div class="el-h2 heading-wrapper"><h2 data-heading="第一课 Processes" dir="auto" class="heading" id="第一课_Processes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第一课 Processes</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">1.1 节内容了解即可，你需要知道什么是程序段、ELF 文件是什么。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.1 Program and Process" dir="auto" class="heading" id="1.1_Program_and_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 Program and Process</h3><div class="heading-children"><div class="el-blockquote"><blockquote dir="auto">
<p><em>A process is a program in execution.</em></p>
</blockquote></div><div class="el-p"><p dir="auto">你对进程这个词可能会陌生，但是你一定不陌生程序和文件这两个词。我们知道程序可以运行在机器上，而文件则是以一定格式存放数据的地方。要生成一个进程，我们需要先将程序交给操作系统，让操作系统帮我们运行。我们把这样具有一定格式的程序文件称为<strong>可执行文件</strong>。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.1 Executable Files" dir="auto" class="heading" id="1.1.1_Executable_Files"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.1 Executable Files</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们这里所说的程序并不是高级语言源程序。高级语言源程序是给人类看的，计算机并不认识这些 ASCII 字符代表什么含义。在使用 C 语言的情况下，我们需要预处理、编译、汇编、链接之后才能得到可执行文件。且在不同的操作系统中，使用的可执行文件格式可能是不同的。</p></div><div class="el-p"><p dir="auto">在 Linux 系统中，最常见的可执行文件格式是 <strong>ELF(Executable and Linkable Format)</strong>。ELF 格式非常灵活，支持静态链接、动态链接、可重定位代码等多种特性。它不仅用于可执行文件，还用于共享库和核心转储文件。</p></div><div class="el-p"><p dir="auto">而在Windows系统中，标准的可执行文件格式是 <code>.exe</code> ，这是 "executable" 的缩写，可能也是我们见的最多的可执行文件的格式。除了 <code>.exe</code> 格式，Windows 还使用其他格式，如 <code>.dll</code>（动态链接库）和 <code>.sys</code>（系统驱动程序）。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.2 ELF Layout (x64)" dir="auto" class="heading" id="1.1.2_ELF_Layout_(x64)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.2 ELF Layout (x64)</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们说文件是具有一定格式的数据集合。ELF 文件有两种视图：链接视图和可执行视图，前者指链接之前的 ELF 目标文件，后者是指链接完成之后的 ELF 目标文件。二者最主要的区别在于，链接前的 ELF 目标文件无法直接载入内存中执行；而通过链接，ELF 目标文件中的地址确定之后（虚拟地址），就可以载入内存中运行了。</p></div><div class="el-p"><p dir="auto">在后续的小节中，我们用下面的程序做例子：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们用命令将程序生成<strong>可重定位目标文件</strong>和<strong>可执行目标文件</strong>：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc <span class="token parameter variable">-c</span> hello.c <span class="token parameter variable">-o</span> hello.o
gcc hello.c <span class="token parameter variable">-o</span> hello
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.3 ELF: Relocatable File" dir="auto" class="heading" id="1.1.3_ELF:_Relocatable_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3 ELF: Relocatable File</h4><div class="heading-children"><div class="el-p"><p dir="auto">在ELF文件的可重定位视图中，目标文件由<strong>ELF头</strong>、<strong>程序头表（可选）</strong>、<strong>节(Sections)</strong>、和<strong>节头表</strong>组成。节(section)是ELF文件中具有相同特征的最小可处理单位，链接时就是对相同的属性的节进行组合成段(segments)，最后按段进行加载。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.3.1 ELF Header" dir="auto" class="heading" id="1.1.3.1_ELF_Header"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3.1 ELF Header</h5><div class="heading-children"><div class="el-p"><p dir="auto">ELF头位于ELF文件最开始的地方（偏移为0），包含了文件结构的说明信息。ELF64头信息在机器中的编码是01序列，我们可以通过<code>readelf</code> 这种工具软件来查看ELF中包含的信息。这里我们需要读取文件的头信息，我们用 <code>readelf -h hello.o</code> 来获取ELF的头包含什么信息。</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -h hello.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          600 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 13
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><code>hello.o</code> 是可重定位的目标文件，给出的是 ELF 的链接视图，所以装入的入口地址是 <code>0x0</code>。这时的程序是无法执行的。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.3.2 Program Header Table" dir="auto" class="heading" id="1.1.3.2_Program_Header_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3.2 Program Header Table</h5><div class="heading-children"><div class="el-p"><p dir="auto">程序头表主要在程序的加载阶段使用。链接阶段主要关注的是节和节头表。程序头表我们保留，在介绍。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.3.3 Sections and Section Header Table" dir="auto" class="heading" id="1.1.3.3_Sections_and_Section_Header_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3.3 Sections and Section Header Table</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们前面在ELF头中其实都看到<code>hello.o</code> 中有多少个节头了。这些节头给出每个节的相关信息，如节的名称、节的起始地址、节的偏移等等。每个节承担不同的功能，我们很快就能根据这些信息从文件的二进值信息这找到我们写进去的数据了。</p></div><div class="el-p"><p dir="auto">节头表是一个结构体，包含了每个节的信息。在ELF头中，我们看到一个节头的大小是64字节，节头的结构体定义如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> sh_name<span class="token punctuation">;</span>      <span class="token comment">// 节名称的索引</span>
    <span class="token class-name">uint32_t</span> sh_type<span class="token punctuation">;</span>      <span class="token comment">// 节的类型</span>
    <span class="token class-name">uint64_t</span> sh_flags<span class="token punctuation">;</span>     <span class="token comment">// 节的标志(在虚拟空间中的访问属性)</span>
    <span class="token class-name">uint64_t</span> sh_addr<span class="token punctuation">;</span>      <span class="token comment">// 节的虚拟内存地址(链接视图无意义)</span>
    <span class="token class-name">uint64_t</span> sh_offset<span class="token punctuation">;</span>    <span class="token comment">// 节在文件中的偏移</span>
    <span class="token class-name">uint64_t</span> sh_size<span class="token punctuation">;</span>      <span class="token comment">// 节的大小</span>
    <span class="token class-name">uint32_t</span> sh_link<span class="token punctuation">;</span>      <span class="token comment">// 节的链接信息</span>
    <span class="token class-name">uint32_t</span> sh_info<span class="token punctuation">;</span>      <span class="token comment">// 链接信息</span>
    <span class="token class-name">uint64_t</span> sh_addralign<span class="token punctuation">;</span> <span class="token comment">// 对齐要求信息</span>
    <span class="token class-name">uint64_t</span> sh_entsize<span class="token punctuation">;</span>   <span class="token comment">// 节中条目的大小</span>
<span class="token punctuation">}</span> Elf64_Shdr<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">节头的结构体中的数据都是01序列，所以我们用 <code>readelf -S</code> 命令来获取节头表的信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -S hello.o
There are 14 section headers, starting at offset 0x258:
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
       
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       000000000000001e  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000198
       0000000000000030  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  0000005e
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  0000005e
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .rodata           PROGBITS         0000000000000000  0000005e
       000000000000000d  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  0000006b
       000000000000002c  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000098
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  000000b8
       0000000000000038  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  000001c8
       0000000000000018  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  000000f0
       0000000000000090  0000000000000018          12     4     8
  [12] .strtab           STRTAB           0000000000000000  00000180
       0000000000000013  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  000001e0
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">现在，我们就能准确地从中知道每个节相对 base 的确切位置。但仍然迷惑的是为何所有节的地址字段都为 <code>0x0000</code> ？这是因为当前 <code>hello.o</code> 并没有链接重定位生成可执行目标文件，所以对应的每个节的起始地址都为 <code>0x0</code>（因为这时的节地址是毫无意义的）。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.3.4 File Structure Layout" dir="auto" class="heading" id="1.1.3.4_File_Structure_Layout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.3.4 File Structure Layout</h5><div class="heading-children"><div class="el-p"><p dir="auto">通过节头表中的信息和ELF头的信息，我们就能绘制出 <code>hello.o</code> 文件结构：</p></div><div class="el-pre"><pre><code data-line="0">+-------------------------+-------------------------+   0x000
| ELF Header              | 64 bytes (0x40)         |
+-------------------------+-------------------------+   0x040
| .text                   | 30 bytes (0x1e)         |
+-------------------------+-------------------------+   0x05e
| .data                   | 0 bytes                 |
+-------------------------+-------------------------+   0x05e
| .bss                    | 0 bytes                 |
+-------------------------+-------------------------+   0x05e
| .rodata                 | 13 bytes (0x0d)         |
+-------------------------+-------------------------+   0x06b
| .comment                | 44 bytes (0x2c)         |
+-------------------------+-------------------------+   0x097
| .note.GNU-stack         | 0 bytes                 |
+-------------------------+-------------------------+   0x097
+-------------------------+-------------------------+   0x098(0x97对齐)
| .note.gnu.property      | 32 bytes (0x20)         |
+-------------------------+-------------------------+   0x0b8
| .eh_frame               | 56 bytes (0x38)         |
+-------------------------+-------------------------+   0x0f0
| .symtab                 | 144 bytes (0x90)        |
+-------------------------+-------------------------+   0x180
| .strtab                 | 19 bytes (0x13)         |
+-------------------------+-------------------------+   0x193
+-------------------------+-------------------------+   0x198(0x193对齐)
| .rela.text              | 48 bytes (0x30)         |
+-------------------------+-------------------------+   0x1c8
| .rela.eh_frame          | 24 bytes (0x18)         |
+-------------------------+-------------------------+   0x1e0
| .shstrtab               | 116 bytes (0x74)        |
+-------------------------+-------------------------+   0x254(596 Bytes)
+-------------------------+-------------------------+   0x258(600 Bytes)
| Section Headers         | 896 bytes (14 * 64)     |
+-------------------------+-------------------------+   0x5d8(600+896 Bytes)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过结构信息，我们可以很清楚地看到文件从哪开始，从哪里结束。我们用 <code>hexdump -C</code> 以16进制和 ASCII 格式查看<code> hello.o</code> 文件。我们看到，程序如我们预想的一样从 <code>0x5d8</code> 结束。查看 <code>.rodata</code> 节的位置，我们也如预料地看到了 <code>hello,world.</code> 这样12个字符。至此，关于 hello.o 的解读圆满结束！</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ hexdump -C hello.o
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
...
00000050  89 c7 e8 00 00 00 00 b8  00 00 00 00 5d c3 68 65  |............].he|
00000060  6c 6c 6f 2c 20 77 6f 72  6c 64 00 00 47 43 43 3a  |llo, world..GCC:|
...
000005d0  00 00 00 00 00 00 00 00                           |........|
000005d8
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.1.4 ELF: Position-Independent Executable File" dir="auto" class="heading" id="1.1.4_ELF:_Position-Independent_Executable_File"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.4 ELF: Position-Independent Executable File</h4><div class="heading-children"><div class="el-p"><p dir="auto">既然本阶段和进程有关，我们就聚焦于ELF的可执行目标文件视图上。链接后，可重定位目标文件进行相同属性节合并成段。由于在程序加载时是按段为单位进行加载，所以可执行目标文件由<strong>ELF头</strong>、<strong>程序头表</strong>、<strong>段(Segments)</strong>、<strong>节</strong>、和<strong>节头表</strong>组成，新加入了段的概念。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.4.1 ELF Header" dir="auto" class="heading" id="1.1.4.1_ELF_Header"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.4.1 ELF Header</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们先用命令<code> readelf -h</code> 查看ELF头，看看与可重定位目标文件有什么不同。首先，最大的不同就是程序的<strong>入口地址</strong>不再是0了，还多了<strong>程序头表</strong>还有节的数量变多了。然后我们发现，在链接（重定位）过后，我们<strong>少了带重定位信息的节</strong>（如 <code>.rela.text</code> 、<code>.rela.data</code> 等）。</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -h hello
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13976 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.1.4.2 Program Header Table" dir="auto" class="heading" id="1.1.4.2_Program_Header_Table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1.4.2 Program Header Table</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们从ELF头中并没有找到什么关于段和段头表的信息，它们在哪里呢？这些信息就存储在程序头中。在ELF头中，我们能读取到程序头的大小和数量，每个程序头描述了一个段的信息。所以，一个个的程序头实际上就是一个个的段头。</p></div><div class="el-p"><p dir="auto">和节头一样，段头也是一个结构体数组，段头表用于描述这些段的各种属性信息。从上面的ELF头信息中我们可以读出，程序有13个段头，每个段头有56个字节。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> p_type<span class="token punctuation">;</span>   <span class="token comment">// 段的类型</span>
    <span class="token class-name">uint32_t</span> p_flags<span class="token punctuation">;</span>  <span class="token comment">// 段的权限标志</span>
    <span class="token class-name">uint64_t</span> p_offset<span class="token punctuation">;</span> <span class="token comment">// 段在文件中的偏移量</span>
    <span class="token class-name">uint64_t</span> p_vaddr<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的虚拟地址</span>
    <span class="token class-name">uint64_t</span> p_paddr<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的物理地址</span>
    <span class="token class-name">uint64_t</span> p_filesz<span class="token punctuation">;</span> <span class="token comment">// 段在文件中的大小</span>
    <span class="token class-name">uint64_t</span> p_memsz<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的大小</span>
    <span class="token class-name">uint64_t</span> p_align<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的对齐要求</span>
<span class="token punctuation">}</span> Elf64_Phdr<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">程序头表描述了从文件中加载的各个段(segment) 的属性和位置，这些信息对于系统加载器将程序加载到内存并执行至关重要。每个Program Header描述了一个或多个段(segment)，包括它们在文件中的位置和大小、应当被加载到内存中的位置、以及需要的内存权限(如只读、可读写等)。</p></div><div class="el-p"><p dir="auto">我们用 <code>readelf -l</code> 读取段头表的信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -l hello

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1060
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000628 0x0000000000000628  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x0000000000000175 0x0000000000000175  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x00000000000000f4 0x00000000000000f4  R      0x1000
  LOAD           0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000258 0x0000000000000260  RW     0x1000
  DYNAMIC        0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000030 0x0000000000000030  R      0x8
  NOTE           0x0000000000000368 0x0000000000000368 0x0000000000000368
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000030 0x0000000000000030  R      0x8
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x0000000000000034 0x0000000000000034  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000248 0x0000000000000248  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过 Section to Segment mapping 中的信息，我们能够知道各个段和其所包含的节之间的映射关系，哪个段由哪些节组成。并且通过段的类型能够知道哪些段是需要载入内存，与存储器进行映像的。通过这些段头的信息，和在上节课的操作一样，我们可以通过这些地址信息找到我们只读字符串的位置。</p></div><div class="el-pre"><pre><code data-line="0">00002000  01 00 02 00 68 65 6c 6c  6f 2c 20 77 6f 72 6c 64  |....hello, world|
00002010  00 00 00 00 01 1b 03 3b  30 00 00 00 05 00 00 00  |.......;0.......|
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.2 Program Loading" dir="auto" class="heading" id="1.2_Program_Loading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 Program Loading</h3><div class="heading-children"><div class="el-p"><p dir="auto">当 ELF 程序加载进内存时，我们就说一个新的进程诞生了。当我们请求操作系统运行一个程序(如ELF可执行文件)时，操作系统会完成以下步骤：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>读取文件</strong>：操作系统读取存储在磁盘上的 ELF 可执行文件。</li>
<li data-line="1" dir="auto"><strong>创建进程</strong>：操作系统调用创建新进程的系统调用（如<code>fork</code>或<code>exec</code>），此时会分配并初始化PCB。PCB包含进程的基本信息，如进程ID、状态、优先级、程序计数器、寄存器信息等。</li>
<li data-line="2" dir="auto"><strong>解析Program Header Table</strong>：系统解析Program Header以确定文件的哪些部分需要被加载到内存，它们需要被加载到内存的什么位置，以及需要什么权限（只读、读写、执行）。</li>
<li data-line="3" dir="auto"><strong>内存分配</strong>：操作系统为程序的各个段分配内存。这通常涉及到为代码段、数据段和BSS段分配空间，同时也包括为动态链接库和程序运行时堆栈的初始化预留空间。</li>
<li data-line="4" dir="auto"><strong>加载到内存</strong>：将代码和数据从磁盘复制到内存中的预定位置。</li>
<li data-line="5" dir="auto"><strong>程序执行</strong>：操作系统将控制权交给程序，从其入口点开始执行。</li>
</ol></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.3 Process" dir="auto" class="heading" id="1.3_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 Process</h3><div class="heading-children"><div class="el-p"><p dir="auto">简单地说，<strong>进程是运行程序的一个实例</strong>。相比于程序（包括指令和数据），进程还包含进程状态以及执行所需要的各项资源。也因此，我们称程序是静态的，而进程是动态的。进程是操作系统资源分配调度的基本单位，每个进程也都有自己独立的虚拟内存区域和其他的资源。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.1 Process Control Block" dir="auto" class="heading" id="1.3.1_Process_Control_Block"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.1 Process Control Block</h4><div class="heading-children"><div class="el-p"><p dir="auto">当进程被创建，操作系统需要一个数据结构来跟踪并表示一个进程的信息和状态，我们通常将这个结构称作<strong>进程控制块</strong>。操作系统将进程的所有信息都存储在一个PCB中。在所有的现代操作系统中，每个进程都有一个与之对应的PCB，它用于存储关于该进程的全部信息，PCB 中包括:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>进程标识符(Process Identifier, PID)</strong>：这是一个整型，用于区分系统中的各个进程。</li>
<li data-line="1" dir="auto"><strong>进程状态(State)</strong>：它表示进程当前的状态，如就绪(ready)、运行(running)、等待(waiting)或终止(terminated)等。</li>
<li data-line="2" dir="auto"><strong>程序计数器(Program Counter)</strong>：存储下一条要执行的指令的地址。</li>
<li data-line="3" dir="auto"><strong>CPU寄存器信息(Register Data)</strong>：保存进程执行状态需要的所有寄存器值，包括累加器、索引寄存器、栈指针等。</li>
<li data-line="4" dir="auto"><strong>CPU调度信息(Scheduling infos)</strong>：包括进程优先级、调度队列指针等，用于CPU调度决策。</li>
<li data-line="5" dir="auto"><strong>内存管理信息</strong>：包括指向进程页面表、内存限制、段表等的指针。</li>
<li data-line="6" dir="auto"><strong>会计信息(Accounting Infomation)</strong>：包括CPU使用时间、实际使用的时间和限制、进程创建的时间等。</li>
<li data-line="7" dir="auto"><strong>I/O 状态信息</strong>：包括分配给进程的I/O设备列表、打开文件列表等。</li>
<li data-line="8" dir="auto">......<br>
<span alt="Pasted image 20241110161041.png" src="Pasted image 20241110161041.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241110161041.png" src="congzhi's-os-series/pics/pasted-image-20241110161041.png"></span></li>
</ol></div><div class="el-p"><p dir="auto">PCB是操作系统内核中的一个重要数据结构，用于存储与一个特定进程相关的所有信息。通过这些信息，操作系统可以有效地管理和调度进程，确保多任务环境下的进程并发执行和资源分配的合理性。操作系统每次对进程的操作都对应着对PCB的更新。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3.1.1 task_struct" dir="auto" class="heading" id="1.3.1.1_task_struct"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.1.1 task_struct</h5><div class="heading-children"><div class="el-p"><p dir="auto">在 Linux操作系统中，进程控制块在<code>task_struct</code>的C结构体中实现。<code>task_struct</code>结构体位于内核源代码目录中的<code>&lt;include/linux/sched.h&gt;</code>头文件中。这个结构体包含了表示进程所需的所有信息，包括进程的状态、调度和内存管理信息、打开文件的列表，以及指向进程的父进程、子进程和兄弟进程的指针。</p></div><div class="el-p"><p dir="auto">其中的一些字段有：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">long</span> state<span class="token punctuation">;</span>                     <span class="token comment">/* state of the process */</span>   
<span class="token keyword">struct</span> <span class="token class-name">sched</span> entity se<span class="token punctuation">;</span>         <span class="token comment">/* scheduling information */</span> 
<span class="token keyword">struct</span> <span class="token class-name">task</span> <span class="token keyword">struct</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>     <span class="token comment">/* this process’s parent */</span> 
<span class="token keyword">struct</span> <span class="token class-name">list</span> head children<span class="token punctuation">;</span>      <span class="token comment">/* this process’s children */</span> 
<span class="token keyword">struct</span> <span class="token class-name">files</span> <span class="token keyword">struct</span> <span class="token operator">*</span>files<span class="token punctuation">;</span>     <span class="token comment">/* list of open files */</span> 
<span class="token keyword">struct</span> <span class="token class-name">mm</span> <span class="token keyword">struct</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>           <span class="token comment">/* address space */</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">......</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.2 Virtual Memory" dir="auto" class="heading" id="1.3.2_Virtual_Memory"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2 Virtual Memory</h4><div class="heading-children"><div class="el-p"><p dir="auto">在进程运行时，它所看到的一切都是虚拟的。所有的地址空间都是操作系统提供给进程的抽象概念，使得每个进程看起来都拥有一段连续且私有的内存区域。这就是虚拟地址空间，这种机制使得进程在运行时似乎有独立且完整的内存控制，而实际上其物理内存可能是非连续的，甚至与其他进程共享。</p></div><div class="el-p"><p dir="auto">也就是说，进程使用的地址都是虚拟地址，而不是真实的物理内存上的地址。虚拟地址并不直接映射到物理内存的实际地址上，而是通过内存管理单元(Memory Management Unit, MMU)进行地址转换。实际上，CPU使用的也是虚拟地址，要映射到物理内存上同样需要MMU的参与。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3.2.1 Different Mode, Different Space" dir="auto" class="heading" id="1.3.2.1_Different_Mode,_Different_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2.1 Different Mode, Different Space</h5><div class="heading-children"><div class="el-p"><p dir="auto">上个阶段，我们谈论到了用户模式和内核模式，还简单地谈到了内核栈。为了实现系统的安全性和稳定性，我们将进程的虚拟内存空间划分为用户空间和内核空间。在32位机器上，由于处理器最多一次性处理的地址为32位的二进制数，只能访问 <span class="math math-inline is-loaded"><mjx-container class="MathJax" jax="CHTML"><mjx-math class="MJX-TEX"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-texatom size="s" texclass="ORD"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msup><mjx-mtext class="mjx-n"><mjx-c class="mjx-c42"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-c47"></mjx-c><mjx-c class="mjx-c42"></mjx-c></mjx-mtext></mjx-math></mjx-container></span> 的内存空间。因而，我们常用<strong>低 3GB 表示用户空间，用高 1GB 表示内核空间</strong>。</p></div><div class="el-p"><p dir="auto">随着软件业的发展，软件占用的空间也越来越大。32 位的机器所能提供的 4GB 虚拟内存明显不够用。进而人们研发了新的 64 位计算机架构，解决了 32 位机器虚拟内存小的短板。 64 位机器的寻址的范围可比 32 位机器大得多了。 64 位机器下，高 16bits 用于区别用户空间和内核空间。只使用了低 48 位分别给进程的内核空间和用户空间进行编址。 64 位进程虚拟内存布局如下:</p></div><div class="el-pre"><pre><code data-line="0">Start               End                  Size    Use
0x0000000000000000  0x0000ffffffffffff   256TB   user
0xffff000000000000  0xffffffffffffffff   256TB   kernel
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">由上图，user space 的空间和 kernel space 两个地址空间各有256TB，合在一起才是一个完整的进程虚拟地址空间。64bits 地址的高16bits，即 <code>0xffff</code> 代表内核空间，<code>0x0000</code> 代表用户空间。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3.2.2 User Space" dir="auto" class="heading" id="1.3.2.2_User_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2.2 User Space</h5><div class="heading-children"><div class="el-p"><p dir="auto">这部分空间是每个进程所独有的，用于存储进程运行所需的代码、数据、堆和栈等。应用程序是可见的只有用户空间的地址，应用程序在此范围内执行其代码和处理数据。运行在用户模式下的程序不能直接访问内核空间资源，这增强了系统的安全性。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3.2.3 Kernel Space" dir="auto" class="heading" id="1.3.2.3_Kernel_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.2.3 Kernel Space</h5><div class="heading-children"><div class="el-p"><p dir="auto">内核空间是系统中所有进程共享的空间，用于运行操作系统的内核代码和处理核心任务，如设备管理、内存管理、进程调度等。内核空间对用户模式下的程序是不可见的，只能由运行在内核模式的操作系统代码访问。这部分通常保留较高的地址范围。</p></div><div class="el-p"><p dir="auto">虽然内核空间在每个进程的地址空间中都是可见的，但普通用户程序不能直接读写或执行内核空间的代码或数据。当用户程序需要进行系统调用以请求操作系统的服务时，它将通过定义好的接口（如系统调用）切换到内核模式，此时才能执行内核代码。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.3.3 Process Memory Layout" dir="auto" class="heading" id="1.3.3_Process_Memory_Layout"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.3 Process Memory Layout</h4><div class="heading-children"><div class="el-p"><p dir="auto">进程虚拟内存空间布局是指进程在虚拟内存中的组织和分配方式。它决定了一个进程的各种内存区域如何在虚拟地址空间中排列。典型的进程内存布局主要包括以下几个主要部分：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>文本段(Text Segment)</strong>：程序的二进制执行代码（r/x）。</li>
<li data-line="1" dir="auto"><strong>数据段(Data Segment)</strong>：初始化为非 0 过的全局变量和静态变量（r/w）。</li>
<li data-line="2" dir="auto"><strong>BSS段(Block Started by Symbol)</strong>：存放初始化为 0 / 未初始化的全局和静态变量（r/w）。</li>
<li data-line="3" dir="auto"><strong>只读数据段(Read-Only Data Segment)</strong>：存储着不可修改的数据字符串常量（r）。</li>
<li data-line="4" dir="auto"><strong>堆(Heap)</strong>：用于动态内存分配（使用malloc）。在BSS段后开始，向上增长。</li>
<li data-line="5" dir="auto"><strong>栈(Stack)</strong>：用于存储函数调用的返回地址、局部变量和参数。位于高地址，向下增长。</li>
<li data-line="6" dir="auto"><strong>环境变量(Environment Variables)</strong>：存储与进程相关的环境信息，如路径、用户信息等。</li>
<li data-line="7" dir="auto"><strong>命令行参数(Command Line Arguments)</strong>：存储进程启动时传递的参数。</li>
<li data-line="8" dir="auto"><strong>内核空间(Kernel Space)</strong>：包含操作系统内核和相关数据结构，用户进程不可见。</li>
</ul></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240928001613.png" src="Pasted image 20240928001613.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240928001613.png" src="congzhi's-os-series/pics/pasted-image-20240928001613.png"></span></p></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3.3.1 Get Your Hands-on" dir="auto" class="heading" id="1.3.3.1_Get_Your_Hands-on"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3.3.1 Get Your Hands-on</h5><div class="heading-children"><div class="el-p"><p dir="auto">这小节，我们通过运行自己的测试程序来观察以下某些变量在进程内存布局的哪部分。我们用到的测试程序如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token keyword">int</span> global_b<span class="token punctuation">;</span> <span class="token comment">//Uninitialized global variable</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> static_c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//static variable initializing</span>
	<span class="token keyword">char</span><span class="token operator">*</span> local_d <span class="token operator">=</span> <span class="token string">"hi,world"</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	static_c <span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">为了保留更多的调试信息，在编译链接时加上-g参数，然后用gdb命令对可执行文件进行调试。需要到用到的gdb命令有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><code>list</code> 命令打印代码</li>
<li data-line="1" dir="auto"><code>break main</code> 设置在 main 数处的断点。</li>
<li data-line="2" dir="auto"><code>run</code> 开始执行程序，直到达到断点。</li>
<li data-line="3" dir="auto"><code>info proc mappings</code>显示进程的内存映射，包括各个内存段的地址范围info locals 显示当前函数的局部变量。</li>
<li data-line="4" dir="auto"><code>print</code> &amp;local_d 打印局部变量 local_d 的地址。</li>
</ol></div><div class="el-p"><p dir="auto">我们得到的进程内存布局如下：</p></div><div class="el-pre"><pre><code data-line="0">Mapped address spaces:
Start Addr           End Addr       Size     Offset   Perms  objfile
0x555555554000     0x555555555000   0x1000    0x0     r--p   hiprocess
0x555555555000     0x555555556000   0x1000    0x1000  r-xp   hiprocess //text
0x555555556000     0x555555557000   0x1000    0x2000  r--p   hiprocess //rodata
0x555555557000     0x555555558000   0x1000    0x2000  r--p   hiprocess //rodata
0x555555558000     0x555555559000   0x1000    0x3000  rw-p   hiprocess //data &amp; bss
0x555555559000     0x55555557a000   0x21000     0x0   rw-p   [heap]
0x7ffff7c00000     0x7ffff7c28000   0x28000     0x0   r--p   libc.so.6
0x7ffff7c28000     0x7ffff7dbd000   0x195000 0x28000  r-xp   libc.so.6
0x7ffff7dbd000     0x7ffff7e15000   0x58000  0x1bd000 r--p   libc.so.6
0x7ffff7e15000     0x7ffff7e16000    0x1000  0x215000 ---p   libc.so.6
0x7ffff7e16000     0x7ffff7e1a000    0x4000  0x215000 r--p   libc.so.6
0x7ffff7e1a000     0x7ffff7e1c000    0x2000  0x219000 rw-p   libc.so.6
0x7ffff7e1c000     0x7ffff7e29000    0xd000      0x0  rw-p   
0x7ffff7fa9000     0x7ffff7fac000    0x3000      0x0  rw-p   
0x7ffff7fbb000     0x7ffff7fbd000    0x2000      0x0  rw-p   
0x7ffff7fbd000     0x7ffff7fc1000    0x4000      0x0  r--p   [vvar]
0x7ffff7fc1000     0x7ffff7fc3000    0x2000      0x0  r-xp   [vdso]
0x7ffff7fc3000     0x7ffff7fc5000    0x2000      0x0  r--p   ld-linux-x86-64.so.2
0x7ffff7fc5000     0x7ffff7fef000    0x2a000  0x2000  r-xp   ld-linux-x86-64.so.2
0x7ffff7fef000     0x7ffff7ffa000    0xb000   0x2c000 r--p   ld-linux-x86-64.so.2
0x7ffff7ffb000     0x7ffff7ffd000    0x2000   0x37000 r--p   ld-linux-x86-64.so.2
0x7ffff7ffd000     0x7ffff7fff000    0x2000   0x39000 rw-p   ld-linux-x86-64.so.2
0x7ffffffde000     0x7ffffffff000    0x21000     0x0  rw-p   [stack]
0xffffffffff600000 0xffffffffff601000 0x1000     0x0  --xp   [vsyscall]
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">对照ELF进程内存布局的表，<strong>global_b</strong>全局变量和<strong>static_c</strong>静态变量的地址都位于<strong>data和bss段</strong>；</li>
<li data-line="1" dir="auto"><strong>char* local_d = "hi,world"</strong> 创建了一个指向字符串的指针变量，其中，字符串中的数据是read-only。因此，指针变量指向的数据位于<strong>rodata段</strong>。</li>
<li data-line="2" dir="auto"><strong>p指针</strong>和<strong>local_d</strong>的地址位于<strong>stack段</strong>，因为它们是个局部变量。</li>
<li data-line="3" dir="auto">p指针指向malloc函数动态内存分配的100个字节，其分配的内存位于<strong>heap段</strong>。</li>
</ul></div><div class="el-pre"><pre><code data-line="0">(gdb) print &amp;static_c
$1 = (int *) 0x555555558010 &lt;static_c&gt;
(gdb) print &amp;local_d
$2 = (char **) 0x7fffffffdee0
(gdb) print &amp;global_b
$3 = (int *) 0x555555558018 &lt;global_b&gt;
(gdb) print &amp;p
$4 = (void **) 0x7fffffffdee8
(gdb) print p
$5 = (void *) 0x5555555592a0
(gdb) print local_d
$6 = 0x555555556004 "hi,world"
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1.4 Stack Space" dir="auto" class="heading" id="1.4_Stack_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4 Stack Space</h3><div class="heading-children"><div class="el-p"><p dir="auto">对于进程来说，栈空间非常重要。我们知道局部变量的概念，但<strong>局部</strong>变量中的局部体现在哪里？对于学过高级语言的我们来说，在花括号“<code>{ }</code>”里面定义的变量就是局部变量了。这样理解当然没有问题，但是为什么会这样呢？</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.1 Stack Frame" dir="auto" class="heading" id="1.4.1_Stack_Frame"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.1 Stack Frame</h4><div class="heading-children"><div class="el-p"><p dir="auto">当一个函数被调用时，系统会为该函数在栈空间上分配一个栈帧(stack frame)，其中包含着所谓的局部变量、参数、返回地址和其他信息。栈是一个动态的概念，局部变量会随着栈帧的创建而被分配，当函数执行完毕、栈帧销毁时，这些局部变量也随之消失。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240509165620.png" src="Pasted image 20240509165620.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240509165620.png" src="congzhi's-os-series/pics/pasted-image-20240509165620.png"></span></p></div><div class="el-p"><p dir="auto">这也为我们使用堆空间带来一些警示。堆内存的申请通常是在函数内进行的，当栈帧销毁时，记录堆内存的指针也将不复存在。如果你没有使用语言提供的自动内存释放工具，你就必须在栈帧销毁前释放内存。当然，也可以像接力比赛一样，将指针的地址传给下一个变量。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.2 Inspect the Stack Space" dir="auto" class="heading" id="1.4.2_Inspect_the_Stack_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.2 Inspect the Stack Space</h4><div class="heading-children"><div class="el-p"><p dir="auto">要查看进程的栈空间，我们还需要用到的 GNU Debugger ，在这次 DIY 的实验中，我们会用到下面的实验代码：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> global_g <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> local_h <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//breakpoint</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> local_i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//breakpoint</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们会用到相关的gdb命令如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>info frame</code>：指令的缩写形式为 <code>i f</code> ，查看函数调用帧所有信息。</li>
<li data-line="1" dir="auto"><code>info registers</code>：查看寄存器的情况(除了浮点寄存器)。</li>
<li data-line="2" dir="auto"><code>info register rbp</code>：查看栈基地址寄存器值。(Base Pointer) | r 表示机器是64位</li>
<li data-line="3" dir="auto"><code>info register rsp</code>：查看栈顶地址寄存器值。(Stack Pointer)</li>
<li data-line="4" dir="auto"><code>x/10x $sp</code>：查看sp(stack pointer，栈顶)开始10个单位的数据(16进制)，每个单位是一个字(在64位机器中是8字节)</li>
<li data-line="5" dir="auto"><code>next</code>：n，步进step over</li>
<li data-line="6" dir="auto"><code>step</code>：s，步入step in</li>
<li data-line="7" dir="auto"><code>disas/disass/disassemble</code>：反汇编指令。有许多选项，如 <code>/m</code>, <code>/r</code>。</li>
</ul></div><div class="el-p"><p dir="auto">我们用gdb查看变量的地址：</p></div><div class="el-pre"><pre><code data-line="0">(gdb) print &amp;local_h
$5 = (int *) 0x7fffffffde0c
(gdb) info frame
Stack level 0, frame at 0x7fffffffde20:
 rip = 0x55555555515c in hello (stack.c:5); saved rip = 0x7fffffffde2f
 called by frame at 0x7fffffffde28
 source language c.
 Arglist at 0x7fffffffde10, args: 
 Locals at 0x7fffffffde10, Previous frame's sp is 0x7fffffffde20
 Saved registers:
  rbp at 0x7fffffffde10, rip at 0x7fffffffde18


(gdb) print &amp;local_i
$6 = (int *) 0x7fffffffdedc

(gdb) i f
Stack level 0, frame at 0x7fffffffdef0:
 rip = 0x5555555551a4 in main (stack.c:17); saved rip = 0x7ffff7c29d90
 source language c.
 Arglist at 0x7fffffffdee0, args: 
 Locals at 0x7fffffffdee0, Previous frame's sp is 0x7fffffffdef0
 Saved registers:
  rbp at 0x7fffffffdee0, rip at 0x7fffffffdee8
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="1.4.3 Stack Frame Information" dir="auto" class="heading" id="1.4.3_Stack_Frame_Information"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4.3 Stack Frame Information</h4><div class="heading-children"><div class="el-p"><p dir="auto">每当一个函数被调用时，都会创建一个全新的栈帧。和系统调用/中断等一样，我们需要在栈帧销毁时回到原函数的下一条指令继续执行。这就需要保存类似的一系列的上下文信息。其中，一部分信息由调用函数（Caller）保存，另一部分信息由被调用函数（Callee）保存。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- line 7</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">函数调用发生在第七行。调用函数会先将参数 <code>b</code> 和 <code>a</code> 的值压栈。然后将下一条指令的返回地址给压栈。之后，调用函数还需要保存部分寄存器（可能被被调函数修改的易失寄存器，比如 <code>EAX</code>, <code>ECX</code>, <code>EDX</code> 等）。被调用函数会保存使用频率相对低的寄存器（<code>EBX</code>, <code>EDI</code>, <code>ESI</code> 等），另外还会将函数里的局部变量压栈。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第二课 Process States and Process Switching" dir="auto" class="heading" id="第二课_Process_States_and_Process_Switching"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第二课 Process States and Process Switching</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.1 Process States" dir="auto" class="heading" id="2.1_Process_States"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 Process States</h3><div class="heading-children"><div class="el-p"><p dir="auto">一个进程的生命周期从<strong>创建(new)</strong> 个进程到进程的 <strong>终止(terminated)</strong>，一般会经历五种不同的状态：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>新建态(New)</strong></li>
<li data-line="1" dir="auto"><strong>就绪态(Ready)</strong></li>
<li data-line="2" dir="auto"><strong>运行态(Running)</strong></li>
<li data-line="3" dir="auto"><strong>等待态(Waiting)</strong></li>
<li data-line="4" dir="auto"><strong>终止态(Terminated)</strong></li>
</ul></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.1.1 New" dir="auto" class="heading" id="2.1.1_New"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1 New</h4><div class="heading-children"><div class="el-p"><p dir="auto">当一个新的进程被创建时，该进程会首先进入<strong>新建态(new)</strong>，这是进程生命周期中的一个瞬间过程。在这个瞬间的状态中，操作系统会为进程创建一个PCB，初始化PCB和进程的状态，随后将指令指针指向指令入口地址。之后，进程会等待操作系统的许可，以进入<strong>就绪态(ready)</strong> 队列。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">在桌面操作系统中，进程通常会被自动批准进入就绪态。</li>
<li data-line="1" dir="auto">RTOS中，为避免系统资源饱和，可能会对进程的准入进行延迟处理，以满足进程的时限要求。</li>
</ul></div><div class="el-p"><p dir="auto">每个新进程的创建都会有一个父进程。一般情况下，引起进程创建的主要有三类事件：</p></div><div class="el-p"><p dir="auto"><strong>（1）系统启动</strong>；<br>
<strong>（2）用户请求（<code>exec()</code>系统调用）</strong>；<br>
<strong>（3）其他进程复制（<code>fork()</code>系统调用）</strong>。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.1.1.1 Newborn Processes in System Booting" dir="auto" class="heading" id="2.1.1.1_Newborn_Processes_in_System_Booting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1.1 Newborn Processes in System Booting</h5><div class="heading-children"><div class="el-p"><p dir="auto">在<a data-href="4. System Boots Up" href="congzhi's-os-series/4.-system-boots-up.html" class="internal-link" target="_self" rel="noopener nofollow">4. System Boots Up</a>的最后，我们简单了解了一下Linux这种类Unix系统是如何启动的。我们看到，在系统启动时，有些进程在“明处”，而有些进程在“暗处”。我们所能看到的实际上都是用户可见的进程（user-visible process），而还有很多进程是我们看不到的，它们时刻支持着系统的运行。对于这类进程，我们称之为<strong>守护进程(Daemon)</strong>。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.1.1.2 `fork()`" dir="auto" class="heading" id="2.1.1.2_`fork()`"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1.2 <code>fork()</code></h5><div class="heading-children"><div class="el-p"><p dir="auto">进程<code>fork()</code>出来的进程是指一个正在运行的进程通过调用fork()系统调用来创建一个新的子进程。这个子进程是父进程的副本，拥有相同的代码和数据，但在操作系统中作为一个独立的进程运行。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters: None.

Return value: 
	- On success: Returns the process ID (PID) of the child process to the parent process, and 0 to the child process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过不同的返回值，我们可以区分父子进程并执行不同的branch逻辑代码。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.1.1.3 You're the Master" dir="auto" class="heading" id="2.1.1.3_You're_the_Master"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1.1.3 You're the Master</h5><div class="heading-children"><div class="el-p"><p dir="auto">用户请求创建的进程是指用户通过操作系统界面或命令行输入指令，要求系统启动某个应用程序或服务。例如，用户双击桌面上的图标或在命令行输入启动命令，这些操作都会触发进程的创建。下面是<code>exec</code> 系列函数的两个常见变体，用于替换子进程的地址空间，使其执行新的程序。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. path: The path to the executable file.
	2. arg: The argument list, terminated by a NULL pointer.

Return value:
	- On success: Does not return, as the new program replaces the current process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. path: The path to the executable file.
	2. argv: An array of argument strings, terminated by a NULL pointer.

Return value:
	- On success: Does not return, as the new program replaces the current process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这个过程中，每个进程都会有相应的父进程负责其创建过程。要启动某个应用程序时，会先使用<code>fork</code>系统调用来创建一个子进程，然后在子进程中使用<code>exec</code>系列系统调用（如<code>execl</code>、<code>execv</code>等）来加载并执行新的程序。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.2 Terminated" dir="auto" class="heading" id="2.2_Terminated"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 Terminated</h4><div class="heading-children"><div class="el-p"><p dir="auto">当进程执行完毕或由于某种原因被终止，进程就会进入<strong>终止态(terminated)</strong>。在这个状态下，操作系统会回收该进程所占用的资源。同样，进程进入终止态也有几种不同的原因，比如：</p></div><div class="el-p"><p dir="auto"><strong>（1）Normal exit (voluntary)</strong>；<br>
<strong>（2）Error exit (voluntary)</strong>；<br>
<strong>（3）Fatal error (involuntary)</strong>；<br>
<strong>（4）Killed by another process (involuntary)</strong></p></div><div class="el-p"><p dir="auto">进程终止后，操作系统会收集进程的一些信息（会计信息等）并移除进程的PCB。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.1 Normal Exit" dir="auto" class="heading" id="2.2.1_Normal_Exit"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.1 Normal Exit</h5><div class="heading-children"><div class="el-p"><p dir="auto">正常退出是指进程自愿完成其任务并退出。这通常发生在用户关闭应用程序或进程完成其预定任务时。例如用户关闭一个应用程序或编译器完成编译任务后退出。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.2 Error Exit（`exit()`）" dir="auto" class="heading" id="2.2.2_Error_Exit（`exit()`）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.2 Error Exit（<code>exit()</code>）</h5><div class="heading-children"><div class="el-p"><p dir="auto">错误退出是指进程遇到错误并自愿退出。例如，程序尝试访问无权限的目录时，可能会选择退出并返回错误代码。当遇到某种错误时，我们常常使用<code>exit()</code>系统调用来终止程序，参数数值表示了代码退出时的状态，以便后续的跟踪。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. status: The exit status of the process. Typically, 0 indicates success, and non-zero indicates failure.

Return value: No return.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">用<code>exit()</code>退出时，操作系统会在进程进入终止态前释放其持有的资源。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.3 Fatal Error" dir="auto" class="heading" id="2.2.3_Fatal_Error"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.3 Fatal Error</h5><div class="heading-children"><div class="el-p"><p dir="auto">致命错误是指进程遇到无法恢复的错误并被操作系统强制终止。例如，发生段错误或除零错误时，操作系统会强制终止进程。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.4 Killed by Others" dir="auto" class="heading" id="2.2.4_Killed_by_Others"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.4 Killed by Others</h5><div class="heading-children"><div class="el-p"><p dir="auto">进程可能会被其他进程强制终止。这通常发生在用户通过任务管理器终止无响应的程序，或者父进程决定终止其子进程。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2.5 Process Return Code" dir="auto" class="heading" id="2.2.5_Process_Return_Code"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2.5 Process Return Code</h5><div class="heading-children"><div class="el-p"><p dir="auto">和函数结束时返回值一样，当进程终止也会返回一个“码”，这是一个整数值。表示进程在终止时的状态。这个代码用于指示进程是否成功执行或是否发生了错误。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>成功执行</strong>：进程成功完成其任务，通常会返回一个值<code>0</code>。</li>
<li data-line="1" dir="auto"><strong>错误发生</strong>：进程执行遇到错误，通常返回一个非零值。不同的值用于代表不同类型的错误。</li>
</ul></div><div class="el-p"><p dir="auto">在Linux中，退出码的范围往往是 0-255，这些退出码可以帮操作系统或用户了解进程的执行结果。根据退出码采取相应的措施。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.3 Process Switching" dir="auto" class="heading" id="2.3_Process_Switching"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 Process Switching</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.1 Five-State Model" dir="auto" class="heading" id="2.3.1_Five-State_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1 Five-State Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们说进程通常而言会有五种状态，其实我们提到的是进程的五态模型，包括新建态、就绪态、运行态、等待态和终止态。任何运行中的进程在生命周期中都可能经历这五种不同的状态。通过将进程划分为不同的状态，操作系统能够更方便的管理计算机资源，为进程分配所需要的资源。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.1.1 State Switching in Five-State Model" dir="auto" class="heading" id="2.3.1.1_State_Switching_in_Five-State_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1.1 State Switching in Five-State Model</h5><div class="heading-children"><div class="el-p"><p dir="auto">在进程的五态模型中，除了我们之前介绍的<strong>新建态</strong>和<strong>终止态</strong>，进程往往还会出现<strong>就绪态</strong>、<strong>运行态</strong>和<strong>等待态(waiting)/阻塞态(blocked)/睡眠态(sleeping)</strong>。</p></div><div class="el-p"><p dir="auto">当进程具备可执行的条件，进程就会进入就绪态。这时，进程会等待被调度器分配CPU时间片来执行。同一时间，可能会有多个进程同时处于就绪态，以一定的顺序等待CPU的调度。为了管理这些就绪进程，操作系统会将这些进程放到一个链表实现的队列中来管理。</p></div><div class="el-p"><p dir="auto">一旦就绪态的进程获得CPU时间片，开始执行代码，那么它就进入了运行态。运行态的进程可能会由于各种各样的情况重新进入就绪态或者进入阻塞态。</p></div><div class="el-p"><p dir="auto">如果进程需要等待某个事件（如I/O操作的完成、资源的可用等）因而无法继续进行，进程就会被阻塞而进入等待队列。当事件发生（I/O操作已经完成）了，阻塞的进程会被唤醒，重新进入就绪态。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250113004224.jpg" src="Pasted image 20250113004224.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250113004224.jpg" src="congzhi's-os-series/pics/pasted-image-20250113004224.jpg"></span></p></div><div class="el-p"><p dir="auto">在五态模型下，进程的状态转变可能会出现以下情况：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>NULL&nbsp;-&gt;&nbsp;New</strong>：新进程的创建。</li>
<li data-line="1" dir="auto"><strong>New&nbsp;-&gt;&nbsp;Ready</strong>：当进程创建完成后，系统将其放入就绪队列，等待调度器的调度。</li>
<li data-line="2" dir="auto"><strong>Ready&nbsp;-&gt;&nbsp;Running</strong>：操作系统的进程调度器选择就绪态进程，为其分配CPU资源。</li>
<li data-line="3" dir="auto"><strong>Ready&nbsp;-&gt;&nbsp;Exit</strong>：在被调度之前进程就被其他进程终止（可能是父进程）。</li>
<li data-line="4" dir="auto"><strong>Running&nbsp;-&gt;&nbsp;Ready</strong>：进程的时间片用完或由于其他调度策略导致进程失去CPU资源（被动）。</li>
<li data-line="5" dir="auto"><strong>Running&nbsp;-&gt;&nbsp;Blocked</strong>：进程等待某个事件的发生而自愿放弃CPU资源。</li>
<li data-line="6" dir="auto"><strong>Running&nbsp;-&gt;&nbsp;Exit</strong>：通常是进程正常退出，也可能是运行过程中发生错误或被终止。</li>
<li data-line="7" dir="auto"><strong>Blocked&nbsp;-&gt;&nbsp;Ready</strong>：阻塞进程接收到事件完成的信号，进入就绪态等待操作系统调度。</li>
</ol></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.1.2 Ready Queue and Wait Queue" dir="auto" class="heading" id="2.3.1.2_Ready_Queue_and_Wait_Queue"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.1.2 Ready Queue and Wait Queue</h5><div class="heading-children"><div class="el-p"><p dir="auto">为了方便管理，操作系统将不同状态的进程放入不同的队列当中进行管理，这个队列是链式的，方便进行PCB的插入和删除。以下是这些链式队列的大致结构。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241130180123.jpg" src="Pasted image 20241130180123.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241130180123.jpg" src="congzhi's-os-series/pics/pasted-image-20241130180123.jpg"></span></p></div><div class="el-p"><p dir="auto">当进程被阻塞进入阻塞态时，操作系统会将阻塞的进程插入到阻塞队列中进行管理，根据不同原因的阻塞，阻塞队列可能有多个。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241130182530.jpg" src="Pasted image 20241130182530.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241130182530.jpg" src="congzhi's-os-series/pics/pasted-image-20241130182530.jpg"></span></p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.3.2 Seven-States Model" dir="auto" class="heading" id="2.3.2_Seven-States_Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.2 Seven-States Model</h4><div class="heading-children"><div class="el-p"><p dir="auto">在五态模型中，我们的视角一直局限于主存。然而，当主存资源耗尽时，我们可以将一些暂时用不到的进程交换（swap）到二级存储器（外存）中，从而腾出更多的资源留给系统中的其他进程，同时也能在一定程度上避免死锁的发生。这就是为什么我们引入七态模型。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3.2.1 Swapping and Suspend" dir="auto" class="heading" id="2.3.2.1_Swapping_and_Suspend"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3.2.1 Swapping and Suspend</h5><div class="heading-children"><div class="el-p"><p dir="auto">在引入七态模型后，我们增加了两个新的状态：<strong>Suspended Ready(就绪挂起)</strong> 和&nbsp;<strong>Suspend Blocked (阻塞挂起)</strong>。这两个状态使得操作系统能够更高效地管理主存和外存资源。</p></div><div class="el-p"><p dir="auto">当进程资源被交换到外存中时，我们就称进程被<strong>挂起</strong>了。在七态模型中，我们就引入了两种挂起态，即进程可以在就绪态被挂起(Suspended ready)，也可以在阻塞态被挂起(Suspended blocked)。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018163535.png" src="Pasted image 20241018163535.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018163535.png" src="congzhi's-os-series/pics/pasted-image-20241018163535.png"></span></p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.4 Context Switch" dir="auto" class="heading" id="2.4_Context_Switch"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4 Context Switch</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.1 CPU Scheduling and Context Switch" dir="auto" class="heading" id="2.4.1_CPU_Scheduling_and_Context_Switch"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1 CPU Scheduling and Context Switch</h4><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="2.4.1.1 CPU Scheduling" dir="auto" class="heading" id="2.4.1.1_CPU_Scheduling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1.1 CPU Scheduling</h5><div class="heading-children"><div class="el-p"><p dir="auto">在之前学习中断时，我们介绍了中断上下文的保存。当时，我们所关心的进程生命周期为：进程创建 -&gt; 使用一些系统调用 -&gt; 进程结束。而且系统一时间只能运行一个进程，并不考虑程序的并发执行和进程阻塞等其他因素。因此，中断上下文往往很简单，只包含一些寄存器，因为系统调用结束后回到用户态继续执行时所需的上下文信息很少。</p></div><div class="el-p"><p dir="auto">然而，CPU从头到尾一次只运行一个程序显然是不能接受的。这样不仅会导致用户体验变差，CPU的利用率也可能很低。为了解决这种情况，人们提出了<strong>多道程序设计</strong>的理念，使得当一个进程等待I/O时，调度器会调度其他进程到CPU上运行。为了使系统更用户友好，我们可以让系统内的应用轮流地各执行1ms，使用户感觉所有进程都在同时运行。这就是分时<strong>多任务系统</strong>的理念。</p></div><div class="el-p"><p dir="auto">在之后的阶段中，我们会介绍很多CPU调度的相关策略。为了使CPU的利用率和系统响应速度更好，操作系统需要选择特定的调度策略对系统内的进程进行调度。CPU调度决定了在任意时间点，哪个进程应该获得CPU的使用权。只要CPU调度发生了，必然牵扯到不同进程的状态转换，只要状态转换了，系统就需要保存进程的上下文信息。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.4.1.2 Process Contexts" dir="auto" class="heading" id="2.4.1.2_Process_Contexts"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1.2 Process Contexts</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们之前提到了，任何对进程的操作最终都会反映在PCB的修改上。当一个进程由于某些原因从运行态上转换成其他状态时，为了保证进程在被暂停后能够恢复并正确继续执行，我们需要保存进程内部（PCB）的一些状态信息。这个信息就是<strong>进程上下文</strong>。进程上下文通常包括：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>CPU寄存器的状态</strong>：这包括通用寄存器(如AX，BX，CX等)、程序计数器PC、堆栈指针BP，SP、指令寄存器IBR、状态寄存器(如EFLAGS)等。</li>
<li data-line="1" dir="auto"><strong>进程的内存状态</strong>：这包括代码本身(CS)、相关的数据、堆栈以及文件描述符等资源。</li>
<li data-line="2" dir="auto"><strong>进程的特定控制信息</strong>：如进程ID、进程的优先级、进程的账户信息、进程的调度状态等。</li>
</ol></div><div class="el-p"><p dir="auto">进程切换时状态时，硬件会自动保存一些上下文（PC寄存器），操作系统会保存剩下的上下文。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.4.1.3 Context Switch" dir="auto" class="heading" id="2.4.1.3_Context_Switch"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.1.3 Context Switch</h5><div class="heading-children"><div class="el-p"><p dir="auto">当OS需要调度一个进程切换到另一个进程时，它会保存进程的上下文，并恢复下一个要运行进程的上下文。这个保存和恢复的过程被称为上下文切换。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241130023834.jpg" src="Pasted image 20241130023834.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241130023834.jpg" src="congzhi's-os-series/pics/pasted-image-20241130023834.jpg"></span></p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.2 Switching Costs" dir="auto" class="heading" id="2.4.2_Switching_Costs"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.2 Switching Costs</h4><div class="heading-children"><div class="el-p"><p dir="auto">进程切换开销是上下文切换中所耗费的系统开销，如上图进程P1执行前后的空闲时间段，这段空闲时间段完全被进程切换所占用。在分时系统中，进程的切换开销往往是调度器选择时间片长度的重要考量因素。使得CPU在处理进程间切换的时间占整个CPU运行时间的比重在一个合理的范围上。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.4.3 Switching Triggers" dir="auto" class="heading" id="2.4.3_Switching_Triggers"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4.3 Switching Triggers</h4><div class="heading-children"><div class="el-p"><p dir="auto">一般情况下，导致进程上下文切换的情况有以下三种：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">Interrupts</li>
<li data-line="1" dir="auto">Multitasking</li>
<li data-line="2" dir="auto">User/Kernel switch</li>
</ul></div><div class="el-p"><p dir="auto"><strong><em>Interrupts:</em></strong>&nbsp;中断是硬件或软件发出的信号，表明需要处理器立即注意的事件。当CPU接收到中断信号时会暂停当前执行的进程(或线程)，保存其状态，并切换到一个专门的中断处理程序来响应和处理这个事件。处理完中断后，操作系统可以选择:</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">恢复被中断的进程的执行。（系统调用这类简单的中断可以只保存中断上下文）</li>
<li data-line="1" dir="auto">切换到另一个进程，特别是在中断处理期间如果有更高优先级的进程变为就绪状态的情况。</li>
</ul></div><div class="el-p"><p dir="auto"><strong><em>Multitasking:</em></strong>&nbsp;多任务处理是操作系统为了更高效地利用处理器资源而进行的进程调度。操作系统会根据特定的调度策略，决定何时将正在运行的进程切换出处理器，以及何时让新的进程或线程占用处理器资源。上下文切换的需求通常来源于以下两种情形：主动和被动，这部分将在进程的状态及转换部分解释。</p></div><div class="el-p"><p dir="auto"><strong><em>Kernel/User Switch:</em></strong>&nbsp;This trigger is used when the OS needed to switch between the&nbsp;<a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/" rel="noopener nofollow" class="external-link" href="https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/" target="_blank">user mode and kernel mode</a>.When switching between user mode and kernel/user mode is necessary, operating systems use the kernel/user switch.</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2.x Moving Beyond: Making New Processes" dir="auto" class="heading" id="2.x_Moving_Beyond:_Making_New_Processes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x Moving Beyond: Making New Processes</h3><div class="heading-children"><div class="el-p"><p dir="auto">本节课的开始，我们说引起进程创建的主要有系统启动、用户请求和其他进程复制的三类事件。那实际情况如何，n个进程是如何变到n+1个进程的？这些就是我们本小节拓展所要解释的，同时更详细地探索这些系统调用实际上都做了什么。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.x.1 Fork and Execute" dir="auto" class="heading" id="2.x.1_Fork_and_Execute"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.1 Fork and Execute</h4><div class="heading-children"><div class="el-p"><p dir="auto">在<a data-href="4. System Boots Up" href="congzhi's-os-series/4.-system-boots-up.html" class="internal-link" target="_self" rel="noopener nofollow">4. System Boots Up</a>中，我们最后简单地提了一嘴，在Linux中，进程号为1的进程是所有进程的祖先进程，<code>init</code>（或<code>systemd</code>）进程是系统启动时由内核创建的第一个进程。之后它会作为父进程启动一些守护进程和用户进程。然后再由这些用户进程生成自己的子进程，这些过程就是通过<code>fork()</code>系统调用完成的。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.1.1 Copy-On-Write Sharing" dir="auto" class="heading" id="2.x.1.1_Copy-On-Write_Sharing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.1.1 Copy-On-Write Sharing</h5><div class="heading-children"><div class="el-p"><p dir="auto">在前面，我们查看了<code>fork()</code>系统调用和<code>exec()</code>系列系统调用的一些函数原型。当父进程用<code>fork()</code>系统调用生成子进程时，一个虚拟内存映像完全一样的子进程就会被创建出来。<code>fork()</code>函数很特别，它有两个返回值，用于区分父子进程。我们可以用不同的返回值来执行不同的逻辑。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241130023659.jpg" src="Pasted image 20241130023659.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241130023659.jpg" src="congzhi's-os-series/pics/pasted-image-20241130023659.jpg"></span></p></div><div class="el-p"><p dir="auto">虽然我们说子进程的内存空间是父进程的拷贝，但是实际上操作系统并不会真的原封不动地复制整个进程内存空间。这时因为操作系统用到了<strong>写时复制</strong>的技术，我们在内存管理的章节中会学到。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.1.2 New Process with New Program" dir="auto" class="heading" id="2.x.1.2_New_Process_with_New_Program"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.1.2 New Process with New Program</h5><div class="heading-children"><div class="el-p"><p dir="auto">子进程创建好了之后，我们可以继续使用父进程的代码逻辑。但大多数时候，我们都想让子进程执行其他的程序，这时候就会用<code>exec()</code>系列的系统调用把当前的进程内存空间进行替换。下面的两个程序就展示了这两种截然不同的子进程执行逻辑。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// fork.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span> </span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is child process.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span><span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is parent process.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// fork.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span> </span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
        <span class="token function">execv</span><span class="token punctuation">(</span><span class="token string">"./hello"</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">上面的例子中，我们用 <code>fork()</code> 和 <code>execv()</code> 系统调用来创建一个子进程，并在子进程中执行一个新的程序。在子进程中，使用 <code>execv()</code> 系统调用执行新的程序 <code>./hello</code>。<code>execv()</code> 替换当前进程的地址空间，使其执行新的程序。而在父进程中，我们调用<code>wait()</code>系统调用，等待子进程结束，避免出现僵尸进程。</p></div><div class="el-p"><p dir="auto">当我们使用<code>strace -f ./fork</code>时，我们会看到程序实际上用到了两个<code>execve()</code>和一个<code>clone()</code>系统调用。第一个<code>execve()</code>用于将当前进程替换为 <code>./fork</code> 程序；接下来，通过 <code>clone()</code> 实现父进程内存空间的复制（<code>fork()</code> 库函数实际上是对 <code>clone()</code> 系统调用的封装）；在子进程中，<code>execv</code> 系统调用被用来执行新的程序 <code>./hello</code>。</p></div><div class="el-pre"><pre><code data-line="0">execve("./fork", ["./fork"], 0x7ffeae4313f8 /* 55 vars */) = 0
...
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLDstrace: Process 20909 attached
, child_tidptr=0x72b7e9c79a10) = 20909
...
[pid 20909] execve("./hello", [], 0x7fffaaac2478 /* 55 vars */) = 0
...
[pid 20909] exit_group(0)               = ?
[pid 20909] +++ exited with 0 +++
&lt;... wait4 resumed&gt;NULL, 0, NULL)       = 20909
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=20909, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
exit_group(0)                           = ?
+++ exited with 0 +++
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在第二种执行逻辑中，其实有一步有些许的多余。我们先是克隆父进程的内存映像，接着对其进行替换。那我们为什么不在最开始的时候就创建一个新的子进程，避免不必要的内存复制操作。而且 Linux 并不保证<code>fork()</code>之后父/子进程执行的先后性。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.x.2 POSIX Spawn" dir="auto" class="heading" id="2.x.2_POSIX_Spawn"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.2 POSIX Spawn</h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>posix_spawn</code> 提供了一个更高级的接口，简化了进程创建和执行的过程。<code>posix_spawn</code> 使用 <code>clone3</code> 系统调用来创建一个新的子进程。与 <code>fork</code> 不同，<code>posix_spawn</code> 不会复制父进程的内存空间，而是直接创建一个新的进程，并立即执行指定的程序。它的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;spawn.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">posix_spawn</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> <span class="token operator">*</span>restrict pid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>restrict path<span class="token punctuation">,</span>
                <span class="token keyword">const</span> <span class="token class-name">posix_spawn_file_actions_t</span> <span class="token operator">*</span>file_actions<span class="token punctuation">,</span>
                <span class="token keyword">const</span> <span class="token class-name">posix_spawnattr_t</span> <span class="token operator">*</span>restrict attrp<span class="token punctuation">,</span>
                <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span>restrict<span class="token punctuation">]</span><span class="token punctuation">,</span>
                <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span>restrict<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. pid: A pointer to a variable where the process ID of the child process will be stored.
	2. path: The path to the program to be executed.
	3. file_actions: A pointer to a posix_spawn_file_actions_t structure that specifies file actions to be performed in the child process before executing the program. Can be NULL.
	4. attrp: A pointer to a posix_spawnattr_t structure that specifies attributes for the child process. Can be NULL.
	5. argv: An array of argument strings passed to the new program. The array must be terminated by a NULL pointer.
	6. envp: An array of environment strings passed to the new program. The array must be terminated by a NULL pointer.

Return value:
	- On success: Returns 0 and stores the process ID of the child process in the variable pointed to by pid.
	- On failure: Returns an error number (positive integer) and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.2.1 Fork vs. Spawn" dir="auto" class="heading" id="2.x.2.1_Fork_vs._Spawn"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.2.1 Fork vs. Spawn</h5><div class="heading-children"><div class="el-p"><p dir="auto">测试代码如下，这段代码和我们前面<code>fork.c</code>的作用相同：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// spawn.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;spawn.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"./hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> status <span class="token operator">=</span> <span class="token function">posix_spawn</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid<span class="token punctuation">,</span> <span class="token string">"./hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process created with PID: %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"posix_spawn failed: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.2.2 What Spawn Brings?" dir="auto" class="heading" id="2.x.2.2_What_Spawn_Brings?"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.2.2 What Spawn Brings?</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们不再这里示例<code>strace -f ./spawn</code>了，我们想一想相比于<code>fork()</code>，<code>posix_spawn()</code>带给我们哪些好处。看看上面的代码，你可能已经发现一个最直接的好处，即<code>posix_spawn</code> 将进程创建和程序执行结合在一个调用中，简化了代码逻辑，减少了开发者犯错的可能。</p></div><div class="el-p"><p dir="auto">通过 <code>posix_spawn_file_actions_t</code> 和 <code>posix_spawnattr_t</code> 结构体，可以在创建新进程时指定文件操作和进程属性，减少了额外的系统调用。</p></div><div class="el-p"><p dir="auto">此外，在使用<code>posix_spawn()</code>时，使用的<code>clone()</code>系统调用实际上会有<code>CLONE_VM</code>和<code>CLONE_VFORK</code>这两个字段。<code>CLONE_VM</code>表示子进程将与父进程共享同一个内存空间，但是不会共享内核资源（文件描述符、信号处理）；<code>CLONE_VFORK</code>表示在子进程调用<code>execve()</code>或<code>_exit()</code>之前，父进程会被挂起。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="2.x.3 Clone Syscall" dir="auto" class="heading" id="2.x.3_Clone_Syscall"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.3 Clone Syscall</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们在上面看到，<code>fork()</code>和<code>posix_spawn()</code>都用到了不同类型的<code>clone()</code>来生成一个子进程。<code>clone()</code>为我们提供了细粒度的操作，我们可以用<code>clone()</code>完成很多有趣的操作。甚至上线程都是用类似的<code>clone3()</code>系统调用完成的。<code>clone()</code>的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sched.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>child_stack<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. fn: A pointer to the function to be executed by the child process. This function takes a single argument of type void* and returns an int.
	2. child_stack: A pointer to the stack space for the child process. The stack grows downwards, so this should point to the end of the allocated stack space.
	3. flags: A bitmask of flags that control the behavior of the child process. Common flags include:
		- CLONE_VM
		- CLONE_FS
		- CLONE_FILES
		- CLONE_SIGHAND
		- CLONE_PARENT
		- CLONE_THREAD
		- CLONE_VFORK
	4. arg: A pointer to the argument to be passed to the function fn.

Return value:
	- On success: Returns the process ID (PID) of the child process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.3.1 Clone3 Syscall" dir="auto" class="heading" id="2.x.3.1_Clone3_Syscall"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.3.1 Clone3 Syscall</h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>clone3()</code>是<code>clone()</code>的改进，相比于后者，<code>clone3()</code>有许多优势，如：更灵活的参数传递、可扩展性更佳等。<code>clone3()</code>的函数原型如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sched.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">clone3</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">clone_args</span> <span class="token operator">*</span>cl_args<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. cl_args: A pointer to a struct clone_args, which contains various fields to specify the behavior and properties of the child process.
	2. size: The size of the struct clone_args structure.

Return value:
	- On success: Returns the process ID (PID) of the child process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">struct</span> <span class="token class-name">clone_args</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> flags<span class="token punctuation">;</span>
    <span class="token class-name">int64_t</span> pidfd<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> child_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> parent_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> exit_signal<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> stack<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> stack_size<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> tls<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> set_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> set_tid_size<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> cgroup<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/* struct clone_args fields:
- flags: A bitmask of flags that control the behavior of the child process. Common flags include CLONE_VM, CLONE_FS, CLONE_FILES, CLONE_SIGHAND, CLONE_PARENT, CLONE_THREAD, CLONE_VFORK, CLONE_SYSVSEM, CLONE_SETTLS, CLONE_PARENT_SETTID, and CLONE_CHILD_CLEARTID.
- pidfd: A file descriptor that refers to the PID of the child process.
- child_tid: A pointer to a location where the child process's thread ID will be stored.
- parent_tid: A pointer to a location where the parent process's thread ID will be stored.
- exit_signal: The signal to be sent to the parent when the child exits.
- stack: A pointer to the stack space for the child process.
- stack_size: The size of the stack space.
- tls: A pointer to the thread-local storage (TLS) area.
- set_tid: A pointer to an array of TIDs to be set in the child.
- set_tid_size: The number of TIDs in the set_tid array.
- cgroup: A file descriptor referring to the cgroup to which the child process should be added.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.3.2 Clone Attributes" dir="auto" class="heading" id="2.x.3.2_Clone_Attributes"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.3.2 Clone Attributes</h5><div class="heading-children"><div class="el-p"><p dir="auto"><code>clone()</code>和<code>clone3()</code>拥有基本相同的flags，用这些不同的flags，我们就可以完成各种各样有趣的事情。常见的flags和相关的释义如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">/* Common flags:
- CLONE_VM: The child process shares the same memory space as the parent process.
- CLONE_FS: The child process shares the same file system information as the parent process.
- CLONE_FILES: The child process shares the same file descriptors as the parent process.
- CLONE_SIGHAND: The child process shares the same signal handlers as the parent process.
- CLONE_PARENT: The child process has the same parent process as the calling process.
- CLONE_THREAD: The child process is placed in the same thread group as the calling process.
- CLONE_VFORK: The parent process is suspended until the child process calls execve() or _exit().
- CLONE_SYSVSEM: The child process shares System V semaphore adjustments with the parent process.
- CLONE_SETTLS: The child process uses the TLS (Thread-Local Storage) area specified in the tls field.
- CLONE_PARENT_SETTID: The child's TID is set in the parent_tid field in the parent process.
- CLONE_CHILD_SETTID: The child's TID is set in the child_tid field in the child process.
- CLONE_CHILD_CLEARTID: The child process's TID is cleared in the child_tid field when the child exits.
- CLONE_UNTRACED: The child process is not traced by the parent process.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.x.3.3 Here Comes the Clone Version" dir="auto" class="heading" id="2.x.3.3_Here_Comes_the_Clone_Version"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.x.3.3 Here Comes the Clone Version</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sched.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/sched.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">clone_args</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint64_t</span> flags<span class="token punctuation">;</span>
    <span class="token class-name">int64_t</span> pidfd<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> child_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> parent_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> exit_signal<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> stack<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> stack_size<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> tls<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> set_tid<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> set_tid_size<span class="token punctuation">;</span>
    <span class="token class-name">uint64_t</span> cgroup<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">extern</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>environ<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"./hello"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">clone_args</span> cl_args <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span>flags <span class="token operator">=</span> CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SIGHAND <span class="token operator">|</span> CLONE_PARENT_SETTID <span class="token operator">|</span> CLONE_CHILD_CLEARTID<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>pidfd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>child_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>parent_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>exit_signal <span class="token operator">=</span> SIGCHLD<span class="token punctuation">,</span>
        <span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>stack_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>tls <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>set_tid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>set_tid_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">.</span>cgroup <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    pid <span class="token operator">=</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_clone3<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cl_args<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"clone3 failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Child process</span>
        <span class="token function">execve</span><span class="token punctuation">(</span><span class="token string">"./hello"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> environ<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execve failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Parent process</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process created with PID: %d\n"</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第三课 Process Organization" dir="auto" class="heading" id="第三课_Process_Organization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第三课 Process Organization</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.1 Process Organization" dir="auto" class="heading" id="3.1_Process_Organization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 Process Organization</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.1 Windows" dir="auto" class="heading" id="3.1.1_Windows"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 Windows</h4><div class="heading-children"></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1.2 Linux Process Tree" dir="auto" class="heading" id="3.1.2_Linux_Process_Tree"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.2 Linux Process Tree</h4><div class="heading-children"><div class="el-p"><p dir="auto">在Linux下，所有的进程都是以树形结构组织起来的。所有的进程都有其父进程（除了根进程&nbsp;<code>init</code>或&nbsp;<code>systemd</code>）。在<code>bash</code>命令行下，你可以用<code>pstree</code>命令来查看这样的树形结构,以获得所有进程及其父子关系的信息。同时，用<code>ps</code>命令可以查看当前系统下进程的各种信息。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018191021.jpg" src="Pasted image 20241018191021.jpg" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018191021.jpg" src="congzhi's-os-series/pics/pasted-image-20241018191021.jpg"></span></p></div><div class="el-p"><p dir="auto">在命令行下，一条命令实际上是由当前的&nbsp;<code>bash</code>&nbsp;创建一个进程，后面的参数是传给这个进程的参数。比如&nbsp;<code>ps</code>、<code>gcc</code>&nbsp;等。而平时我们经常使用&nbsp;<code>./hello</code>&nbsp;来执行程序，为什么&nbsp;<code>ps</code>&nbsp;这些命令行命令不需要&nbsp;<code>./</code>&nbsp;呢？这是因为这些命令的路径问题。</p></div><div class="el-p"><p dir="auto">命令行中的&nbsp;<code>ps</code>、<code>gcc</code>&nbsp;等命令通常位于系统的 环境变量&nbsp;<code>PATH</code>&nbsp;指定的目录中，例如&nbsp;<code>/usr/bin</code>、<code>/bin</code>&nbsp;等。<code>bash</code>&nbsp;会在&nbsp;<code>PATH</code>&nbsp;环境变量指定的目录中查找命令，所以直接输入命令名即可执行。</p></div><div class="el-p"><p dir="auto">而&nbsp;<code>./hello</code>&nbsp;表示在当前目录下查找并执行&nbsp;<code>hello</code>&nbsp;程序，<code>./</code>&nbsp;显式指定了当前目录。如果没有在&nbsp;<code>PATH</code>&nbsp;中包含当前目录，就需要使用&nbsp;<code>./</code>&nbsp;来运行当前目录中的程序。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3.2 Process Group and Session(Process Control)" dir="auto" class="heading" id="3.2_Process_Group_and_Session(Process_Control)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 Process Group and Session(Process Control)</h3><div class="heading-children"><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.1 Process Group" dir="auto" class="heading" id="3.2.1_Process_Group"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1 Process Group</h4><div class="heading-children"><div class="el-p"><p dir="auto">进程组是操作系统中用于管理和组织进程的一种机制。一个进程组由一个或多个进程组成，这些进程可以相互协作完成某些任务。进程组的主要目的是为了方便信号的发送和管理。当我们用shell执行命令时，进程组就会被创建。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded"><span class="token function">sleep</span> <span class="token number">100</span> <span class="token comment"># a proc group with only 1 process.</span>

<span class="token builtin class-name">echo</span> <span class="token string">"Hello, World!"</span> <span class="token operator">&gt;</span> temp.txt <span class="token operator">&amp;</span> <span class="token function">cat</span> temp.txt <span class="token comment"># a proc group with 2 processes.</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在Linux和Unix系统中，每个进程都有一个进程组ID，并且有其组标识符<code>PGID</code>。进程组中的所有进程共享同一个<code>PGID</code>。通常而言，<code>fork()</code>父进程和子进程在一个进程组中，进程组的ID是组长的ID。我们可以通过<code>getpgid(pid_t pid)</code>来获取指定进程的进程组ID。</p></div><div class="el-p"><p dir="auto">子进程除了加入父进程的进程组外，还可以创建或加入其他的进程组。我们通过<code>setpgid(pid_t pid, pid_t pgid)</code>来设置指定进程的进程组ID，如果<code>pid</code>参数为0，则使用调用者的进程id，如果pgid是0，则由<code>pid</code>指定的进程id作为进程组id。比如<code>setpgid(0, 0);</code>就表示创建一个当前进程为进程组长的进程组。</p></div><div class="el-p"><p dir="auto">进程组的一个常见用途是信号处理。信号会被发生给进程组的全体成员。当用户在终端中按下<code>Ctrl+C</code>时，系统会向前台进程组发送一个中断信号（SIGINT），终止该进程组中的所有进程。此外，进程组还会由于作业控制，因为在shell中，一个进程组通常被看作为一个作业(job)。</p></div><div class="el-p"><p dir="auto">例如，以下代码展示了如何创建一个新的进程组并将子进程加入该进程组：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// fork failed</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Child process</span>
        <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Create a new process group with the child process as the leader</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process: PID = %d, PGID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Child process code here</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Parent process</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Parent process: PID = %d, PGID = %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getpgid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Parent process code here</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">在这个示例中，子进程通过<code>setpgid(0, 0)</code>创建了一个新的进程组，并将自己设置为该进程组的组长。父进程和子进程的进程组ID可以通过<code>getpgid(0)</code>获取。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2.1.0 PGID System Calls" dir="auto" class="heading" id="3.2.1.0_PGID_System_Calls"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1.0 PGID System Calls</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>

<span class="token class-name">pid_t</span> <span class="token function">getpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. pid: Process ID of the target process. If pid is 0, getpgid() returns the PGID of the calling process.

Return value:
	- On success, returns the PGID of the specified process.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> pgid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. pid: Process ID of the target process. If pid is 0, setpgid() sets the PGID of the calling process.
	2. pgid: Process Group ID to be assigned. If pgid is 0, the PGID is set to the PID of the process specified by pid.

Return value:
	- On success, returns 0.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.2 Session" dir="auto" class="heading" id="3.2.2_Session"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.2 Session</h4><div class="heading-children"><div class="el-p"><p dir="auto">几个进程组又可以组成一个会话。会话中的所有进程都拥有相同的会话ID，会话ID是session leader的进程组ID，保存在task_struct中的session成员中。一个会话中有一个前台进程组，剩下的都作为后台进程组存在。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20250128013013.png" src="Pasted image 20250128013013.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20250128013013.png" src="congzhi's-os-series/pics/pasted-image-20250128013013.png"></span><br>
前台任务会阻塞当前会话，而后台任务不会阻塞当前会话。我们可以在shell命令后面加入<code>&amp;</code>来将进程组作为后台任务运行。只有前台进程组中的进程可以读写终端，而后台进程组中的进程只能写终端，不能读终端。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded"><span class="token function">sleep</span> <span class="token number">5</span>
<span class="token comment"># You cannot do anything before 5s passed.</span>

<span class="token function">sleep</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token comment"># background proc group</span>
<span class="token comment"># You can do anything here.</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">此外，当你使用ctrl+C发生终止信号（下节课会了解到）时，信号只会发送给前台进程组的所有进程，而后台进程组中的进程不会受影响。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2.2.0 pgrp System Calls" dir="auto" class="heading" id="3.2.2.0_pgrp_System_Calls"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.2.0 pgrp System Calls</h5><div class="heading-children"><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>

<span class="token class-name">pid_t</span> <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters: None.

Return value:
	- On success, returns the PGID of the calling process.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">setpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters: None.

Return value:
	- On success, returns 0.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pid_t</span> <span class="token function">getsid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. pid: Process ID of the target process. If pid is 0, getsid() returns the SID of the calling process.

Return value:
	- On success, returns the SID of the specified process.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pid_t</span> <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters: None.

Return value:
	- On success, returns the SID of the calling process.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pid_t</span> <span class="token function">tcgetpgrp</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. fd: File descriptor of the terminal.

Return value:
	- On success, returns the PGID of the foreground process group associated with the terminal.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">tcsetpgrp</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">pid_t</span> pgrp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. fd: File descriptor of the terminal.
	2. pgrp: Process Group ID to be set as the foreground process group.

Return value:
	- On success, returns 0.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pid_t</span> <span class="token function">tcgetsid</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. fd: File descriptor of the terminal.

Return value:
	- On success, returns the SID of the session leader for the terminal.
	- On failure, returns -1 and sets errno to indicate the error.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2.3 Terminal" dir="auto" class="heading" id="3.2.3_Terminal"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.3 Terminal</h4><div class="heading-children"><div class="el-p"><p dir="auto">终端用于绑定一个会话，作为其控制台使用。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第四课 Orphans and Zombies" dir="auto" class="heading" id="第四课_Orphans_and_Zombies"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第四课 Orphans and Zombies</h2><div class="heading-children"><div class="el-h3 heading-wrapper"><h3 data-heading="4.1 Orphan Process" dir="auto" class="heading" id="4.1_Orphan_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 Orphan Process</h3><div class="heading-children"><div class="el-p"><p dir="auto">如果父进程先于子进程结束终止，那么子进程就会变成孤儿进程。孤儿进程会被进程号为1的进程（<code>init</code>和<code>systemd</code>）接管，成为它们的子进程。孤儿进程并不会对系统造成直接的危害，操作系统会在孤儿进程运行完毕之后回收进程资源。但是，我们仍然有义务给孤儿进程一些关爱。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018205838.png" src="Pasted image 20241018205838.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018205838.png" src="congzhi's-os-series/pics/pasted-image-20241018205838.png"></span></p></div><div class="el-p"><p dir="auto">虽然init进程会接管孤儿进程，但是大量的孤儿进程会增加init进程的负担。而且孤儿进程可能会使调试变得复杂。为了更美好的明天，我们应尽量避免孤儿进程的产生。如果孤儿进程并不关键，我们可以用<code>kill -SIGKILL [PID]</code>杀死孤儿进程。(ꈨຶꎁꈨຶ)۶”</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4.2 Zombie Process" dir="auto" class="heading" id="4.2_Zombie_Process"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 Zombie Process</h3><div class="heading-children"><div class="el-p"><p dir="auto">当子进程先于父进程终止但父进程尚未调用&nbsp;<code>wait()</code>&nbsp;系统调用时，子进程会变成僵尸进程。僵尸进程保留在系统中，直到父进程读取其退出状态。如果父进程终止前没有读取其状态，僵尸进程占用的进程表项资源就会一直被其霸占。特别是在发生&nbsp;fork&nbsp;bomb&nbsp;的情况下，这种情况会变得尤为危险，因为进程表项的数量是有限的（通常为&nbsp;65536&nbsp;项）。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018203144.png" src="Pasted image 20241018203144.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018203144.png" src="congzhi's-os-series/pics/pasted-image-20241018203144.png"></span></p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.1 `wait()` System Call" dir="auto" class="heading" id="4.2.1_`wait()`_System_Call"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 <code>wait()</code> System Call</h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>wait()</code>系统调用会阻塞父进程，知道任意一个子进程终止。当子进程终止，<code>wait()</code>会返回子进程的PID，子进程的退出状态会被存储到父进程提供的地址中。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters: None.

Return value:
	- On success: Returns the process ID (PID) of the terminated child process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* 
Parameters:
	1. pid: The process ID of the child process to wait for. If pid is -1, wait for any child process.
	2. status: Pointer to an integer where the exit status of the child process will be stored.
	3. options: Options to modify the behavior of waitpid (e.g., WNOHANG).

Return value:
	- On success: Returns the process ID (PID) of the terminated child process.
	- On failure: Returns -1 and sets errno appropriately.
*/</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018204321.png" src="Pasted image 20241018204321.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018204321.png" src="congzhi's-os-series/pics/pasted-image-20241018204321.png"></span></p></div><div class="el-p"><p dir="auto">当子进程用<code>exit()</code>系统调用终止执行后，内核会给父进程发送一个<strong>SIGCHLD</strong>信号，理想情况下，父进程应当读取子进程的信息并删除子进程的进程表项(process entry)。所以其实每个子进程执行结束都会变成僵尸进程，保留最小退出信息。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018205735.png" src="Pasted image 20241018205735.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018205735.png" src="congzhi's-os-series/pics/pasted-image-20241018205735.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.2 Fork Bomb : An Extreme Case" dir="auto" class="heading" id="4.2.2_Fork_Bomb_:_An_Extreme_Case"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 Fork Bomb : An Extreme Case</h4><div class="heading-children"><div class="el-p"><p dir="auto">下面是一个fork炸弹，尽管在运行时不会产生僵尸进程，但是进程会源源不断地产生子进程，子进程又会源源不断的产生子进程，不一会儿你就会发现系统卡死了。这时，系统资源耗尽，无法再启动新进程，现有的进程可能会很慢甚至无法响应。</p></div><div class="el-pre"><pre class="language-cpp" tabindex="0"><code data-line="0" class="language-cpp is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
      <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20241018202903.png" src="Pasted image 20241018202903.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20241018202903.png" src="congzhi's-os-series/pics/pasted-image-20241018202903.png"></span></p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2.3 Zombie Maker" dir="auto" class="heading" id="4.2.3_Zombie_Maker"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.3 Zombie Maker</h4><div class="heading-children"><div class="el-p"><p dir="auto">通过对上面的fork炸弹做一些修改，你可以用<code>top</code>命令来直观地查看该进程所产生的僵尸进程。这个例子中的子进程将不会再产生子进程，因而不会产生上面进程数量的指数爆炸，更加安全一些。每隔一秒，父进程就会fork一次，子进程会迅速结束并变成僵尸进程。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	        <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		    <span class="token comment">// wait(NULL);</span>
		    <span class="token comment">// printf("Child cleanup!\n");</span>
	        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"A zombie is made.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们前面说过，僵尸进程会占用系统的进程表项资源，而且这种资源是有限的。当所有PIDs都被僵尸进程霸占后，我们将不能够再创建新进程。在这种极端的情况下，我们只能够重启系统了。那如何解决这些僵尸进程呢？</p></div><div class="el-p"><p dir="auto">最好的解决方案当然是编写正确的程序，确保子进程退出后父进程读取其进程表项。然而，犯错有时是难免的。在这个例子中，我们可以直接终止父进程，这样 <code>init</code> 进程会接管并清理掉这些僵尸进程。然而在实际中，我们并不能直接关闭服务器（用户还等着服务器提供服务呢），因此需要手动清理偶尔产生的僵尸进程。在学习信号时我们会讲到。</p></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="第x课 SIGCHILD" dir="auto" class="heading" id="第x课_SIGCHILD"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>第x课 SIGCHILD</h2><div class="heading-children"><div class="el-hr"><hr></div><div class="el-p"><p dir="auto">这里我们简单了解一下信号，为如何用信号处理僵尸进程做铺垫。作为进程间通信的一部分，我们将在进程间通信中详细探讨信号。</p></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.1 POSIX Signals" dir="auto" class="heading" id="x.1_POSIX_Signals"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1 POSIX Signals</h3><div class="heading-children"><div class="el-p"><p dir="auto">每个发送给进程的信号都有相应默认的处理程序(handler)。如果进程自己没有为特定信号注册相应的处理程序，那么收到信号时，就会执行默认的处理程序。下面举例了一些常用的 POSIX.1-1990 标准下的信号：</p></div><div class="el-table" dir="ltr" style="overflow-x: auto;"><table>
<thead>
<tr>
<th align="center" dir="ltr">Signal</th>
<th align="center" dir="ltr">Comment</th>
<th align="center" dir="ltr">Value</th>
<th align="center" dir="ltr">Action</th>
<th align="center" dir="ltr">Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" dir="ltr">SIGHUP</td>
<td align="center" dir="ltr">Hang-up detected</td>
<td align="center" dir="auto">1</td>
<td align="center" dir="ltr">Term</td>
<td align="center" dir="ltr">Terninate process</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGINT</td>
<td align="center" dir="ltr">Keyboard interrupt (Ctrl+C)</td>
<td align="center" dir="auto">2</td>
<td align="center" dir="ltr">Term</td>
<td align="center" dir="ltr">Terninate process</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGQUIT</td>
<td align="center" dir="ltr">Quit form keyboard</td>
<td align="center" dir="auto">3</td>
<td align="center" dir="ltr">Core</td>
<td align="center" dir="ltr">Terminate and dump debug info</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGILL</td>
<td align="center" dir="ltr">Illegal instruction</td>
<td align="center" dir="auto">4</td>
<td align="center" dir="ltr">Core</td>
<td align="center" dir="ltr">Terminate and dump debug info</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGKILL</td>
<td align="center" dir="ltr">Kill signal</td>
<td align="center" dir="auto">9</td>
<td align="center" dir="ltr">Term</td>
<td align="center" dir="ltr">Terminate process</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGSEGV</td>
<td align="center" dir="ltr">Segmentation fault</td>
<td align="center" dir="auto">11</td>
<td align="center" dir="ltr">Core</td>
<td align="center" dir="ltr">Terminate and dump debug info</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGTERM</td>
<td align="center" dir="ltr">Terminatation signal</td>
<td align="center" dir="auto">15</td>
<td align="center" dir="ltr">Term</td>
<td align="center" dir="ltr">Terminate process</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGCHLD</td>
<td align="center" dir="ltr">Child stopped or terminated</td>
<td align="center" dir="auto">20, 17, 18</td>
<td align="center" dir="ltr">Ign</td>
<td align="center" dir="ltr">Ignore</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGCONT</td>
<td align="center" dir="ltr">Continue if stopped</td>
<td align="center" dir="auto">19, 18,  25</td>
<td align="center" dir="ltr">Cont</td>
<td align="center" dir="ltr">Continue if process stopped</td>
</tr>
<tr>
<td align="center" dir="ltr">SIGSTOP</td>
<td align="center" dir="ltr">Stop process</td>
<td align="center" dir="auto">18, 20, 24</td>
<td align="center" dir="ltr">Stop</td>
<td align="center" dir="ltr">Stop process</td>
</tr>
</tbody>
</table></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.1 Handling Signals" dir="auto" class="heading" id="x.1.1_Handling_Signals"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.1 Handling Signals</h4><div class="heading-children"><div class="el-p"><p dir="auto">如果进程想选择特立独行，想要接收到信号之后执行自定义的处理程序，对于大多数信号而言，这样是可行的，这样可以在信号触发时执行特定的逻辑。例如，当按下 <code>Ctrl+C</code> (SIGINT 信号) 时，进程可以执行一些清理操作或记录日志，而不仅仅是简单地终止进程。</p></div><div class="el-p"><p dir="auto">对于任何事件发生的信号，信号都必须被响应处理，那怕在处理程序中什么都不做。此外，我们有两个特殊的信号 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 不可以被捕获、阻塞或忽略。<code>SIGKILL</code> 信号用于强制终止进程，而 <code>SIGSTOP</code> 信号用于停止进程的执行。无论进程如何设置信号处理程序，这两个信号都会被内核直接处理，以确保系统能够对不响应的进程进行强制干预。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.1.2 Taste the Blood" dir="auto" class="heading" id="x.1.2_Taste_the_Blood"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.1.2 Taste the Blood</h4><div class="heading-children"><div class="el-p"><p dir="auto">在命令行界面，我们常用 <code>kill [PID]</code> 命令来杀掉一个 PID 进程号的进程。通常情况下，使用 <code>kill 8080</code> 这样的命令会向8080号进程发送一个 <code>SIGHUP</code> 的信号，默认情况下，这个进程就会被终止（当然你可以注册另外的处理程序来进行额外的善后工作）。</p></div><div class="el-p"><p dir="auto">如果进程仍然阻塞，你可以用 <code>kill -9 8080</code> 来强制终止这个进程。这个 <code>-9</code> 参数就是向进程发送9号信号（<code>SIGKILL</code>），而默认下是1号信号（<code>SIGHUP</code>）。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="x.2 Zombocalypse Cleanup" dir="auto" class="heading" id="x.2_Zombocalypse_Cleanup"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2 Zombocalypse Cleanup</h3><div class="heading-children"><div class="el-p"><p dir="auto">在子进程退出时，父进程需要读取其进程表项以避免僵尸进程的出现。然而，尽管子进程终止后会像父进程发送<code>SIGCHILD</code>的信号，但是我们在上面看到，对于这个信号，默认的处理方式却是忽略。要避免僵尸进程的产生，我们的想法是在父进程收到子进程退出时发来的<code>SIGCHILD</code>信号后读取相应的进程表项。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.2.1 Lock and Load" dir="auto" class="heading" id="x.2.1_Lock_and_Load"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2.1 Lock and Load</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们用下面的函数注册信号的服务例程，其中<strong>signo</strong>是想要捕获的信号号，后面的<strong>sig_handler</strong>是对该信号的服务例程。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// This is a void handler</span>
<span class="token keyword">void</span> <span class="token function">sig_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">/* Handle the signal in some way. */</span>
<span class="token punctuation">}</span>
<span class="token comment">// Register the handler</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>sig_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.2.2 Fire!!!" dir="auto" class="heading" id="x.2.2_Fire!!!"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2.2 Fire!!!</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们前面说过，要避免僵尸进程，我们就需要使父进程<code>wait()</code>子进程，但这一过程会阻塞父进程，这是我们不想要看到的。其实如果父进程结束，这些僵尸进程会被进程号为1的进程接管并自动释放资源，但是父进程可能是服务器，需要一直运行下去。</p></div><div class="el-p"><p dir="auto">我们知道，当子进程运行结束，子进程就会给父进程发送SIGCHLD信号。我们可以让父进程捕捉这样的信号，然后在其中调用<code>wait()</code>系统调用，从而释放子进程的进程表项，即杀死僵尸进程：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">SIGCHLD_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Released in SIGCHLD_handler!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> SIGCHLD_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from child process.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//sleep(5); // Nonsense, program will wake up after handler being called.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">运行程序后，打开另一个终端。用命令<code>ps -aux | grep 'Z'</code>查看当前系统下的僵尸进程，应当每隔1秒钟就多一个僵尸进程。当我们用ctrl+c给进程发送<code>SIGINT</code>终止进程时，你会看到这些僵尸进程的资源都被释放掉了。如果你想子程序退出后立即释放，就将上面的注释删掉。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="x.2.3 `sigaction`: Standardized Signal Handling" dir="auto" class="heading" id="x.2.3_`sigaction`:_Standardized_Signal_Handling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>x.2.3 <code>sigaction</code>: Standardized Signal Handling</h4><div class="heading-children"><div class="el-p"><p dir="auto"><code>sigaction</code>是一个规范的、扩展性更好的信号处理框架。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">SIGCHLD_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Released in SIGCHLD_handler!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">SIGINT_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> signo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Released in SIGINT_handler!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>

    sa<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> SIGCHLD_handler<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sa<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> SA_RESTART<span class="token punctuation">;</span>
    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    sa<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> SIGINT_handler<span class="token punctuation">;</span>
    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    sa<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello from child process.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child created!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// sleep(5); // Nonsense, program will wake up after handler being called.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="mod-footer mod-ui"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#6. Processing The Processes"><div class="tree-item-contents heading-link" heading-name="
Processing The Processes
"><span class="tree-item-title">Processing The Processes</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#第一课_Processes"><div class="tree-item-contents heading-link" heading-name="第一课 Processes"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第一课 Processes</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1_Program_and_Process"><div class="tree-item-contents heading-link" heading-name="1.1 Program and Process"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1 Program and Process</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.1_Executable_Files"><div class="tree-item-contents heading-link" heading-name="1.1.1 Executable Files"><span class="tree-item-title">1.1.1 Executable Files</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.2_ELF_Layout_(x64)"><div class="tree-item-contents heading-link" heading-name="1.1.2 ELF Layout (x64)"><span class="tree-item-title">1.1.2 ELF Layout (x64)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.3_ELF:_Relocatable_File"><div class="tree-item-contents heading-link" heading-name="1.1.3 ELF: Relocatable File"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.3 ELF: Relocatable File</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.3.1_ELF_Header"><div class="tree-item-contents heading-link" heading-name="1.1.3.1 ELF Header"><span class="tree-item-title">1.1.3.1 ELF Header</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.3.2_Program_Header_Table"><div class="tree-item-contents heading-link" heading-name="1.1.3.2 Program Header Table"><span class="tree-item-title">1.1.3.2 Program Header Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.3.3_Sections_and_Section_Header_Table"><div class="tree-item-contents heading-link" heading-name="1.1.3.3 Sections and Section Header Table"><span class="tree-item-title">1.1.3.3 Sections and Section Header Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.3.4_File_Structure_Layout"><div class="tree-item-contents heading-link" heading-name="1.1.3.4 File Structure Layout"><span class="tree-item-title">1.1.3.4 File Structure Layout</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.4_ELF:_Position-Independent_Executable_File"><div class="tree-item-contents heading-link" heading-name="1.1.4 ELF: Position-Independent Executable File"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.1.4 ELF: Position-Independent Executable File</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.4.1_ELF_Header"><div class="tree-item-contents heading-link" heading-name="1.1.4.1 ELF Header"><span class="tree-item-title">1.1.4.1 ELF Header</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.1.4.2_Program_Header_Table"><div class="tree-item-contents heading-link" heading-name="1.1.4.2 Program Header Table"><span class="tree-item-title">1.1.4.2 Program Header Table</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.2_Program_Loading"><div class="tree-item-contents heading-link" heading-name="1.2 Program Loading"><span class="tree-item-title">1.2 Program Loading</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3_Process"><div class="tree-item-contents heading-link" heading-name="1.3 Process"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3 Process</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.1_Process_Control_Block"><div class="tree-item-contents heading-link" heading-name="1.3.1 Process Control Block"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3.1 Process Control Block</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.1.1_task_struct"><div class="tree-item-contents heading-link" heading-name="1.3.1.1 task_struct"><span class="tree-item-title">1.3.1.1 task_struct</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.2_Virtual_Memory"><div class="tree-item-contents heading-link" heading-name="1.3.2 Virtual Memory"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3.2 Virtual Memory</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.2.1_Different_Mode,_Different_Space"><div class="tree-item-contents heading-link" heading-name="1.3.2.1 Different Mode, Different Space"><span class="tree-item-title">1.3.2.1 Different Mode, Different Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.2.2_User_Space"><div class="tree-item-contents heading-link" heading-name="1.3.2.2 User Space"><span class="tree-item-title">1.3.2.2 User Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.2.3_Kernel_Space"><div class="tree-item-contents heading-link" heading-name="1.3.2.3 Kernel Space"><span class="tree-item-title">1.3.2.3 Kernel Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.3_Process_Memory_Layout"><div class="tree-item-contents heading-link" heading-name="1.3.3 Process Memory Layout"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.3.3 Process Memory Layout</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.3.3.1_Get_Your_Hands-on"><div class="tree-item-contents heading-link" heading-name="1.3.3.1 Get Your Hands-on"><span class="tree-item-title">1.3.3.1 Get Your Hands-on</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.4_Stack_Space"><div class="tree-item-contents heading-link" heading-name="1.4 Stack Space"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1.4 Stack Space</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.4.1_Stack_Frame"><div class="tree-item-contents heading-link" heading-name="1.4.1 Stack Frame"><span class="tree-item-title">1.4.1 Stack Frame</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.4.2_Inspect_the_Stack_Space"><div class="tree-item-contents heading-link" heading-name="1.4.2 Inspect the Stack Space"><span class="tree-item-title">1.4.2 Inspect the Stack Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#1.4.3_Stack_Frame_Information"><div class="tree-item-contents heading-link" heading-name="1.4.3 Stack Frame Information"><span class="tree-item-title">1.4.3 Stack Frame Information</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#第二课_Process_States_and_Process_Switching"><div class="tree-item-contents heading-link" heading-name="第二课 Process States and Process Switching"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第二课 Process States and Process Switching</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.1_Process_States"><div class="tree-item-contents heading-link" heading-name="2.1 Process States"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.1 Process States</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.1.1_New"><div class="tree-item-contents heading-link" heading-name="2.1.1 New"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.1.1 New</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.1.1.1_Newborn_Processes_in_System_Booting"><div class="tree-item-contents heading-link" heading-name="2.1.1.1 Newborn Processes in System Booting"><span class="tree-item-title">2.1.1.1 Newborn Processes in System Booting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.1.1.2_`fork()`"><div class="tree-item-contents heading-link" heading-name="2.1.1.2 `fork()`"><span class="tree-item-title">2.1.1.2 <code>fork()</code></span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.1.1.3_You're_the_Master"><div class="tree-item-contents heading-link" heading-name="2.1.1.3 You're the Master"><span class="tree-item-title">2.1.1.3 You're the Master</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2_Terminated"><div class="tree-item-contents heading-link" heading-name="2.2 Terminated"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.2 Terminated</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2.1_Normal_Exit"><div class="tree-item-contents heading-link" heading-name="2.2.1 Normal Exit"><span class="tree-item-title">2.2.1 Normal Exit</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2.2_Error_Exit（`exit()`）"><div class="tree-item-contents heading-link" heading-name="2.2.2 Error Exit（`exit()`）"><span class="tree-item-title">2.2.2 Error Exit（<code>exit()</code>）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2.3_Fatal_Error"><div class="tree-item-contents heading-link" heading-name="2.2.3 Fatal Error"><span class="tree-item-title">2.2.3 Fatal Error</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2.4_Killed_by_Others"><div class="tree-item-contents heading-link" heading-name="2.2.4 Killed by Others"><span class="tree-item-title">2.2.4 Killed by Others</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.2.5_Process_Return_Code"><div class="tree-item-contents heading-link" heading-name="2.2.5 Process Return Code"><span class="tree-item-title">2.2.5 Process Return Code</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3_Process_Switching"><div class="tree-item-contents heading-link" heading-name="2.3 Process Switching"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3 Process Switching</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3.1_Five-State_Model"><div class="tree-item-contents heading-link" heading-name="2.3.1 Five-State Model"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3.1 Five-State Model</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3.1.1_State_Switching_in_Five-State_Model"><div class="tree-item-contents heading-link" heading-name="2.3.1.1 State Switching in Five-State Model"><span class="tree-item-title">2.3.1.1 State Switching in Five-State Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3.1.2_Ready_Queue_and_Wait_Queue"><div class="tree-item-contents heading-link" heading-name="2.3.1.2 Ready Queue and Wait Queue"><span class="tree-item-title">2.3.1.2 Ready Queue and Wait Queue</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3.2_Seven-States_Model"><div class="tree-item-contents heading-link" heading-name="2.3.2 Seven-States Model"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.3.2 Seven-States Model</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.3.2.1_Swapping_and_Suspend"><div class="tree-item-contents heading-link" heading-name="2.3.2.1 Swapping and Suspend"><span class="tree-item-title">2.3.2.1 Swapping and Suspend</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4_Context_Switch"><div class="tree-item-contents heading-link" heading-name="2.4 Context Switch"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.4 Context Switch</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.1_CPU_Scheduling_and_Context_Switch"><div class="tree-item-contents heading-link" heading-name="2.4.1 CPU Scheduling and Context Switch"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.4.1 CPU Scheduling and Context Switch</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.1.1_CPU_Scheduling"><div class="tree-item-contents heading-link" heading-name="2.4.1.1 CPU Scheduling"><span class="tree-item-title">2.4.1.1 CPU Scheduling</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.1.2_Process_Contexts"><div class="tree-item-contents heading-link" heading-name="2.4.1.2 Process Contexts"><span class="tree-item-title">2.4.1.2 Process Contexts</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.1.3_Context_Switch"><div class="tree-item-contents heading-link" heading-name="2.4.1.3 Context Switch"><span class="tree-item-title">2.4.1.3 Context Switch</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.2_Switching_Costs"><div class="tree-item-contents heading-link" heading-name="2.4.2 Switching Costs"><span class="tree-item-title">2.4.2 Switching Costs</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.4.3_Switching_Triggers"><div class="tree-item-contents heading-link" heading-name="2.4.3 Switching Triggers"><span class="tree-item-title">2.4.3 Switching Triggers</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x_Moving_Beyond:_Making_New_Processes"><div class="tree-item-contents heading-link" heading-name="2.x Moving Beyond: Making New Processes"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.x Moving Beyond: Making New Processes</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.1_Fork_and_Execute"><div class="tree-item-contents heading-link" heading-name="2.x.1 Fork and Execute"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.x.1 Fork and Execute</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.1.1_Copy-On-Write_Sharing"><div class="tree-item-contents heading-link" heading-name="2.x.1.1 Copy-On-Write Sharing"><span class="tree-item-title">2.x.1.1 Copy-On-Write Sharing</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.1.2_New_Process_with_New_Program"><div class="tree-item-contents heading-link" heading-name="2.x.1.2 New Process with New Program"><span class="tree-item-title">2.x.1.2 New Process with New Program</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.2_POSIX_Spawn"><div class="tree-item-contents heading-link" heading-name="2.x.2 POSIX Spawn"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.x.2 POSIX Spawn</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.2.1_Fork_vs._Spawn"><div class="tree-item-contents heading-link" heading-name="2.x.2.1 Fork vs. Spawn"><span class="tree-item-title">2.x.2.1 Fork vs. Spawn</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.2.2_What_Spawn_Brings?"><div class="tree-item-contents heading-link" heading-name="2.x.2.2 What Spawn Brings?"><span class="tree-item-title">2.x.2.2 What Spawn Brings?</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.3_Clone_Syscall"><div class="tree-item-contents heading-link" heading-name="2.x.3 Clone Syscall"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2.x.3 Clone Syscall</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.3.1_Clone3_Syscall"><div class="tree-item-contents heading-link" heading-name="2.x.3.1 Clone3 Syscall"><span class="tree-item-title">2.x.3.1 Clone3 Syscall</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.3.2_Clone_Attributes"><div class="tree-item-contents heading-link" heading-name="2.x.3.2 Clone Attributes"><span class="tree-item-title">2.x.3.2 Clone Attributes</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#2.x.3.3_Here_Comes_the_Clone_Version"><div class="tree-item-contents heading-link" heading-name="2.x.3.3 Here Comes the Clone Version"><span class="tree-item-title">2.x.3.3 Here Comes the Clone Version</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#第三课_Process_Organization"><div class="tree-item-contents heading-link" heading-name="第三课 Process Organization"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第三课 Process Organization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.1_Process_Organization"><div class="tree-item-contents heading-link" heading-name="3.1 Process Organization"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 Process Organization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.1.1_Windows"><div class="tree-item-contents heading-link" heading-name="3.1.1 Windows"><span class="tree-item-title">3.1.1 Windows</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.1.2_Linux_Process_Tree"><div class="tree-item-contents heading-link" heading-name="3.1.2 Linux Process Tree"><span class="tree-item-title">3.1.2 Linux Process Tree</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2_Process_Group_and_Session(Process_Control)"><div class="tree-item-contents heading-link" heading-name="3.2 Process Group and Session(Process Control)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2 Process Group and Session(Process Control)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2.1_Process_Group"><div class="tree-item-contents heading-link" heading-name="3.2.1 Process Group"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2.1 Process Group</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2.1.0_PGID_System_Calls"><div class="tree-item-contents heading-link" heading-name="3.2.1.0 PGID System Calls"><span class="tree-item-title">3.2.1.0 PGID System Calls</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2.2_Session"><div class="tree-item-contents heading-link" heading-name="3.2.2 Session"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2.2 Session</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2.2.0_pgrp_System_Calls"><div class="tree-item-contents heading-link" heading-name="3.2.2.0 pgrp System Calls"><span class="tree-item-title">3.2.2.0 pgrp System Calls</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#3.2.3_Terminal"><div class="tree-item-contents heading-link" heading-name="3.2.3 Terminal"><span class="tree-item-title">3.2.3 Terminal</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#第四课_Orphans_and_Zombies"><div class="tree-item-contents heading-link" heading-name="第四课 Orphans and Zombies"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第四课 Orphans and Zombies</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#4.1_Orphan_Process"><div class="tree-item-contents heading-link" heading-name="4.1 Orphan Process"><span class="tree-item-title">4.1 Orphan Process</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#4.2_Zombie_Process"><div class="tree-item-contents heading-link" heading-name="4.2 Zombie Process"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2 Zombie Process</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#4.2.1_`wait()`_System_Call"><div class="tree-item-contents heading-link" heading-name="4.2.1 `wait()` System Call"><span class="tree-item-title">4.2.1 <code>wait()</code> System Call</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#4.2.2_Fork_Bomb_:_An_Extreme_Case"><div class="tree-item-contents heading-link" heading-name="4.2.2 Fork Bomb : An Extreme Case"><span class="tree-item-title">4.2.2 Fork Bomb : An Extreme Case</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#4.2.3_Zombie_Maker"><div class="tree-item-contents heading-link" heading-name="4.2.3 Zombie Maker"><span class="tree-item-title">4.2.3 Zombie Maker</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#第x课_SIGCHILD"><div class="tree-item-contents heading-link" heading-name="第x课 SIGCHILD"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">第x课 SIGCHILD</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.1_POSIX_Signals"><div class="tree-item-contents heading-link" heading-name="x.1 POSIX Signals"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.1 POSIX Signals</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.1.1_Handling_Signals"><div class="tree-item-contents heading-link" heading-name="x.1.1 Handling Signals"><span class="tree-item-title">x.1.1 Handling Signals</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.1.2_Taste_the_Blood"><div class="tree-item-contents heading-link" heading-name="x.1.2 Taste the Blood"><span class="tree-item-title">x.1.2 Taste the Blood</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.2_Zombocalypse_Cleanup"><div class="tree-item-contents heading-link" heading-name="x.2 Zombocalypse Cleanup"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">x.2 Zombocalypse Cleanup</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.2.1_Lock_and_Load"><div class="tree-item-contents heading-link" heading-name="x.2.1 Lock and Load"><span class="tree-item-title">x.2.1 Lock and Load</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.2.2_Fire!!!"><div class="tree-item-contents heading-link" heading-name="x.2.2 Fire!!!"><span class="tree-item-title">x.2.2 Fire!!!</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="congzhi's-os-series\6.-processing-the-processes.html#x.2.3_`sigaction`:_Standardized_Signal_Handling"><div class="tree-item-contents heading-link" heading-name="x.2.3 `sigaction`: Standardized Signal Handling"><span class="tree-item-title">x.2.3 <code>sigaction</code>: Standardized Signal Handling</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>