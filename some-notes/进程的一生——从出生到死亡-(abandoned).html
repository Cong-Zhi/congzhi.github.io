<!DOCTYPE html> <html><head>
		<title>进程的一生——从出生到死亡 (Abandoned)</title>
		<base href="../">
		<meta id="root-path" root-path="../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Congzhi's Notes Vault - 进程的一生——从出生到死亡 (Abandoned)">
		<meta property="og:title" content="进程的一生——从出生到死亡 (Abandoned)">
		<meta property="og:description" content="Congzhi's Notes Vault - 进程的一生——从出生到死亡 (Abandoned)">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://congzhi.wiki/some-notes/进程的一生——从出生到死亡-(abandoned).html">
		<meta property="og:image" content="https://congzhi.wiki/some-notes/pics/pasted-image-20240916212548.png">
		<meta property="og:site_name" content="Congzhi's Notes Vault">
		<meta name="author" content="Congzhi"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://congzhi.wiki/lib/rss.xml"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-light show-inline-title show-ribbon"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles">mjx-mspace{display:inline-block;text-align:left}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"×"}mjx-c.mjx-c1D44C.TEX-I::before{padding:.683em .763em 0 0;content:"Y"}mjx-c.mjx-c2061::before{padding:0;content:""}mjx-c.mjx-c4B::before{padding:.683em .778em 0 0;content:"K"}mjx-c.mjx-c46::before{padding:.68em .653em 0 0;content:"F"}mjx-c.mjx-c7A::before{padding:.431em .444em 0 0;content:"z"}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"×"}mjx-c.mjx-c4D::before{padding:.683em .917em 0 0;content:"M"}mjx-c.mjx-c1D43A.TEX-I::before{padding:.705em .786em .022em 0;content:"G"}mjx-c.mjx-c70::before{padding:.442em .556em .194em 0;content:"p"}mjx-c.mjx-cB1::before{padding:.666em .778em 0 0;content:"±"}mjx-c.mjx-c5F::before{padding:0 .5em .062em 0;content:"_"}mjx-mtable{display:inline-block;text-align:center;vertical-align:.25em;position:relative;box-sizing:border-box;border-spacing:0px;border-collapse:collapse}mjx-mstyle[size="s"] mjx-mtable{vertical-align:.354em}mjx-labels{position:absolute;left:0;top:0}mjx-table{display:inline-block;vertical-align:-.5ex;box-sizing:border-box}mjx-table>mjx-itable{vertical-align:middle;text-align:left;box-sizing:border-box}mjx-labels>mjx-itable{position:absolute;top:0}mjx-mtable[justify=left]{text-align:left}mjx-mtable[justify=right]{text-align:right}mjx-mtable[justify=left][side=left]{padding-right:0!important}mjx-mtable[justify=left][side=right]{padding-left:0!important}mjx-mtable[justify=right][side=left]{padding-right:0!important}mjx-mtable[justify=right][side=right]{padding-left:0!important}mjx-mtable[align]{vertical-align:baseline}mjx-mtable[align=top]>mjx-table{vertical-align:top}mjx-mtable[align=bottom]>mjx-table{vertical-align:bottom}mjx-mtable[side=right] mjx-labels{min-width:100%}mjx-mtr{display:table-row;text-align:left}mjx-mtr[rowalign=top]>mjx-mtd{vertical-align:top}mjx-mtr[rowalign=center]>mjx-mtd{vertical-align:middle}mjx-mtr[rowalign=bottom]>mjx-mtd{vertical-align:bottom}mjx-mtr[rowalign=baseline]>mjx-mtd{vertical-align:baseline}mjx-mtr[rowalign=axis]>mjx-mtd{vertical-align:.25em}mjx-mtd{display:table-cell;text-align:center;padding:.215em .4em}mjx-mtd:first-child{padding-left:0}mjx-mtd:last-child{padding-right:0}mjx-mtable>*>mjx-itable>:first-child>mjx-mtd{padding-top:0}mjx-mtable>*>mjx-itable>:last-child>mjx-mtd{padding-bottom:0}mjx-tstrut{display:inline-block;height:1em;vertical-align:-.25em}mjx-labels[align=left]>mjx-mtr>mjx-mtd{text-align:left}mjx-labels[align=right]>mjx-mtr>mjx-mtd{text-align:right}mjx-mtd[extra]{padding:0}mjx-mtd[rowalign=top]{vertical-align:top}mjx-mtd[rowalign=center]{vertical-align:middle}mjx-mtd[rowalign=bottom]{vertical-align:bottom}mjx-mtd[rowalign=baseline]{vertical-align:baseline}mjx-mtd[rowalign=axis]{vertical-align:.25em}mjx-stretchy-v.mjx-c5B mjx-beg mjx-c::before{content:"⎡";padding:1.154em .667em .645em 0}mjx-stretchy-v.mjx-c5B mjx-ext mjx-c::before{content:"⎢";width:.667em}mjx-stretchy-v.mjx-c5B mjx-end mjx-c::before{content:"⎣";padding:1.155em .667em .644em 0}mjx-stretchy-v.mjx-c5B>mjx-end{margin-top:-1.799em}mjx-stretchy-v.mjx-c5B>mjx-ext{border-top-width:1.769em;border-bottom-width:1.769em}mjx-stretchy-v.mjx-c5D mjx-beg mjx-c::before{content:"⎤";padding:1.154em .667em .645em 0}mjx-stretchy-v.mjx-c5D mjx-ext mjx-c::before{content:"⎥";width:.667em}mjx-stretchy-v.mjx-c5D mjx-end mjx-c::before{content:"⎦";padding:1.155em .667em .644em 0}mjx-stretchy-v.mjx-c5D>mjx-end{margin-top:-1.799em}mjx-stretchy-v.mjx-c5D>mjx-ext{border-top-width:1.769em;border-bottom-width:1.769em}mjx-c.mjx-c1D703.TEX-I::before{padding:.705em .469em .01em 0;content:"θ"}mjx-c.mjx-c1D434.TEX-I::before{padding:.716em .75em 0 0;content:"A"}mjx-c.mjx-c5B::before{padding:.75em .278em .25em 0;content:"["}mjx-c.mjx-c5D::before{padding:.75em .278em .25em 0;content:"]"}mjx-c.mjx-c22EF::before{padding:.31em 1.172em 0 0;content:"⋯"}mjx-c.mjx-c22EE::before{padding:1.3em .278em .03em 0;content:"⋮"}mjx-c.mjx-c22F1::before{padding:1.52em 1.282em 0 0;content:"⋱"}mjx-c.mjx-c1D44A.TEX-I::before{padding:.683em 1.048em .022em 0;content:"W"}mjx-c.mjx-c1D444.TEX-I::before{padding:.704em .791em .194em 0;content:"Q"}mjx-c.mjx-c3E::before{padding:.54em .778em .04em 0;content:">"}mjx-c.mjx-c1D70F.TEX-I::before{padding:.431em .517em .013em 0;content:"τ"}mjx-c.mjx-c1D458.TEX-I::before{padding:.694em .521em .011em 0;content:"k"}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"∑"}mjx-c.mjx-c3C::before{padding:.54em .778em .04em 0;content:"<"}mjx-c.mjx-c44::before{padding:.683em .764em 0 0;content:"D"}mjx-c.mjx-c20::before{padding:0 .25em 0 0;content:" "}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c2D::before{padding:.252em .333em 0 0;content:"-"}mjx-c.mjx-c75::before{padding:.442em .556em .011em 0;content:"u"}mjx-c.mjx-c6B::before{padding:.694em .528em 0 0;content:"k"}mjx-c.mjx-c52::before{padding:.683em .736em .022em 0;content:"R"}mjx-c.mjx-c67::before{padding:.453em .5em .206em 0;content:"g"}mjx-c.mjx-c45::before{padding:.68em .681em 0 0;content:"E"}mjx-c.mjx-c78::before{padding:.431em .528em 0 0;content:"x"}mjx-c.mjx-c220F.TEX-S2::before{padding:.95em 1.278em .45em 0;content:"∏"}mjx-c.mjx-c2264::before{padding:.636em .778em .138em 0;content:"≤"}mjx-c.mjx-c1D457.TEX-I::before{padding:.661em .412em .204em 0;content:"j"}mjx-c.mjx-c1D435.TEX-I::before{padding:.683em .759em 0 0;content:"B"}mjx-c.mjx-c47::before{padding:.705em .785em .022em 0;content:"G"}mjx-c.mjx-c4C::before{padding:.683em .625em 0 0;content:"L"}mjx-c.mjx-c42::before{padding:.683em .708em 0 0;content:"B"}mjx-c.mjx-c41::before{padding:.716em .75em 0 0;content:"A"}mjx-c.mjx-c43::before{padding:.705em .722em .021em 0;content:"C"}mjx-c.mjx-c79::before{padding:.431em .528em .204em 0;content:"y"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c69::before{padding:.669em .278em 0 0;content:"i"}mjx-c.mjx-c6E::before{padding:.442em .556em 0 0;content:"n"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c72::before{padding:.442em .392em 0 0;content:"r"}mjx-c.mjx-c4E::before{padding:.683em .75em 0 0;content:"N"}mjx-c.mjx-c68::before{padding:.694em .556em 0 0;content:"h"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c48::before{padding:.683em .75em 0 0;content:"H"}mjx-c.mjx-c63::before{padding:.448em .444em .011em 0;content:"c"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c53::before{padding:.705em .556em .022em 0;content:"S"}mjx-c.mjx-c54::before{padding:.677em .722em 0 0;content:"T"}mjx-c.mjx-c5A::before{padding:.683em .611em 0 0;content:"Z"}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}mjx-msup{display:inline-block;text-align:left}mjx-c.mjx-c38::before{padding:.666em .5em .022em 0;content:"8"}mjx-c.mjx-c39::before{padding:.666em .5em .022em 0;content:"9"}mjx-c.mjx-c73::before{padding:.448em .394em .011em 0;content:"s"}mjx-c.mjx-c1D448.TEX-I::before{padding:.683em .767em .022em 0;content:"U"}mjx-c.mjx-c37::before{padding:.676em .5em .022em 0;content:"7"}mjx-c.mjx-c1D438.TEX-I::before{padding:.68em .764em 0 0;content:"E"}mjx-c.mjx-c1D6FC.TEX-I::before{padding:.442em .64em .011em 0;content:"α"}mjx-c.mjx-c1D463.TEX-I::before{padding:.443em .485em .011em 0;content:"v"}mjx-c.mjx-c1D6FD.TEX-I::before{padding:.705em .566em .194em 0;content:"β"}mjx-c.mjx-c7C::before{padding:.75em .278em .249em 0;content:"|"}mjx-c.mjx-c1D43C.TEX-I::before{padding:.683em .504em 0 0;content:"I"}mjx-mtext{display:inline-block;text-align:left}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-munderover{display:inline-block;text-align:left}mjx-munderover:not([limits=false]){padding-top:.1em}mjx-munderover:not([limits=false])>*{display:block}mjx-msubsup{display:inline-block;text-align:left}mjx-script{display:inline-block;padding-right:.05em;padding-left:.033em}mjx-script>mjx-spacer{display:block}mjx-c.mjx-c210E.TEX-I::before{padding:.694em .576em .011em 0;content:"h"}mjx-c.mjx-c3A::before{padding:.43em .278em 0 0;content:":"}mjx-c.mjx-c1D464.TEX-I::before{padding:.443em .716em .011em 0;content:"w"}mjx-c.mjx-c1D45A.TEX-I::before{padding:.442em .878em .011em 0;content:"m"}mjx-c.mjx-c1D446.TEX-I::before{padding:.705em .645em .022em 0;content:"S"}mjx-c.mjx-c1D454.TEX-I::before{padding:.442em .477em .205em 0;content:"g"}mjx-c.mjx-c1D453.TEX-I::before{padding:.705em .55em .205em 0;content:"f"}mjx-c.mjx-c1D465.TEX-I::before{padding:.442em .572em .011em 0;content:"x"}mjx-c.mjx-c2217::before{padding:.465em .5em 0 0;content:"∗"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-cA0::before{padding:0 .25em 0 0;content:" "}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}mjx-c.mjx-c2248::before{padding:.483em .778em 0 0;content:"≈"}mjx-c.mjx-c1D449.TEX-I::before{padding:.683em .769em .022em 0;content:"V"}mjx-c.mjx-c1D43F.TEX-I::before{padding:.683em .681em 0 0;content:"L"}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c2265::before{padding:.636em .778em .138em 0;content:"≥"}mjx-c.mjx-c7B::before{padding:.75em .5em .25em 0;content:"{"}mjx-c.mjx-c7D::before{padding:.75em .5em .25em 0;content:"}"}mjx-c.mjx-c1D443.TEX-I::before{padding:.683em .751em 0 0;content:"P"}mjx-c.mjx-c2211.TEX-S1::before{padding:.75em 1.056em .25em 0;content:"∑"}mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}mjx-assistive-mml{top:0;left:0;clip:rect(1px,1px,1px,1px);user-select:none;position:absolute!important;padding:1px 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;letter-spacing:normal;border-collapse:collapse;overflow-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em}mjx-msub{display:inline-block;text-align:left}mjx-texatom{display:inline-block;text-align:left}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scaleX(1)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scaleX(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaleY(1);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mn{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url("lib/fonts/mathjax_zero.woff") format("woff")}@font-face{font-family:MJXTEX;src:url("lib/fonts/mathjax_main-regular.woff") format("woff")}@font-face{font-family:MJXTEX-B;src:url("lib/fonts/mathjax_main-bold.woff") format("woff")}@font-face{font-family:MJXTEX-I;src:url("lib/fonts/mathjax_math-italic.woff") format("woff")}@font-face{font-family:MJXTEX-MI;src:url("lib/fonts/mathjax_main-italic.woff") format("woff")}@font-face{font-family:MJXTEX-BI;src:url("lib/fonts/mathjax_math-bolditalic.woff") format("woff")}@font-face{font-family:MJXTEX-S1;src:url("lib/fonts/mathjax_size1-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S2;src:url("lib/fonts/mathjax_size2-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S3;src:url("lib/fonts/mathjax_size3-regular.woff") format("woff")}@font-face{font-family:MJXTEX-S4;src:url("lib/fonts/mathjax_size4-regular.woff") format("woff")}@font-face{font-family:MJXTEX-A;src:url("lib/fonts/mathjax_ams-regular.woff") format("woff")}@font-face{font-family:MJXTEX-C;src:url("lib/fonts/mathjax_calligraphic-regular.woff") format("woff")}@font-face{font-family:MJXTEX-CB;src:url("lib/fonts/mathjax_calligraphic-bold.woff") format("woff")}@font-face{font-family:MJXTEX-FR;src:url("lib/fonts/mathjax_fraktur-regular.woff") format("woff")}@font-face{font-family:MJXTEX-FRB;src:url("lib/fonts/mathjax_fraktur-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SS;src:url("lib/fonts/mathjax_sansserif-regular.woff") format("woff")}@font-face{font-family:MJXTEX-SSB;src:url("lib/fonts/mathjax_sansserif-bold.woff") format("woff")}@font-face{font-family:MJXTEX-SSI;src:url("lib/fonts/mathjax_sansserif-italic.woff") format("woff")}@font-face{font-family:MJXTEX-SC;src:url("lib/fonts/mathjax_script-regular.woff") format("woff")}@font-face{font-family:MJXTEX-T;src:url("lib/fonts/mathjax_typewriter-regular.woff") format("woff")}@font-face{font-family:MJXTEX-V;src:url("lib/fonts/mathjax_vector-regular.woff") format("woff")}@font-face{font-family:MJXTEX-VB;src:url("lib/fonts/mathjax_vector-bold.woff") format("woff")}mjx-c.mjx-c1D437.TEX-I::before{padding:.683em .828em 0 0;content:"D"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D459.TEX-I::before{padding:.694em .298em .011em 0;content:"l"}mjx-c.mjx-c1D44E.TEX-I::before{padding:.441em .529em .01em 0;content:"a"}mjx-c.mjx-c1D466.TEX-I::before{padding:.442em .49em .205em 0;content:"y"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c1D45D.TEX-I::before{padding:.442em .503em .194em 0;content:"p"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c1D450.TEX-I::before{padding:.442em .433em .011em 0;content:"c"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c1D45E.TEX-I::before{padding:.442em .46em .194em 0;content:"q"}mjx-c.mjx-c1D462.TEX-I::before{padding:.442em .572em .011em 0;content:"u"}mjx-c.mjx-c1D461.TEX-I::before{padding:.626em .361em .011em 0;content:"t"}mjx-c.mjx-c1D460.TEX-I::before{padding:.442em .469em .01em 0;content:"s"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"−"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D445.TEX-I::before{padding:.683em .759em .021em 0;content:"R"}mjx-c.mjx-c1D440.TEX-I::before{padding:.683em 1.051em 0 0;content:"M"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-c.mjx-c1D439.TEX-I::before{padding:.68em .749em 0 0;content:"F"}mjx-c.mjx-c2F::before{padding:.75em .5em .25em 0;content:"/"}mjx-c.mjx-c1D44F.TEX-I::before{padding:.694em .429em .011em 0;content:"b"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c1D43E.TEX-I::before{padding:.683em .889em 0 0;content:"K"}mjx-c.mjx-c1D43B.TEX-I::before{padding:.683em .888em 0 0;content:"H"}</style><pre class="frontmatter language-yaml" tabindex="0" style="display: none;"><code class="language-yaml is-loaded"><span class="token key atrule">tags</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> Notes</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="进程的一生——从出生到死亡 (Abandoned)"><p dir="auto">进程的一生——从出生到死亡 (Abandoned)</p></h1><div class="el-h2 heading-wrapper"><h2 data-heading="〇：先导知识" dir="auto" class="heading" id="〇：先导知识"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>〇：先导知识</h2><div class="heading-children"><div class="el-h3 heading-wrapper"><h3 data-heading="1. 存储程序的工作方式" dir="auto" class="heading" id="1._存储程序的工作方式"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. 存储程序的工作方式</h3><div class="heading-children"><div class="el-p"><p dir="auto">存储程序的工作方式是现代计算机运行的根基之一，它由冯诺依曼在1946年提出。它的核心思想是将用于解决问题的程序和数据一起存储在计算机的存储器中。计算机通过读取和执行这些存储的指令自动地完成各种任务，在执行过程中不需要认为的干预。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2. 计算机的层层抽象" dir="auto" class="heading" id="2._计算机的层层抽象"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2. 计算机的层层抽象</h3><div class="heading-children"><div class="el-blockquote"><blockquote dir="auto">
<p><em>Any problem in computer science can be solved by another layer of indirection.</em></p>
</blockquote></div><div class="el-p"><p dir="auto">当今的计算机是层层抽象的产物，我们已经不需要直接和逻辑进行交互，而将这些繁琐的程序交给操作系统这个”管家“（管理软硬件资源）。有了一层层的抽象，我们现在只需要把高级语言源程序交给操作系统，而不需要明白管家之后要做什么。</p></div><div class="el-p"><p dir="auto">我们有了底层的门电路后能够将电路实现进行封装，创造出自己的存储元件、计算器、控制器等这些功能部件。之后，我们组合这些元件可以组成自己简易的计算机了，但是指令太乱、没有章法，咋办？</p></div><div class="el-p"><p dir="auto">人们提出了一个个的指令集体系结构来应对指令混乱的问题，规约底层硬件的实现，为上层提供操作计算机的接口。最开始我们用开关、灯泡来作为计算机的输入和输出。后来，我们将这些工作交给操作系统代为我们完成，我们只用输入指令。这也是汇编诞生的节点，而直到这里都是机器级的代码，也就是对于不同的ISA，你需要使用不同的汇编。</p></div><div class="el-p"><p dir="auto">再到后来，具有跨平台特性(portable)的高级语言诞生了。汇编指令和机器码是一一对应的，我们可以通过汇编器来直接转换，我们在一定程度上可以说汇编就是机器语言。而高级对于机器来说就相当于外国语，因为高级语言是人类读写的，是人类与机器交流的接口。通过编译器，我们就可以将高级语言翻译为机器能够理解的语言。所有相比于汇编器，编译器可就复杂多了。</p></div><div class="el-p"><p dir="auto">从高级语言的诞生开始，你就可以用高级语言提供的抽象来操作计算机底层硬件为你做各种各样的操作。各种应用层出不穷，为人们的生活带来了极大的便利。</p></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3. 堆和栈" dir="auto" class="heading" id="3._堆和栈"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3. 堆和栈</h3><div class="heading-children"><div class="el-p"><p dir="auto">程序自动执行而不需要人为干预听起来可能有些不知所以然。到了后面，我们会慢慢发现，这些其实都是堆和栈的功劳。在进程的虚拟内存中，只有堆和栈是会一直变化的，栈中的创建栈帧、销毁栈帧更是时刻不停的发生。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1 栈(Stack)" dir="auto" class="heading" id="3.1_栈(Stack)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 栈(Stack)</h5><div class="heading-children"><div class="el-p"><p dir="auto">栈是一种数据结构，遵循着<strong>先进后出(Last In First Out, LIFO)</strong> 的原则进行工作。在程序运行的过程中，我们往往需要一些函数帮助我们实现想要的功能，而栈的应用就是保存在程序执行过程中所需要保存的返回地址和局部变量，还负责保存和恢复现场信息。</p></div><div class="el-p"><p dir="auto">如果你学过系统调用或中断，你一定对“栈”不陌生。栈非常重要，它保存的数据是程序近期会用到的数据。在硬件中断或软件中断发生时，操作系统为了响应这些中断，会将程序运行的现场信息保存到<strong>内核栈</strong>。等操作系统应付完差事，读取栈中数据并恢复现场状态。</p></div><div class="el-p"><p dir="auto">如果执行用户程序呢？在x86-64架构下，当我们进入一段用户程序的函数中时，我们会：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>保存参数</strong> 寄存器传递和压栈</li>
<li data-line="1" dir="auto"><strong>调用函数</strong> <code>call func</code></li>
<li data-line="2" dir="auto"><strong>压栈保存当前栈帧</strong> <code>push ebp</code></li>
<li data-line="3" dir="auto"><strong>设置新的栈顶</strong> <code>mov ebp, esp</code></li>
<li data-line="4" dir="auto"><strong>分配局部变量</strong> <code>push sub_args</code></li>
<li data-line="5" dir="auto"><strong>函数执行</strong> <code>add</code> or <code>sub</code> and so on</li>
</ol></div><div class="el-p"><p dir="auto">函数执行完毕要返回，这时我们会：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>释放局部变量空间</strong> <code>mov esp, ebp</code></li>
<li data-line="1" dir="auto"><strong>恢复调用函数栈帧</strong> <code>pop ebp</code></li>
<li data-line="2" dir="auto"><strong>返回</strong> <code>ret</code></li>
</ol></div><div class="el-p"><p dir="auto">其中，EBP和ESP分别是帧指针寄存器和栈指针寄存器，分别用来指 向当前栈帧的底部和顶部。其实也并不复杂，就是<mark>调用函数的栈底就是被调用函数的栈顶</mark>。我们后面会用具体的例子说明。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2 堆(Heap)" dir="auto" class="heading" id="3.2_堆(Heap)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 堆(Heap)</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们可能会知道，堆是容纳、存放动态内存分配的内存块。尽管使用上理解起来很简单，但是堆的实现比栈来得复杂。堆内存的分配有很多种实现方式，如bitmap，linked list等。在这个文档中，你只需要知道，堆是用于动态内存分配，程序在运行时可以请求和释放内存块。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4. x86汇编结构" dir="auto" class="heading" id="4._x86汇编结构"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4. x86汇编结构</h3><div class="heading-children"><div class="el-p"><p dir="auto">x86汇编有三部分构成：<strong>1)</strong> <strong>伪指令</strong>，<strong>2)</strong> <strong>指令</strong>，<strong>3)</strong> <strong>标号</strong> 所构成。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1 伪指令" dir="auto" class="heading" id="4.1_伪指令"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 伪指令</h5><div class="heading-children"></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2 标号" dir="auto" class="heading" id="4.2_标号"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 标号</h5><div class="heading-children"></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.3 汇编指令" dir="auto" class="heading" id="4.3_汇编指令"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 汇编指令</h5><div class="heading-children"><div class="el-p"><p dir="auto">指令中需要给出的信息有：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">操作性质（操作码）</li>
<li data-line="1" dir="auto">源操作数1 或/和 源操作数2（可能是立即数、寄存器、存储地址）</li>
<li data-line="2" dir="auto">目的操作数地址（寄存器、存储地址）</li>
</ol></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5. C语言的机器级表示" dir="auto" class="heading" id="5._C语言的机器级表示"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5. C语言的机器级表示</h3><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="5.1 x86-32位机器的过程调用" dir="auto" class="heading" id="5.1_x86-32位机器的过程调用"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 x86-32位机器的过程调用</h5><div class="heading-children"><div class="el-p"><p dir="auto">入口参数的位置：从左到右的顺序入栈，即最右边的参数先入栈。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6. 复杂数据类型的机器级表示" dir="auto" class="heading" id="6._复杂数据类型的机器级表示"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6. 复杂数据类型的机器级表示</h3><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="6.1 数组和指针类型的分配和访问" dir="auto" class="heading" id="6.1_数组和指针类型的分配和访问"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6.1 数组和指针类型的分配和访问</h5><div class="heading-children"></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="7. x86-64 保存参数规则" dir="auto" class="heading" id="7._x86-64_保存参数规则"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7. x86-64 保存参数规则</h3><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="7.1 寄存器传递和栈传递" dir="auto" class="heading" id="7.1_寄存器传递和栈传递"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.1 寄存器传递和栈传递</h5><div class="heading-children"><div class="el-p"><p dir="auto">不同于<strong>传统32位机器将所有要传递的参数压到栈中保存</strong>的方式，在x86-64架构下的机器会先使用寄存器传递参数，通过通用寄存器传送参数，很多过程不用访问栈，缩短了代码的执行时间。在x86-64架构下的机器中，最多可有6个整型或指针型参数通过寄存器传递。当超过6个入口参数时，后面的通过栈来传递。</p></div><div class="el-p"><p dir="auto"><strong>寄存器传递</strong>：在x86-64架构下，前六个整数参数依次存放在寄存器 %rdi、%rsi、%rdx、%rcx、%r8 和 %r9 中。如果有浮点参数，它们会依次存放在 %xmm0 到 %xmm7 中。</p></div><div class="el-p"><p dir="auto"><strong>栈传递</strong>：如果参数数量超过了寄存器的数量限制，多余的参数会依次压入栈中，从右到左的顺序。在栈中传递的参数若是基本类型，则都被分配8个字节。</p></div><div class="el-p"><p dir="auto">假设有一个函数 func，它有八个整型参数和两个浮点型参数：<br>
<code>void func(int a, int b, int c, int d, int e, int f, int g, int h, float i, float j);</code></p></div><div class="el-p"><p dir="auto">在调用 func 时，前六个参数 a 到 f 会存放在寄存器中，而参数 g 和 h 会被压入栈中：</p></div><div class="el-pre"><pre><code data-line="0">整型数：
	a -&gt; %rdi
	b -&gt; %rsi
	c -&gt; %rdx
	d -&gt; %rcx
	e -&gt; %r8
	f -&gt; %r9
	g -&gt; 栈
	h -&gt; 栈
浮点数：
	i -&gt; %xmm0
	j -&gt; %xmm1
	...
	klmnop -&gt; %xmm2-%xmm7
	q -&gt; 栈
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="7.2 性能优化" dir="auto" class="heading" id="7.2_性能优化"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.2 性能优化</h5><div class="heading-children"><div class="el-p"><p dir="auto">在上面，我们知道当我们直接使用寄存器来传递参数后，能够免去一系列的微指令的开销。当我们每次调用过程中都只使用寄存器传递参数的话，我们就能保证系统的性能处在最佳状态。为了优化为了减少参数传递的开销，可以考虑以下优化方法：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>使用结构体</strong>：将多个相关参数打包成一个结构体，传递结构体指针。</li>
<li data-line="1" dir="auto"><strong>减少参数数量</strong>：尽量减少函数参数的数量，保持在寄存器的限制范围内。</li>
</ol></div></div></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="一：从代码到ELF" dir="auto" class="heading" id="一：从代码到ELF"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>一：从代码到ELF</h2><div class="heading-children"><div class="el-p"><p dir="auto">从我们编写程序，到一个真正可以在机器上运行的二进制可执行目标程序ELF之间，我们需要执行许多步骤。C语言源程序的预处理、编译到汇编最后链接之后我们才能获得二进制的可执行文件。下面，我们会一步一步的说明每个阶段的作用是什么。<br>
<span alt="Pasted image 20240916212548.png" src="Pasted image 20240916212548.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240916212548.png" src="some-notes/pics/pasted-image-20240916212548.png"></span></p></div><div class="el-h3 heading-wrapper"><h3 data-heading="1. C代码到二进制目标程序" dir="auto" class="heading" id="1._C代码到二进制目标程序"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. C代码到二进制目标程序</h3><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="1.1 C程序阶段" dir="auto" class="heading" id="1.1_C程序阶段"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.1 C程序阶段</h5><div class="heading-children"><div class="el-p"><p dir="auto">当你创建了一个 <code>xxxx.c</code> 的文件，一颗ELF的种子开始在此处生根。我们前面说过，高级语言源程序是给人类读的，机器没办法直接执行高级语言源程序。可能我们没有办法直接理解这句话，我们下面用最简单的 <code>hello.c</code> 源程序来说明一下。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This prints "hello, world\n"</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">上面的代码在计算机看来就是一连串的ASCII字符，转换成ASCII就是：</p></div><div class="el-pre"><pre class="language-ascii" tabindex="0"><code data-line="0" class="language-ascii is-loaded"># i n c l u d e &lt;sp&gt; &lt; s t d i o . h &gt; \n \n i n t m a i n ( ) \n { \n  &lt;sp&gt; &lt;sp&gt; &lt;sp&gt; &lt;sp&gt; p r i n t f ( " h e l l o , w o r l d \ n " ) ; \n } 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">而计算机实际上只能存储0和1所组成的二进制数，将这些字符转换成对应的十进制数数字就是：</p></div><div class="el-pre"><pre class="language-ascii" tabindex="0"><code data-line="0" class="language-ascii is-loaded">35 105 110 99 108 117 100 101 32 60 115 116 100 105 111 46 104 62 10 10 105 110 116 32 109 97 105 110 40 41 10 123 10 32 32 32 32 112 114 105 110 116 102 40 34 104 101 108 108 111 44 32 119 111 114 108 100 92 110 34 41 59 10 125
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.2 预处理阶段(Preprocessor)" dir="auto" class="heading" id="1.2_预处理阶段(Preprocessor)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.2 预处理阶段(Preprocessor)</h5><div class="heading-children"><div class="el-p"><p dir="auto">在得到源程序后，我们可以用下面的命令对源程序进行预处理：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc <span class="token parameter variable">-E</span> hello.c <span class="token parameter variable">-o</span> hello.i
cpp hello.c <span class="token operator">&gt;</span> hello.i
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">预处理完毕后，我们就得到了 <code>xxxx.i</code> 的预处理后文本文件。在Linux中，文件的后缀并不重要，但我们这样规定，使得我们能够清楚 <code>xxxx.i</code> 是一个预处理文件。那么预处理阶段做了什么呢？</p></div><div class="el-p"><p dir="auto">预处理文件处理源文件中<strong>以 '#' 开头的语句</strong>。如：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">删除 <code>#define</code> 并展开其所定义的宏</li>
<li data-line="1" dir="auto">处理所有条件预编译指令，如 <code>#if</code>、<code>#ifdef</code>、<code>#endif</code>等</li>
<li data-line="2" dir="auto">插入头文件到<code>#include</code>处，可以递归方式进行处理（复制粘贴）</li>
<li data-line="3" dir="auto">删除注释（可选择保留）</li>
<li data-line="4" dir="auto">添加行号和文件名标识</li>
<li data-line="5" dir="auto">保留<code>#pragma</code>编译指令（编译用）</li>
</ol></div><div class="el-p"><p dir="auto">完成这六步的源文件处理后，我们就得到了预处理文件，虽然预处理文件仍然可读，但是不包含任何头文件信息和宏定义。这时的种子褪去外壳。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.3 编译阶段" dir="auto" class="heading" id="1.3_编译阶段"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.3 编译阶段</h5><div class="heading-children"><div class="el-p"><p dir="auto">编译非常重要，因为这是从 human readable 到 machine readable 的阶段。编译过程将预处理文件进行词法分析、语法分析、语义分析和优化后生成汇编代码文件。《编译原理》就是专门讨论编译阶段而诞生的学科。我们称进行编译处理的程序为<strong>编译器(Compiler)</strong> 。</p></div><div class="el-p"><p dir="auto">我们用如下的命令可将程序编译为可读的汇编代码文件。虽然机器无法理解这些代码，但是汇编代码和二进制机器语言代码一一对应。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc <span class="token parameter variable">-S</span> hello.i <span class="token parameter variable">-o</span> hello.s
gcc <span class="token parameter variable">-S</span> hello.c <span class="token parameter variable">-o</span> hello.s
/user/lib/gcc/xxxx-linux-gnu/4.1/cc1 hello.c

</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">其中，cc1&nbsp;是 GCC 的内部编译器，它负责将预处理后的 C 语言文件转换为汇编代码。直接调用cc1可以跳过 GCC 的其他阶段，直接进行编译。gcc命令实际上是具体程序（如ccp、cc1、as等）的包装命令， 用户通过gcc命令来使用具体的预处理程序ccp、编译程序cc1和 汇编程序as等。</p></div><div class="el-p"><p dir="auto">编译阶段的实现非常复杂，我们不介绍。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.4 汇编阶段" dir="auto" class="heading" id="1.4_汇编阶段"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.4 汇编阶段</h5><div class="heading-children"><div class="el-p"><p dir="auto">编译阶段完成后，生成ELF可执行文件的程序就依然走完了大半。在汇编阶段，汇编程序（汇编器）会将编译阶段所产生的汇编代码文件转换成机器指令序列。我们提到过汇编指令和机器指令是一一对应的，都属于机器级代码，只不过前者是后者的符号标识而已。我们可以用如下的指令汇编得到<strong>可重定位目标文件</strong>。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc –c hello.s –o hello.o
gcc –c hello.c –o hello.o
as hello.s <span class="token parameter variable">-o</span> hello.o
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">汇编结果是一个可重定位目标文件（如，hello.o），其中包含着的是人不可读的二进制代码，必须用相应的工具软件来查看其内容。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.5 链接" dir="auto" class="heading" id="1.5_链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.5 链接</h5><div class="heading-children"><div class="el-p"><p dir="auto">预处理、编译和汇编三个阶段针对一个模块（一个<em>.c文件）进行处理，得到对应的一个可重定位目标文件（一个</em>.o文件）。而链接过程是将<strong>多个可重定位目标文件</strong>合并生成一个<strong>可执行文件</strong>。我们可以用下面的shell命令来生成一个可执行文件：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc –static –o myproc main.o test.o
ld –static –o myproc main.o test.o  <span class="token comment"># 需要C静态标准库</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">其中，–static 表示静态链接，如果不指定-o选项，则可执行文件名 为“a.out”。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="1.6 链接器的由来" dir="auto" class="heading" id="1.6_链接器的由来"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1.6 链接器的由来</h5><div class="heading-children"><div class="el-p"><p dir="auto">早期程序员是在纸带上编写程序的，当程序员修改了某行指令（增加/删除指令）时，纸带很可能作废。这是因为有些代码是位置相关的（如&nbsp;<code>jmp</code>，即跳转指令），当增加一行代码，<code>jmp</code>&nbsp;后面跟的绝对地址就需要跟着改变。</p></div><div class="el-p"><p dir="auto">后来汇编语言出现了，汇编语言用符号表示跳转的位置，不需要修改&nbsp;<code>jmp</code>&nbsp;指令的跳转目标了。如：</p></div><div class="el-pre"><pre class="language-assembly" tabindex="0"><code data-line="0" class="language-assembly is-loaded">0: 0101 0110       add B
1: 0010 0101       jmp L0
	...
5: 0110 0111    L0: sub C
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">这样，我们开始编写的汇编指令都是位置无关的。随着程序越来越复杂，一个程序可能由多个子模块组成。子程序（函数）的起始地址和变量的起始地址我们也用符号来定义，调用子程序或对变量的使用就是顾好的引用(reference)。之后这些符号通过汇编、链接后才会确定符号的地址（符号解析和重定位）。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="2. 三类目标文件" dir="auto" class="heading" id="2._三类目标文件"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2. 三类目标文件</h3><div class="heading-children"><div class="el-p"><p dir="auto">我们编写的C语言源程序通过预处理、编译、汇编之后终于得到一个二进制的目标文件了。之后我们还需要链接之后才能成为可执行目标文件。那为什么要链接，链接给我们带来什么好处了？简单来说，链接容许我们程序的<strong>模块化</strong>，当你要使用某个功能时，只需要加载对应功能的模块就好了。这种模块化加载还带来了另一个好处，即<strong>效率高</strong>，debug程序和更新程序也只需要修改某一个模块就好了。开发工作由此也可以并发进行，效率更高。</p></div><div class="el-p"><p dir="auto">程序经过编译汇编之后能够生成下面的三类目标文件。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.1 可重定位目标文件（.o）" dir="auto" class="heading" id="2.1_可重定位目标文件（.o）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.1 可重定位目标文件（.o）</h5><div class="heading-children"><div class="el-p"><p dir="auto">即未链接之前的目标文件，每个.o文件都由对应的.c文件生成。每个.o文件代码和数据的<strong>地址都从0开始</strong>。虽然这时的目标文件代码是机器能够识别的机器代码，但由于没有经过符号的解析和重定位，这种目标文件仍然是不可执行的。可重定位目标文件包含代码、数据和重定位的信息。</p></div><div class="el-p"><p dir="auto"><strong>静态链接库文件</strong>可以又若干的可重定位目标文件构成。</p></div><div class="el-p"><p dir="auto">要得到可执行目标文件，我们需要将可重定位目标文件和其他可重定位文件合并为可执行文件。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.2 可执行目标文件（默认a.out）" dir="auto" class="heading" id="2.2_可执行目标文件（默认a.out）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.2 可执行目标文件（默认a.out）</h5><div class="heading-children"><div class="el-p"><p dir="auto">可执行目标文件包含的代码和数据可以被直接复制到内存中执行。这时的代码和数据的地址不再是从0开始，经过重定位之后，代码和数据的地址为<strong>虚拟地址</strong>空间中的地址。</p></div><div class="el-p"><p dir="auto"><mark>**链接的本质</mark>就是合并多个可重定位目标文件的代码节、数据节等成代码段、数据段。**</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240926140732.png" src="Pasted image 20240926140732.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240926140732.png" src="some-notes/pics/pasted-image-20240926140732.png"></span><br>
但是在合并这些可重定位目标文件的代码节、数据节等节之前，我们需要对这些<strong>符号（即全局变量和函数名）</strong> 进行解析并重定位这些符号。（局部变量不放入符号表）</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.3 共享库文件（.so）" dir="auto" class="heading" id="2.3_共享库文件（.so）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.3 共享库文件（.so）</h5><div class="heading-children"><div class="el-p"><p dir="auto">共享库文件是<strong>特殊的可重定位目标文件</strong>，能够在程序装入内存或运行时自动地被装入内存并自动被链接。在Windows中称为动态链接库文件(Dynamic Link Libraries, DLL)。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="2.4 目标文件的格式" dir="auto" class="heading" id="2.4_目标文件的格式"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2.4 目标文件的格式</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>目标代码(Object Code)</strong>：编译器和汇编器处理源代码后所生成的机器语言目标代码。</p></div><div class="el-p"><p dir="auto"><strong>目标文件(Object File)</strong>：指包含目标代码的文件，最早的目标文件是自由格式，非标准的。标准的几种目标文件格式：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>DOS操作系统</strong>：COM格式，文件中仅包含代码和数据， 且被加载到固定位置</li>
<li data-line="1" dir="auto"><strong>System V UNIX早期版本</strong>：COFF格式，文件中不仅包含代码和数据 ，还包含重定位信息、调试信息、符号表等其他信息，由一组严格定 义的数据结构序列组成</li>
<li data-line="2" dir="auto"><strong>Windows</strong>：PE格式（COFF的变种），称为可移植可执行（ Portable Executable，简称PE）</li>
<li data-line="3" dir="auto"><strong>Linux等类UNIX</strong>：ELF格式（COFF的变种），称为可执行可链接（ Executable and Linkable Format，简称ELF）</li>
</ul></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="3. ELF的两种视图（x64）" dir="auto" class="heading" id="3._ELF的两种视图（x64）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3. ELF的两种视图（x64）</h3><div class="heading-children"><div class="el-p"><p dir="auto"><strong>可执行可链接目标文件</strong>有两种视图，我们说的三类目标文件都是是ELF。其中 .o 后缀的文件和 .so 后缀的文件其实并不是可执行文件，而是<strong>可重定位目标文件</strong>，这时*.o 文件并不具有可执行属性，是<strong>ELF的链接视图</strong>。当这些链接视图的文件链接后就会生成<strong>可执行目标文件</strong>（默认 a.out ），这时得到的目标文件具有可执行的属性，是<strong>ELF的执行视图</strong>。</p></div><div class="el-p"><p dir="auto">我们现在可以将链接的概念拓展一下：<mark>链接的本质</mark>就是将多个<strong>可重定位目标文件</strong>的代码节、数据节等合并成<strong>可执行目标文件</strong>中的代码段和数据段。</p></div><div class="el-p"><p dir="auto">本节课我们依旧使用下面的程序做例子：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">开始之前，我们先用命令将C语言程序生成<strong>可重定位目标文件</strong>和<strong>可执行目标文件</strong>：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc <span class="token parameter variable">-c</span> hello.c <span class="token parameter variable">-o</span> hello.o
gcc hello.c <span class="token parameter variable">-o</span> hello
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">需要用到的命令：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded"><span class="token comment"># 显示 ELF 文件的所有信息</span>
readelf <span class="token parameter variable">-a</span> objfile
<span class="token comment"># 显示 ELF 文件头信息</span>
readelf <span class="token parameter variable">-h</span> objfile
<span class="token comment"># 显示 ELF 文件的节头信息</span>
readelf <span class="token parameter variable">-S</span> objfile
<span class="token comment"># 显示 ELF 文件的符号表信息</span>
readelf <span class="token parameter variable">-s</span> objfile
<span class="token comment"># 显示 ELF 文件的程序头信息</span>
readelf <span class="token parameter variable">-l</span> objfile
<span class="token comment"># 反汇编 ELF 文件中的代码段</span>
objdump <span class="token parameter variable">-d</span> objfile
<span class="token comment"># 以十六进制和 ASCII 格式显示文件内容</span>
hexdump <span class="token parameter variable">-C</span> objfile
<span class="token comment"># 查看目标文件中的符号表信息</span>
nm
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.1 链接视图——可重定位目标文件(Relocatable Object File)" dir="auto" class="heading" id="3.1_链接视图——可重定位目标文件(Relocatable_Object_File)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1 链接视图——可重定位目标文件(Relocatable Object File)</h4><div class="heading-children"><div class="el-p"><p dir="auto">可重定位目标文件由<strong>ELF头</strong>、<strong>程序头表（可选）</strong>、<strong>节(Sections)</strong>、和<strong>节头表</strong>组成。节(section)是ELF文件中具有相同特征的最小可处理单位，链接时就是对相同的属性的节进行组合成段(segments)。</p></div><div class="el-p"><p dir="auto">ELF头标识了文件的架构类型、数据的编码方式、文件类型、目标机器架构、入口点地址、节头表的位置和header的大小等信息。而节头表标识了每个节的属性信息，这两个部分是可重定位目标文件最重要的部分，搞清楚这两个部分，你就明白了ELF的链接视图是怎么样的。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1.1 ELF头(ELF Header)" dir="auto" class="heading" id="3.1.1_ELF头(ELF_Header)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.1 ELF头(ELF Header)</h5><div class="heading-children"><div class="el-p"><p dir="auto">ELF头位于ELF文件最开始的地方（偏移为0），包含了文件结构的说明信息。这些信息存放在一个数据结构中。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EI_NIDENT</span> <span class="token expression"><span class="token number">16</span></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> e_ident<span class="token punctuation">[</span>EI_NIDENT<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 魔数和其他标识信息，16字节</span>
    <span class="token class-name">uint16_t</span> e_type<span class="token punctuation">;</span>                  <span class="token comment">// 文件类型，2字节</span>
    <span class="token class-name">uint16_t</span> e_machine<span class="token punctuation">;</span>               <span class="token comment">// 目标机器架构（如 x86-64），2字节</span>
    <span class="token class-name">uint32_t</span> e_version<span class="token punctuation">;</span>               <span class="token comment">// ELF 版本号，4字节</span>
    <span class="token class-name">uint64_t</span> e_entry<span class="token punctuation">;</span>                 <span class="token comment">// 程序入口地址（可执行文件使用），8字节</span>
    <span class="token class-name">uint64_t</span> e_phoff<span class="token punctuation">;</span>                 <span class="token comment">// 程序头表在文件中的偏移量，8字节</span>
    <span class="token class-name">uint64_t</span> e_shoff<span class="token punctuation">;</span>                 <span class="token comment">// 节头表在文件中的偏移量，8字节</span>
    <span class="token class-name">uint32_t</span> e_flags<span class="token punctuation">;</span>                 <span class="token comment">// 特定于处理器的标志，4字节</span>
    <span class="token class-name">uint16_t</span> e_ehsize<span class="token punctuation">;</span>                <span class="token comment">// ELF 头部的大小，2字节</span>
    <span class="token class-name">uint16_t</span> e_phentsize<span class="token punctuation">;</span>             <span class="token comment">// 程序头表中每个条目的大小，2字节</span>
    <span class="token class-name">uint16_t</span> e_phnum<span class="token punctuation">;</span>                 <span class="token comment">// 程序头表中的条目数，2字节</span>
    <span class="token class-name">uint16_t</span> e_shentsize<span class="token punctuation">;</span>             <span class="token comment">// 节头表中每个条目的大小，2字节</span>
    <span class="token class-name">uint16_t</span> e_shnum<span class="token punctuation">;</span>                 <span class="token comment">// 节头表中的条目数，2字节</span>
    <span class="token class-name">uint16_t</span> e_shstrndx<span class="token punctuation">;</span>              <span class="token comment">// 节头字符串表的索引，2字节</span>
<span class="token punctuation">}</span> Elf64_Ehdr<span class="token punctuation">;</span>                         <span class="token comment">// ELF头部总共64字节</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">ELF64头信息在机器中的编码是01序列，我们可以通过 readelf 这种工具软件来查看ELF中包含的信息。这里我们需要读取文件的头信息，我们用 <code>readelf -h hello.o</code> 来获取ELF的头包含什么信息。</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -h hello.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          600 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14
  Section header string table index: 13
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">从中，我们能够读取到很多信息，如果你好奇查看了 hello 可执行文件的ELF头，你就会发现有几项不一样。比如文件的类型、入口地址、程序头和节信息变了。其中入口地址是我们不得不关注的，hello.o 是可重定位的目标文件，给出的是ELF的链接视图，所以装入的入口地址是0x0。</p></div><div class="el-p"><p dir="auto">我们再来读一下其他信息，在ELF头中，我们可以读到另一个重要表项——节头表的信息。我们在下面的注释中给出。</p></div><div class="el-pre"><pre><code data-line="0"># 节头表开始的位置，偏移量为600字节(0x258)
  Start of section headers:          600 (bytes into file)
# 节头表由多个节头的信息组成，这里节头表由14个大小为64个字节的节头构成。一共896Bytes
  Size of section headers:           64 (bytes)
  Number of section headers:         14

# 字符串表在节头表中的位置 .strtab
  Section header string table index: 13
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">思考一下，为什么需要额外地指出 .strtab 在节头表中的位置？</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.1.2 节头表" dir="auto" class="heading" id="3.1.2_节头表"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.1.2 节头表</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们前面在ELF头中其实都看到 hello.o 中有多少个节头了。这些节头给出每个节的相关信息，如节的名称、节的起始地址、节的偏移等等。每个节承担不同的功能，我们很快就能根据这些信息从文件的二进值信息这找到我们写进去的数据了（Hacker 101）。</p></div><div class="el-p"><p dir="auto">在 ELF 文件中，节头表（Section Header Table）包含了每个节的信息。节头的结构体定义如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> sh_name<span class="token punctuation">;</span>      <span class="token comment">// 节名称的索引</span>
    <span class="token class-name">uint32_t</span> sh_type<span class="token punctuation">;</span>      <span class="token comment">// 节的类型</span>
    <span class="token class-name">uint64_t</span> sh_flags<span class="token punctuation">;</span>     <span class="token comment">// 节的标志(在虚拟空间中的访问属性)</span>
    <span class="token class-name">uint64_t</span> sh_addr<span class="token punctuation">;</span>      <span class="token comment">// 节的虚拟内存地址(链接视图无意义)</span>
    <span class="token class-name">uint64_t</span> sh_offset<span class="token punctuation">;</span>    <span class="token comment">// 节在文件中的偏移</span>
    <span class="token class-name">uint64_t</span> sh_size<span class="token punctuation">;</span>      <span class="token comment">// 节的大小</span>
    <span class="token class-name">uint32_t</span> sh_link<span class="token punctuation">;</span>      <span class="token comment">// 节的链接信息</span>
    <span class="token class-name">uint32_t</span> sh_info<span class="token punctuation">;</span>      <span class="token comment">// 链接信息</span>
    <span class="token class-name">uint64_t</span> sh_addralign<span class="token punctuation">;</span> <span class="token comment">// 对齐要求信息</span>
    <span class="token class-name">uint64_t</span> sh_entsize<span class="token punctuation">;</span>   <span class="token comment">// 节中条目的大小</span>
<span class="token punctuation">}</span> Elf64_Shdr<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">节头的结构体中的数据都是01序列，不方便读懂，我们用 <code>readelf -S</code> 命令来获取节头表的信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -S hello.o
There are 14 section headers, starting at offset 0x258:
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
       
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       000000000000001e  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  00000198
       0000000000000030  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  0000005e
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .bss              NOBITS           0000000000000000  0000005e
       0000000000000000  0000000000000000  WA       0     0     1
  [ 5] .rodata           PROGBITS         0000000000000000  0000005e
       000000000000000d  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  0000006b
       000000000000002c  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  00000097
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  00000098
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  000000b8
       0000000000000038  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  000001c8
       0000000000000018  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  000000f0
       0000000000000090  0000000000000018          12     4     8
  [12] .strtab           STRTAB           0000000000000000  00000180
       0000000000000013  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  000001e0
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">属性信息的含义如下：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>[Nr]</strong>：节的索引号，从 0 开始。</li>
<li data-line="1" dir="auto"><strong>Name</strong>：节的名称，如&nbsp;<code>.text</code>、<code>.data</code>&nbsp;等。</li>
<li data-line="2" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>Type</strong>：节的类型，表示节的内容和用途。
<ul>
<li data-line="3" dir="auto"><strong>NULL</strong>：空节。</li>
<li data-line="4" dir="auto"><strong>PROGBITS</strong>：程序数据。</li>
<li data-line="5" dir="auto"><strong>RELA</strong>：重定位条目，带附加信息。</li>
<li data-line="6" dir="auto"><strong>NOBITS</strong>：不占用文件空间的节（如 .bss）。</li>
<li data-line="7" dir="auto"><strong>NOTE</strong>：包含附加信息的节。</li>
<li data-line="8" dir="auto"><strong>SYMTAB</strong>：符号表。</li>
<li data-line="9" dir="auto"><strong>STRTAB</strong>：字符串表。</li>
</ul>
</li>
<li data-line="10" dir="auto"><strong>Address</strong>：节在内存中的加载地址。</li>
<li data-line="11" dir="auto"><strong>Offset</strong>：节在文件中的偏移量。</li>
<li data-line="12" dir="auto"><strong>Size</strong>：节的大小（以字节为单位）。</li>
<li data-line="13" dir="auto"><strong>EntSize</strong>：节中每个条目的大小（如果节包含固定大小的条目）。</li>
<li data-line="14" dir="auto"><strong>Flags</strong>：节的标志，描述节的属性。</li>
<li data-line="15" dir="auto"><strong>Link</strong>：与该节相关联的其他节的索引。</li>
<li data-line="16" dir="auto"><strong>Info</strong>：额外的信息，通常与&nbsp;<code>Link</code>&nbsp;字段一起使用。</li>
<li data-line="17" dir="auto"><strong>Align</strong>：节的对齐要求。</li>
</ol></div><div class="el-p"><p dir="auto">现在，我们就能准确地从中知道每个节相对 0 的确切位置。但仍然迷惑的是为何所有节的 address 字段都为 0000？这是因为当前 hello.o 并没有链接重定位生成可执行目标文件，所以对应的每个节的起始地址都为0（因为这时的节地址是毫无意义的）。</p></div><div class="el-p"><p dir="auto">我们的例子中并没有使用任何变量，所以在 .data 节和 .bss 节中什么都没有，size 字段为0。而我们的 <code>hello world</code> 字符串属于 .rodata 节中的内容（只读数据、printf格式串、<strong>switch跳转表</strong>），一共13个字节（13 = 0xd），所以 .rodata 的 size 字段为 0xd。我们之后会在 hello.o 文件中查看我们 .rodata 中的内容。</p></div><div class="el-p"><p dir="auto">如果你定义了初始化的全局变量和未初始化的全局变量，你就会发现 .data 节中是有数据的，而 .bss 节中无论你定义了多少未初始化的全局变量和局部静态变量都不会存放任何数据即 size 字段永远是0。这是因为 .data 节中存放具体的初始值，需要占磁盘空间。而 .bss 节用专门的节头表来说明应该为 .bss 节预留多大的空间，所以只要说明 .bss 中的每个变量将来在执行时占用几个字节即可，因此，.bss 节实际上不占用磁盘空间，提高了磁盘空间利用率。（C语言默认未初始化的全局和局部静态变量的值为0）</p></div><div class="el-p"><p dir="auto">通过节头表中的信息和ELF头的信息，我们就能绘制出 hello.o 文件结构：</p></div><div class="el-pre"><pre><code data-line="0">
+-------------------------+-------------------------+   0x000
| ELF Header              | 64 bytes (0x40)         |
+-------------------------+-------------------------+   0x040
| .text                   | 30 bytes (0x1e)         |
+-------------------------+-------------------------+   0x05e
| .data                   | 0 bytes                 |
+-------------------------+-------------------------+   0x05e
| .bss                    | 0 bytes                 |
+-------------------------+-------------------------+   0x05e
| .rodata                 | 13 bytes (0x0d)         |
+-------------------------+-------------------------+   0x06b
| .comment                | 44 bytes (0x2c)         |
+-------------------------+-------------------------+   0x097
| .note.GNU-stack         | 0 bytes                 |
+-------------------------+-------------------------+   0x097
+-------------------------+-------------------------+   0x098(0x97对齐)
| .note.gnu.property      | 32 bytes (0x20)         |
+-------------------------+-------------------------+   0x0b8
| .eh_frame               | 56 bytes (0x38)         |
+-------------------------+-------------------------+   0x0f0
| .symtab                 | 144 bytes (0x90)        |
+-------------------------+-------------------------+   0x180
| .strtab                 | 19 bytes (0x13)         |
+-------------------------+-------------------------+   0x193
+-------------------------+-------------------------+   0x198(0x193对齐)
| .rela.text              | 48 bytes (0x30)         |
+-------------------------+-------------------------+   0x1c8
| .rela.eh_frame          | 24 bytes (0x18)         |
+-------------------------+-------------------------+   0x1e0
| .shstrtab               | 116 bytes (0x74)        |
+-------------------------+-------------------------+   0x254(596 Bytes)
+-------------------------+-------------------------+   0x258(600 Bytes)
| Section Headers         | 896 bytes (14 * 64)     |
+-------------------------+-------------------------+   0x5d8(600+896 Bytes)
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">通过结构信息，我们可以很清楚地看到文件从哪开始，从哪里结束。我们用 <code>hexdump -C</code> 以16进制和ASCII格式查看 hello.o 文件。我们看到，程序如我们预想的一样从 0x5d8 结束。查看 .rodata 节的位置，我们也如预料地看到了 <code>hello,world.</code> 这样12个字符。至此，关于 hello.o 的解读圆满结束！</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ hexdump -C hello.o
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
...
00000050  89 c7 e8 00 00 00 00 b8  00 00 00 00 5d c3 68 65  |............].he|
00000060  6c 6c 6f 2c 20 77 6f 72  6c 64 00 00 47 43 43 3a  |llo, world..GCC:|
...
000005d0  00 00 00 00 00 00 00 00                           |........|
000005d8
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="番外：`switch` jump table" dir="auto" class="heading" id="番外：`switch`_jump_table"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>番外：<code>switch</code> jump table</h5><div class="heading-children"></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="3.2 执行视图——可执行目标文件(Executable Object File)" dir="auto" class="heading" id="3.2_执行视图——可执行目标文件(Executable_Object_File)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2 执行视图——可执行目标文件(Executable Object File)</h4><div class="heading-children"><div class="el-p"><p dir="auto">可执行文件中包括代码、数据（已初始化的 .data 和未初始化的 .bss）。与可重定位的目标文件不同，我们定义的所有变量和函数在可执行目标文件中都明确了其地址（虚拟地址空间），符号的引用处也已被重定位，指向所引用的定义符号。</p></div><div class="el-p"><p dir="auto">为了执行的方便，链接时还会将具有相同访问属性的节进行合并成段（如 .text 节和 .rodata 节合并为 .rodata 段，.data 和 .bss 节合并为 .data 段）。这些段的信息被存放在<strong>程序头表/段头表</strong>中。</p></div><div class="el-p"><p dir="auto">在Linux中的可执行目标文件没有文件扩展名（默认为a.out），在Windows中，可执行文件的扩展名为 .exe。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2.1 ELF头" dir="auto" class="heading" id="3.2.1_ELF头"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.1 ELF头</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们先用命令 readelf -h 查看ELF头，看看与可重定位目标文件有什么不同。首先，最大的不同就是程序的<strong>入口地址</strong>不再是0了，还多了<strong>程序头表/段头表(Segment header table)</strong> 和 <strong>.init 节</strong>。然后我们发现，在链接（重定位）过后，我们<strong>少了带重定位信息的节</strong>（如.rela.text、.rela.data等）。</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -h hello
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
  Start of program headers:          64 (bytes into file)
  Start of section headers:          13976 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们简单介绍 .init 节和段头表的作用。.init 节用于定义 _init函数，这个函数用于可执行目标文件开始时的初始化工作。和节头表一样，段头表也是一个结构体数组，段头表用于描述这些段的各种属性信息。从上面的ELF头信息中我们可以读出，程序有13个段头，每个段头有56个字节。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2.2 程序头表(Segment Header Table)" dir="auto" class="heading" id="3.2.2_程序头表(Segment_Header_Table)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.2 程序头表(Segment Header Table)</h5><div class="heading-children"><div class="el-p"><p dir="auto">程序头表描述了可执行文件中的段的属性信息和虚拟空间中的存储段和节之间的映射关系（段由哪些节构成）。在我的系统上，每个段头有52字节，这52字节就说明虚拟地址空间中一个连续的段或特殊节的描述信息。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> p_type<span class="token punctuation">;</span>   <span class="token comment">// 段的类型</span>
    <span class="token class-name">uint32_t</span> p_flags<span class="token punctuation">;</span>  <span class="token comment">// 段的权限标志</span>
    <span class="token class-name">uint64_t</span> p_offset<span class="token punctuation">;</span> <span class="token comment">// 段在文件中的偏移量</span>
    <span class="token class-name">uint64_t</span> p_vaddr<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的虚拟地址</span>
    <span class="token class-name">uint64_t</span> p_paddr<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的物理地址</span>
    <span class="token class-name">uint64_t</span> p_filesz<span class="token punctuation">;</span> <span class="token comment">// 段在文件中的大小</span>
    <span class="token class-name">uint64_t</span> p_memsz<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的大小</span>
    <span class="token class-name">uint64_t</span> p_align<span class="token punctuation">;</span>  <span class="token comment">// 段在内存中的对齐要求</span>
<span class="token punctuation">}</span> Elf64_Phdr<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">同样，我们用 readelf -l 读取段头表的信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -l hello

Elf file type is DYN (Position-Independent Executable file)
Entry point 0x1060
There are 13 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000628 0x0000000000000628  R      0x1000
  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000
                 0x0000000000000175 0x0000000000000175  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000
                 0x00000000000000f4 0x00000000000000f4  R      0x1000
  LOAD           0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000258 0x0000000000000260  RW     0x1000
  DYNAMIC        0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000030 0x0000000000000030  R      0x8
  NOTE           0x0000000000000368 0x0000000000000368 0x0000000000000368
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338
                 0x0000000000000030 0x0000000000000030  R      0x8
  GNU_EH_FRAME   0x0000000000002014 0x0000000000002014 0x0000000000002014
                 0x0000000000000034 0x0000000000000034  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000002db8 0x0000000000003db8 0x0000000000003db8
                 0x0000000000000248 0x0000000000000248  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">段头的的属性信息含义入下：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>Type</strong>: 段的类型，例如&nbsp;<code>LOAD</code>&nbsp;表示可加载段/可装入段，<code>DYNAMIC</code>&nbsp;表示动态链接信息段。</li>
<li data-line="1" dir="auto"><strong>Offset</strong>: 段在文件中的偏移量。</li>
<li data-line="2" dir="auto"><strong>VirtAddr</strong>: 段在内存中的虚拟地址。</li>
<li data-line="3" dir="auto"><strong>PhysAddr</strong>: 段在内存中的物理地址（通常在现代系统中未使用）。</li>
<li data-line="4" dir="auto"><strong>FileSiz</strong>: 段在文件中的大小。</li>
<li data-line="5" dir="auto"><strong>MemSiz</strong>: 段在内存中的大小。</li>
<li data-line="6" dir="auto"><strong>Flags</strong>: 段的权限标志，例如&nbsp;<code>R</code>&nbsp;表示可读，<code>W</code>&nbsp;表示可写，<code>E</code>&nbsp;表示可执行。</li>
<li data-line="7" dir="auto"><strong>Align</strong>: 段在内存中的对齐要求。</li>
</ol></div><div class="el-p"><p dir="auto">通过Section to Segment mapping中的信息，我们能够知道各个段和其所包含的节之间的映射关系，哪个段由哪些节组成。并且通过段的类型能够知道哪些段是需要载入内存，与存储器进行映像的。通过这些段头的信息，和在上节课的操作一样，我们可以通过这些地址信息找到我们只读字符串的位置。</p></div><div class="el-pre"><pre><code data-line="0">00002000  01 00 02 00 68 65 6c 6c  6f 2c 20 77 6f 72 6c 64  |....hello, world|
00002010  00 00 00 00 01 1b 03 3b  30 00 00 00 05 00 00 00  |.......;0.......|
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="3.2.3 存储器映像" dir="auto" class="heading" id="3.2.3_存储器映像"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>3.2.3 存储器映像</h5><div class="heading-children"><div class="el-p"><p dir="auto">在 ELF 文件中，只有&nbsp;<code>LOAD</code>&nbsp;类型的段会被装入内存。这些段包含了程序的代码和数据，加载器会根据这些段的信息将它们映射到进程的地址空间中。其他类型的段，如&nbsp;<code>PHDR</code>、<code>INTERP</code>、<code>DYNAMIC</code>、<code>NOTE</code>&nbsp;等，虽然在 ELF 文件中有定义，但不会被直接装入内存，而是用于辅助加载和运行程序。</p></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="4. 符号及符号解析（链接操作步骤1）" dir="auto" class="heading" id="4._符号及符号解析（链接操作步骤1）"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4. 符号及符号解析（链接操作步骤1）</h3><div class="heading-children"><div class="el-p"><p dir="auto">链接的操作实际上是合并多个可重定位目标文件，要合并这些可重定位目标文件，我们就需要先对这些符号进行符号解析。这是因为不同的可重定位目标文件中可能有其他文件中的符号引用。我们<mark>确定这些符号的引用关系</mark>的这一过程就是<strong>符号解析</strong>（<mark>将每个符号的引用都与一个确定的符号定义建立关联</mark>）。</p></div><div class="el-p"><p dir="auto">符号解析后，我们就能够合并相关的.o文件了。具体一点的过程是：先确定每个符号的地址，然后在引用处填入符号的地址。<br>
<span alt="Pasted image 20240928003748.png" src="Pasted image 20240928003748.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240928003748.png" src="some-notes/pics/pasted-image-20240928003748.png"></span><br>
在上面的例子中，P0.o中引用了符号P1（使用外部定义的函数），在P1.o中引用了P0.o中的符号A和B（外部数据）。而在编译阶段，符号的位置是未知的，因为它们可能在不同的目标文件中。链接器将可重定位目标文件中属性相同的节合并成段。链接器解析这些符号，确定它们的最终地址。在符号引用处将引用替换为解析后的地址，从而完成对符号的访问。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.1 符号及符号表" dir="auto" class="heading" id="4.1_符号及符号表"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1 符号及符号表</h4><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.1 链接符号的类型" dir="auto" class="heading" id="4.1.1_链接符号的类型"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.1 链接符号的类型</h5><div class="heading-children"><div class="el-p"><p dir="auto">每个可重定位目标文件都有一个符号表，包含着在文件中定义和引用的符号。有三种连接器符号：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">
<p><strong>模块内部定义的全局符号(global symbols)</strong>：<br>
由模块m定义并能被其他模块引用的符号。例如，非static的函数和非static的全局变量。<br>
如，my_func.c 中的全局变量名<code>buf </code>。</p>
</li>
<li data-line="4" dir="auto">
<p><strong>外部定义的全局符号(external symbols)</strong>：<br>
由其他模块定义并被模块引用的全局符号。如在<code>main.c</code>中的函数名<code>swap</code>和<code>add</code>。 </p>
</li>
<li data-line="7" dir="auto">
<p><strong>本模块的局部符号(local symbols)</strong>：<br>
仅由模块m定义和引用的本地符号。在模块定义的带static的函数和全局变量。如，my_var.c中的<strong>static变量</strong><code>local</code>。</p>
<p>需要<strong>注意</strong>的是链接的局部符号不是指程序中的局部变量（分配在栈中的临时性变量）。对于C语言中的局部变量，链接器并不关心。</p>
</li>
</ol></div><div class="el-p"><p dir="auto">在<strong>符号解析</strong>的时候，当本模块内引用的是<strong>本地的局部符号</strong>，我们只要与本模块内唯一的定义符号关联即可。而<strong>全局符号</strong>的解析涉及多个模块（内部定义的、外部定义的），所以较复杂。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.2 符号的定义和引用" dir="auto" class="heading" id="4.1.2_符号的定义和引用"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.2 符号的定义和引用</h5><div class="heading-children"><div class="el-p"><p dir="auto">在程序中，我们需要先定义一个符号。之后对该符号的操作其实都是对符号的引用，例如我们定义了一个函数（符号的定义），之后使用函数的操作叫函数的引用（符号的引用）。变量也有相似的操作。例如：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">// 定义符号 test</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义符号（弱符号）</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 引用符号 test</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>          <span class="token comment">// 全局变量x，定义符号x</span>
<span class="token keyword">int</span> <span class="token operator">*</span>xp <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>   <span class="token comment">// 全局变量xp，定义符号xp，引用符号x</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">说明类型的符号都是一种定义，而其他的属于引用。局部变量会在栈中分配空间，不会被过程外的文件中引用，所以不属于符号，不会出现在符号表中。</p></div><div class="el-p"><p dir="auto">我们举个例子：</p></div><div class="el-p"><p dir="auto">我们将变量都放在 my_var.c 中（3个符号，没有引用）</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 全局符号的定义</span>
<span class="token keyword">int</span> var2 <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>          <span class="token comment">// 全局符号的定义</span>
<span class="token keyword">static</span> var1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        <span class="token comment">// 局部符号(static)的定义</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">然后我们有 my_func.c（3个符号，7个 .rela.text 的引用（buf）,2个 .rela.eh_frame 的引用）</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">extern</span> <span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 外部符号的定义</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 全局符号的定义</span>
	<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
	temp <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// buf引用</span>
	buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 2*buf的引用</span>
	buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>      <span class="token comment">// 1*buf的引用</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment">// 全局符号的定义</span>
	buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 2*buf的引用</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">之后所有的操作在 main.c 中完成（6个符号）</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 外部符号(弱符号)的定义</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 外部符号(弱符号)的定义</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 外部符号(弱符号)的定义</span>
<span class="token keyword">void</span> <span class="token function">local</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 全局符号的定义</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 全局符号的定义</span>
	<span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 全局符号的引用</span>
	<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 全局符号的引用</span>
	<span class="token function">local</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局符号的引用</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.1.3 符号表和重定位节" dir="auto" class="heading" id="4.1.3_符号表和重定位节"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.1.3 符号表和重定位节</h5><div class="heading-children"><div class="el-p"><p dir="auto">编译器会将<strong>符号的定义</strong>存放到一个<strong>符号表(symbol table)</strong> 即我们之前看到的 .symtab 中。符号表是一个结构体数组，每个表项都包含着符号名、长度和位置等信息。在64位系统中，符号表的每一项有24字节大小。（32位系统位16字节）</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Elf64_Word    st_name<span class="token punctuation">;</span>  <span class="token comment">// 符号名(.strtab节中的偏移量)          4B</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> st_info<span class="token punctuation">;</span>  <span class="token comment">// 符号类型(低四位)和绑定(高四位)        1B</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> st_other<span class="token punctuation">;</span> <span class="token comment">// 符号可见性，通常为0                  1B</span>
    Elf64_Half    st_shndx<span class="token punctuation">;</span> <span class="token comment">// 符号对应目标所在的节，或其他情况       2B</span>
    Elf64_Addr    st_value<span class="token punctuation">;</span> <span class="token comment">// 在对应节中的偏移量，或虚拟地址         8B</span>
    Elf64_Xword   st_size<span class="token punctuation">;</span>  <span class="token comment">// 符号对应的字节数(函数大小或变量长度)    8B</span>
<span class="token punctuation">}</span> Elf64_Sym<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto"><strong>绑定属性(Bind)</strong>：局部符号(0)、全局符号(1)、弱符号(2)<br>
<strong>符号类型(Type)</strong>：未指定类型(0)、数据(1)、函数或可执行代码(2)、节(3)、文件名(4)。其他情况下，ABS表示不该被重定位、UND表示未定义、COM表示未初始化数据（.bss），此时，value表示对齐要求，size给出最小大小。（x64 下未初始化数据一般用 .bss 节号指代未初始化符号的类型）</p></div><div class="el-p"><p dir="auto">当我们查看符号表时，会发现我们的文件中额外多了两个符号。第一个符号（Num: 0）通常是<strong>占位符</strong>，之前我们查看节头表信息时也会发现第一个节头也是占位符。第二个符号（Num: 1）通常是源文件的名称。往后的符号表信息往往就是我们所<strong>定义或引用</strong>的符号了。</p></div><div class="el-p"><p dir="auto"><strong>符号的重定位信息</strong>会被编译器放到<strong>重定位节</strong>中。当符号解析完成且没有错误时，链接器会进行符号的重定位，即将<strong>符号的引用</strong>与一个确定的符号定义相关联。这一过程涉及符号表和重定位节之间的关联。在重定位阶段，多个代码节和数据节会合并成单独的代码段和数据段。链接器会计算每个定义的符号在虚拟地址空间中的绝对地址，并将引用处的地址修改为重定位后的地址信息。</p></div><div class="el-p"><p dir="auto">从符号对应的字节数我们能够看到，我们其实就是用<strong>符号</strong>来指代一段存储空间。当符号为变量名时，变量名指的就是其所占的静态数据区，当符号是函数名时，函数么指的其实就是代码所在的区域大小。</p></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.2 符号的特性" dir="auto" class="heading" id="4.2_符号的特性"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2 符号的特性</h4><div class="heading-children"><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.1 强符号和弱符号" dir="auto" class="heading" id="4.2.1_强符号和弱符号"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.1 强符号和弱符号</h5><div class="heading-children"><div class="el-p"><p dir="auto"><strong>全局符号的强弱特性</strong>：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">函数/初始化的全局变量是强符号</li>
<li data-line="1" dir="auto">未初始化的全局变量是弱符号（使用COMMON标记）</li>
</ul></div><div class="el-p"><p dir="auto"><strong>符号解析规则</strong>：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>不允许多个同名的强符号</strong><br>
强符号只能定义一次，否则链接错误</li>
<li data-line="2" dir="auto"><strong>有一个强符号和弱符号同名时，链接选择强符号</strong><br>
后面对弱符号的引用被解析为定义强定义符号</li>
<li data-line="4" dir="auto"><strong>如果多个弱符号同名，链接时任意选择一个</strong><br>
符号解析时只能有一个确定的定义（即每个符号仅占一处存储空间）。</li>
</ol></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">gcc <span class="token parameter variable">-c</span> main.c <span class="token parameter variable">-o</span> main.o -fno-common    <span class="token comment">#禁止弱符号</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">用上面的命令链接时，会告诉链接器在遇到多个弱定义的全局符号时输出一条警告信息。</p></div><div class="el-p"><p dir="auto">static变量是弱符号且只能在当前文件中使用（限制符号的可见性），所以即使在不同文件中定义有相同变量名的static变量或函数也不会发生冲突。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.2.2 多重定义符号的例子" dir="auto" class="heading" id="4.2.2_多重定义符号的例子"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.2.2 多重定义符号的例子</h5><div class="heading-children"><div class="el-p"><p dir="auto">多重定义全局变量会造成一些意想不到的错误，编译系统也可能不会发出警告。程序运行过程中可能就会发生意料之外的错误。随着软件不断做大，错误的根源也会变得愈发难找。</p></div><div class="el-p"><p dir="auto">我们下面看一下这个例子。在编译的时候，模块各自进行编译，在<code>main.c</code>中的变量<code>d</code>是<code>int</code>类型的变量，运算时的命令是整型运算命令。而<code>p1.c</code>中的变量<code>d</code>虽然是未初始化的全局变量（弱符号）。但是编译的时候并不知晓这个符号是否外部定义了。所以执行<code>d = 1.0;</code>的时候会将<code>d</code>作为浮点类型变量进行运算。</p></div><div class="el-p"><p dir="auto">链接的时候强弱符号的定义非常清晰，并不会发生冲突。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
d <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d = %d, x = %d\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">main.c</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">double</span> d<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">/*
	d = 1.0;会被汇编成浮点运算指令
	FLD1
	FSTPI &amp;d
*/</span>
	d <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">p1.c</p></div><div class="el-p"><p dir="auto">由于浮点数是8Bytes，int型变量只有4Bytes。当在<code>main()</code>函数中对<code>p1()</code>进行调用之后，写回结果时就会出现意想不到的结果。我们得到的变量<code>d</code>和变量<code>x</code>都不是我们想要的结果。</p></div><div class="el-p"><p dir="auto">要避免多重定义全局符号的问题。</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto">
<p><strong>尽量避免使用全局变量</strong> </p>
</li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<p>一定需要用的话，请按照以下规则使用：</p>
<ol>
<li data-line="3" dir="auto"><strong>尽量使用static本地变量</strong></li>
<li data-line="4" dir="auto"><strong>全局变量要赋初值</strong></li>
<li data-line="5" dir="auto"><strong>外部全局变量要使用extern</strong></li>
</ol>
</li>
</ul></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.3 静态链接" dir="auto" class="heading" id="4.3_静态链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3 静态链接</h4><div class="heading-children"><div class="el-p"><p dir="auto">我们前面链接不同文件生成可执行文件时，使用的链接命令就是把多个可重定位目标文件静态链接成一个可执行目标文件的过程。在这个过程中，静态链接的对象是<strong>多个可重定位目标文件</strong>和<strong>标准静态库</strong>。<mark>静态库文件就是 <code>.a</code> 文件，包含有多个 <code>.o</code> 模块</mark>。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.3.1 静态库" dir="auto" class="heading" id="4.3.1_静态库"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3.1 静态库</h5><div class="heading-children"><div class="el-p"><p dir="auto">为了增加代码的可重用，我们可以将一些函数进行分类并将分类好的函数存放在多个源文件中，编译后将这些 <code>.o</code> 可重定位目标文件进行<strong>归档</strong>。这样生成的文件就是<strong>静态库文件</strong>，也叫做<strong>归档文件(archive file)</strong>。常见的库函数模块有 <code>libc.a</code>(C标准库) 和 <code>libm.a</code>(C数学库)。</p></div><div class="el-p"><p dir="auto">当我们自定义静态库时，我们应当注意避免下面的<strong>两种极端</strong>：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>将所有的函数都放在一个源文件中</strong>
<ul>
<li data-line="1" dir="auto">这样会导致每次修改，都需要重新编译整个源文件（时间浪费）</li>
<li data-line="2" dir="auto">每次链接都会为可执行文件引入不必要的模块（空间上的浪费）</li>
</ul>
</li>
<li data-line="3" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>每个源文件只分配一个函数</strong>
<ul>
<li data-line="4" dir="auto">虽然效率提高了，但是模块太多，链接时会很繁琐</li>
</ul>
</li>
</ol></div><div class="el-p"><p dir="auto">在构建可执行文件时，只需指定库文件名，链接器会自动到库中寻找那些应用程序所用到的目标模块，并且只把用到的模块从库中拷贝出来。在GCC命令行中无需明显指定 <code>libc.a</code>，涉及到文件路径的查找问题。</p></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.3.2 静态库的创建" dir="auto" class="heading" id="4.3.2_静态库的创建"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3.2 静态库的创建</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们可以用归档器 <code>ar</code> 将 <code>.o</code> 目标文件模块进行归档为 <code>.a</code> 文件。归档器允许程序进行增量更新，如果我们重新编写了某一源程序或者想为静态库增加新的功能，我们只需要编译那一个文件并将其归档即可。</p></div><div class="el-p"><p dir="auto"><span alt="Pasted image 20240930154026.png" src="Pasted image 20240930154026.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240930154026.png" src="some-notes/pics/pasted-image-20240930154026.png"></span><br>
常用的标准库有：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><code>libc.a</code> ：C标准库，包含I/O、存储分配、信号处理、字符串处理、时间和日期、随机数生成、定点整数算术运算实现等的目标文件。约有8MB。</li>
<li data-line="2" dir="auto"><code>libm.a</code> ：C数学库，浮点数算术运算(如sin, cos, tan, log, exp, sqrt, …)，约1MB。</li>
</ul></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.3.3 创建自定义静态库" dir="auto" class="heading" id="4.3.3_创建自定义静态库"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.3.3 创建自定义静态库</h5><div class="heading-children"><div class="el-p"><p dir="auto">我们新创建两个模块（module1.c 和 module2.c），将这两个文件编译后归档成我们自己的静态库。</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// module1.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// module2.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">print_world</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">编译后我们用归档程序将这两个模块( .o )文件归档成一个归档文件( .a )文件。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">ar rcs mylib.a module1.o module2.o
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们可以用下面的命令来查看存档文件中有哪些目标文件：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded"><span class="token comment"># 查看xxxx.a中目标文件成员表，-t 表示table listing</span>
ar t xxxx.a <span class="token operator">|</span> <span class="token function">sort</span> 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="4.4 符号解析(Symbol Resolution)" dir="auto" class="heading" id="4.4_符号解析(Symbol_Resolution)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4 符号解析(Symbol Resolution)</h4><div class="heading-children"><div class="el-p"><p dir="auto">用我们创建的静态库，与一个main.o链接，最后会发生什么？</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">print_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">函数之间的调用关系很清楚，<code>main()</code>调用<code>print_hello()</code>，然后<code>print_hello()</code>调用C库中的<code>printf()</code>函数。如果链接后查看可执行文件的符号表，你会发现虽然我们链接的是整个 mylib.a ，但是符号表中确没有<code>print_world</code>。也就是说 module2.o 并没有走到“节的合并”这一步。这里面发生了什么就是我们符号解析要关注的。</p></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.4.1 符号解析的过程" dir="auto" class="heading" id="4.4.1_符号解析的过程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.1 符号解析的过程</h5><div class="heading-children"><div class="el-p"><p dir="auto">在符号解析开始之前，我们先给出三个符号解析需要用到的集合：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto"><strong>E</strong>：指的是将被合并组成可执行文件的所有目标文件的集合</li>
<li data-line="1" dir="auto"><strong>U</strong>：指的是当前所有未解析的引用符号的集合</li>
<li data-line="2" dir="auto"><strong>D</strong>：当前所有已定义符号的集合</li>
</ol></div><div class="el-p"><p dir="auto">当执行下面的命令时，链接器会先对所要链接的模块进行符号解析。从上面的字符说明不难明白，符号解析完成后U应当为空，否则就会链接失败。</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">$ gcc –o proc main.o mylib.a 
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">具体一点的<strong>符号解析过程</strong>如下：</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">最开始的时候E、U、D集合为空，然后扫描 main.o，发现定义的符号 <code>main</code> 和未定义的引用符号 <code>print_hello</code> 。随后将 <code>main</code> 加入D中、将 <code>print_hello</code> 加入U中并将main.o加入E中。</li>
<li data-line="1" dir="auto">接下来扫描mylib.a中的 .o 文件，发现 <code>print_hello</code> 的定义在 module.o 中，随后将符号 <code>print_hello</code> 从U转移到D中并将 module1.o 加入到E中。之后 <code>print_hello</code> 引入了一个未定义的符号 <code>printf</code> 到U里面。</li>
<li data-line="2" dir="auto">如果使用静态链接，链接器会扫描module2.o查找 <code>printf</code> 的符号定义，最后会从 libc.a 中一个一个查找 <code>printf</code> 的符号定义，过程和上面的相同。（这里我并没有使用静态标准库）</li>
<li data-line="3" dir="auto">最后，U为空，符号解析完毕。之后重定位的时候就只需要合并E中的文件就好了。</li>
</ol></div></div></div><div class="el-h5 heading-wrapper"><h5 data-heading="4.4.2 链接的顺序问题" dir="auto" class="heading" id="4.4.2_链接的顺序问题"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>4.4.2 链接的顺序问题</h5><div class="heading-children"><div class="el-p"><p dir="auto">由于符号解析是顺序进行的，这就为我们带来了一个问题，那就是链接时的顺序问题。如果我们把静态库文件放在前头会怎么样？</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">du@DVM:~/Desktop$ gcc <span class="token parameter variable">-o</span> proc mylib.a main.o
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">结果出错了，链接器告诉我们在main.o中引用的符号 <code>print_hello</code> 没有找到定义。还记得我们的函数调用顺序么？是这样的：<code>main -&gt; print_hello -&gt; printf</code>。由于 <code>main</code> 是程序的入口，其他文件在先于 <code>main</code> 链接时由于集合U为空，所以扫描这些文件无一会被加入集合E里。等到扫描main.o时就会出现找不到定义的问题。（因为后面没有能扫描的模块了）</p></div><div class="el-pre"><pre><code data-line="0">/usr/bin/ld: main.o: in function `main':
main.c:(.text+0xe): undefined reference to `print_hello'
collect2: error: ld returned 1 exit status
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">除了使用正确的顺序外，我们可以用下面亡羊补牢的命令简单的解决这种问题：</p></div><div class="el-pre"><pre class="language-sh" tabindex="0"><code data-line="0" class="language-sh is-loaded">du@DVM:~/Desktop$ gcc <span class="token parameter variable">-o</span> proc mylib.a main.o mylib.a
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">事实上，如果两个模块互相引用对方模块中定义的符号，我们就可以用上面这种形式解决<strong>符号的互相调用问题</strong>。假设调用关系如下：func.o → libx.a 和 liby.a 中的函数 libx.a → liby.a 同时 liby.a → libx.a 则以下命令行可行：</p></div><div class="el-pre"><pre><code data-line="0">gcc -static –o myfunc func.o libx.a liby.a libx.a
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="5. 重定位（链接操作步骤2）| IA-32" dir="auto" class="heading" id="5._重定位（链接操作步骤2）|_IA-32"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5. 重定位（链接操作步骤2）| IA-32</h3><div class="heading-children"><div class="el-p"><p dir="auto">链接由下面的四部分构成：<strong>符号解析</strong>、<strong>同节合并</strong>、<strong>确定地址</strong> 和 <strong>修改引用</strong>。我们上面已经做完了第一步，也就是符号解析过程，后面三步就属于<strong>重定位</strong>所关系的。</p></div><div class="el-p"><p dir="auto">符号解析完成之后，我们得到了E集合和D集合。之后在重定位的时候我们就会将<strong>E集合</strong>中所有的.o文件进行<strong>同节合并</strong>。然后再确定<strong>D集合</strong>中所有符号的虚拟空间地址，最后将合并的文件中所有引用处的符号替换为符号定义处的地址就完成了重定位。</p></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.1 重定位信息" dir="auto" class="heading" id="5.1_重定位信息"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1 重定位信息</h4><div class="heading-children"><div class="el-p"><p dir="auto">同节合并看起来很简单，合并之后确定符号定义的地址也不复杂，现在我们可能仍然困惑于引用处是如何替换地址的。在学习<strong>节头表</strong>时，我们看到<strong>重定位信息</strong>会被放到 .rela 的重定位节中（x64）。</p></div><div class="el-p"><p dir="auto">当汇编器进行汇编时，它一旦遇到符号的引用，就会初始化引用地址并生成一个<strong>重定位条目</strong>用于链接时的重定位。在IA32中，将对数据引用的重定位条目在 .rel_data 节中，对指令的重定位条目在 .rel_text 节中。</p></div><div class="el-p"><p dir="auto"><strong>IA-32</strong>中有两种最基本的重定位类型：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>R_386_32</strong>：绝对地址（一般多用于数据引用条目的重定位）</li>
<li data-line="1" dir="auto"><strong>R_386_PC32</strong>：PC相对地址（多用于指令引用条目的重定位）</li>
</ul></div><div class="el-p"><p dir="auto">在<strong>x64</strong>中重定位类型被分为：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>R_X86_64_PLT32</strong>：32位相对地址，用于调用外部函数，通过过程链接表（PLT）进行间接调用。</li>
<li data-line="1" dir="auto"><strong>R_X86_64_PC32</strong>：32位的相对地址，用于相对当前指令位置的偏移。</li>
</ul></div><div class="el-p"><p dir="auto">ELF中重定位条目的格式如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> offset<span class="token punctuation">;</span>
	<span class="token keyword">int</span> symbol<span class="token operator">:</span><span class="token number">24</span><span class="token punctuation">,</span> type<span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> ELF32_Rel<span class="token punctuation">;</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">我们用<code>readelf</code>读重定位条目信息：</p></div><div class="el-pre"><pre><code data-line="0">readelf -r xxxx.o
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-h5 heading-wrapper"><h5 data-heading="5.1.1 查看重定位条目信息(x64)" dir="auto" class="heading" id="5.1.1_查看重定位条目信息(x64)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.1.1 查看重定位条目信息(x64)</h5><div class="heading-children"><div class="el-p"><p dir="auto">这里我们先编写两个模块的程序，最后链接时将两个模块链接为一个可执行文件，这里我们对符号解析的过程不再赘述，我们两个单独的模块如下：</p></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// module1.c</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>         <span class="token comment">// Symbol 'i' is defined in the module</span>
<span class="token keyword">static</span> s_i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>   <span class="token comment">// Local defined symbol</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span>       <span class="token comment">// Symbol 'j' and 'k' is defined outside of the module</span>
<span class="token keyword">extern</span> <span class="token keyword">double</span> k<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    i <span class="token operator">=</span> j <span class="token operator">+</span> k<span class="token punctuation">;</span>      <span class="token comment">// In case global variables won't be optimized.</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">externFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ref to an extern function</span>
    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// ref to an internal defined function</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-pre"><pre class="language-c" tabindex="0"><code data-line="0" class="language-c is-loaded"><span class="token comment">// module2.c</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> k <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>

<span class="token function">externFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    j <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">编译汇编为可重定位目标文件后，我们先读取符号表：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -s module1.o

Symbol table '.symtab' contains 10 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS module1.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 s_i
     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 i
     5: 0000000000000000    47 FUNC    GLOBAL DEFAULT    1 test
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND j
     7: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND k
     8: 000000000000002f    35 FUNC    GLOBAL DEFAULT    1 main
     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND externFunc

du@DVM:~/Desktop$ readelf -s module2.o

Symbol table '.symtab' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS module2.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 j
     5: 0000000000000008     8 OBJECT  GLOBAL DEFAULT    3 k
     6: 0000000000000000    37 FUNC    GLOBAL DEFAULT    1 externFunc
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">读重定位条目。我们先看module1.o的重定位条目信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -r module1.o

Relocation section '.rela.text' at offset 0x240 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000500000002 R_X86_64_PC32     0000000000000000 j - 4
00000000001a  000600000002 R_X86_64_PC32     0000000000000000 k - 4
000000000028  000300000002 R_X86_64_PC32     0000000000000000 i - 4
00000000003d  000800000004 R_X86_64_PLT32    0000000000000000 externFunc - 4
000000000047  000400000004 R_X86_64_PLT32    0000000000000000 test - 4

Relocation section '.rela.eh_frame' at offset 0x2b8 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + 2f
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">下面是module2.o的重定位条目信息：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ readelf -r module2.o

Relocation section '.rela.text' at offset 0x1d0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000a  000400000002 R_X86_64_PC32     0000000000000000 j - 8
000000000016  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
00000000001e  000500000002 R_X86_64_PC32     0000000000000008 k - 4

Relocation section '.rela.eh_frame' at offset 0x218 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0

</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">反汇编后的代码如下：</p></div><div class="el-pre"><pre><code data-line="0">du@DVM:~/Desktop$ objdump -d module1.o

module1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;test&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	8b 05 00 00 00 00    	mov    0x0(%rip),%eax        # e &lt;test+0xe&gt;
   e:	66 0f ef c9          	pxor   %xmm1,%xmm1
  12:	f2 0f 2a c8          	cvtsi2sd %eax,%xmm1
  16:	f2 0f 10 05 00 00 00 	movsd  0x0(%rip),%xmm0        # 1e &lt;test+0x1e&gt;
  1d:	00 
  1e:	f2 0f 58 c1          	addsd  %xmm1,%xmm0
  22:	f2 0f 2c c0          	cvttsd2si %xmm0,%eax
  26:	89 05 00 00 00 00    	mov    %eax,0x0(%rip)        # 2c &lt;test+0x2c&gt;
  2c:	90                   	nop
  2d:	5d                   	pop    %rbp
  2e:	c3                   	ret    

000000000000002f &lt;main&gt;:
  2f:	f3 0f 1e fa          	endbr64 
  33:	55                   	push   %rbp
  34:	48 89 e5             	mov    %rsp,%rbp
  37:	b8 00 00 00 00       	mov    $0x0,%eax
  3c:	e8 00 00 00 00       	call   41 &lt;main+0x12&gt;
  41:	b8 00 00 00 00       	mov    $0x0,%eax
  46:	e8 00 00 00 00       	call   4b &lt;main+0x1c&gt;
  4b:	b8 00 00 00 00       	mov    $0x0,%eax
  50:	5d                   	pop    %rbp
  51:	c3                   	ret    
du@DVM:~/Desktop$ objdump -d module2.o

module2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;externFunc&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	c7 05 00 00 00 00 04 	movl   $0x4,0x0(%rip)        # 12 &lt;externFunc+0x12&gt;
   f:	00 00 00 
  12:	f2 0f 10 05 00 00 00 	movsd  0x0(%rip),%xmm0        # 1a &lt;externFunc+0x1a&gt;
  19:	00 
  1a:	f2 0f 11 05 00 00 00 	movsd  %xmm0,0x0(%rip)        # 22 &lt;externFunc+0x22&gt;
  21:	00 
  22:	90                   	nop
  23:	5d                   	pop    %rbp
  24:	c3                   	ret    
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div></div></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.2 PC相对地址重定位" dir="auto" class="heading" id="5.2_PC相对地址重定位"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.2 PC相对地址重定位</h4><div class="heading-children"><div class="el-p"><p dir="auto">在<strong>同节合并</strong>后，所有的数据节、代码节都会合并成数据段、代码段。我们在<code>.rela.eh_frame</code>中看到很多如下的重定位项，其实当同节合并后这些不同的&nbsp;<code>.text</code>&nbsp;节的虚存地址也就能够得到确认了。这时只要将节合并后的&nbsp;<code>.text</code>&nbsp;节首地址同后面的偏移量相加即可。</p></div><div class="el-pre"><pre><code data-line="0">Relocation section '.rela.eh_frame' at offset 0x2b8 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0
000000000040  000200000002 R_X86_64_PC32     0000000000000000 .text + 2f
</code><button class="copy-code-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-copy"><rect x="8" y="8" width="14" height="14" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></button></pre></div><div class="el-p"><p dir="auto">一般PC相对地址的重定位多用于函数符号的重定位上。因为函数都是作为代码段映射到虚拟内存上的。如果引用符号在本模块里定义了，我们就只需要像上面那样计算出偏移量即可知道函数符号的定义在哪里了。</p></div></div></div><div class="el-h4 heading-wrapper"><h4 data-heading="5.3 绝对地址重定位" dir="auto" class="heading" id="5.3_绝对地址重定位"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>5.3 绝对地址重定位</h4><div class="heading-children"><div class="el-p"><p dir="auto">同样，在所有的同节合并后，当我们定义和引用数据符号时，由于它们不在同一个段内，我们往往直接将数据的<strong>绝对地址</strong>填入数据符号的引用处。在符号引用时，能够直接在数据段读取数据。这时，相对地址的方式就显得繁琐。</p></div></div></div></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="6. 可执行文件的加载" dir="auto" class="heading" id="6._可执行文件的加载"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>6. 可执行文件的加载</h3><div class="heading-children"></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="7.动态链接" dir="auto" class="heading" id="7.动态链接"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>7.动态链接</h3><div class="heading-children"></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="二：从ELF到进程" dir="auto" class="heading" id="二：从ELF到进程"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>二：从ELF到进程</h2><div class="heading-children"><div class="el-h3 heading-wrapper"><h3 data-heading="0. 什么是加载器" dir="auto" class="heading" id="0._什么是加载器"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>0. 什么是加载器</h3><div class="heading-children"></div></div><div class="el-h3 heading-wrapper"><h3 data-heading="1. 进程内存布局" dir="auto" class="heading" id="1._进程内存布局"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. 进程内存布局</h3><div class="heading-children"><div class="el-p"><p dir="auto">在不考虑内核区内存布局的情况下，一般而言用户区的进程内存布局从低地址到高地址分别是代码段、数据段、堆和栈。它们具体的作用如下：</p></div><div class="el-ul"><ul>
<li data-line="0" dir="auto"><strong>代码段(Text Segment)</strong>：存放二进制机器代码程序的执行代码（只读/执行）</li>
<li data-line="1" dir="auto"><strong>数据段(Data Segment)</strong>：初始化的全局变量和静态变量（读写）</li>
<li data-line="2" dir="auto"><strong>BSS段(Block Started by Symbol)</strong>：未初始化的全局和静态变量（读写）</li>
<li data-line="3" dir="auto"><strong>只读数据段(Read-Only Data Segment, rodata)</strong>：不可修改的数据（只读）字符串常量如：char* local_d = "hi,world";</li>
<li data-line="4" dir="auto"><strong>堆(Heap)</strong>：动态内存分配的区域（使用malloc）</li>
<li data-line="5" dir="auto"><strong>栈(Stack)</strong>：由于存放函数的局部变量、调用返回地址等<br>
<span alt="Pasted image 20240916181307.png" src="Pasted image 20240916181307.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240916181307.png" src="some-notes/pics/pasted-image-20240916181307.png"></span></li>
</ul></div></div></div></div></div><div class="el-h2 heading-wrapper"><h2 data-heading="三：进程的异常、中断和结束" dir="auto" class="heading" id="三：进程的异常、中断和结束"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>三：进程的异常、中断和结束</h2><div class="heading-children"><div class="mod-footer mod-ui"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#进程的一生——从出生到死亡 (Abandoned)"><div class="tree-item-contents heading-link" heading-name="进程的一生——从出生到死亡 (Abandoned)"><span class="tree-item-title">进程的一生——从出生到死亡 (Abandoned)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#〇：先导知识"><div class="tree-item-contents heading-link" heading-name="〇：先导知识"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">〇：先导知识</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1._存储程序的工作方式"><div class="tree-item-contents heading-link" heading-name="1. 存储程序的工作方式"><span class="tree-item-title">1. 
存储程序的工作方式
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2._计算机的层层抽象"><div class="tree-item-contents heading-link" heading-name="2. 计算机的层层抽象"><span class="tree-item-title">2. 
计算机的层层抽象
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3._堆和栈"><div class="tree-item-contents heading-link" heading-name="3. 堆和栈"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3. 
堆和栈
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.1_栈(Stack)"><div class="tree-item-contents heading-link" heading-name="3.1 栈(Stack)"><span class="tree-item-title">3.1 栈(Stack)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.2_堆(Heap)"><div class="tree-item-contents heading-link" heading-name="3.2 堆(Heap)"><span class="tree-item-title">3.2 堆(Heap)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4._x86汇编结构"><div class="tree-item-contents heading-link" heading-name="4. x86汇编结构"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4. 
x86汇编结构
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.1_伪指令"><div class="tree-item-contents heading-link" heading-name="4.1 伪指令"><span class="tree-item-title">4.1 伪指令</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.2_标号"><div class="tree-item-contents heading-link" heading-name="4.2 标号"><span class="tree-item-title">4.2 标号</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.3_汇编指令"><div class="tree-item-contents heading-link" heading-name="4.3 汇编指令"><span class="tree-item-title">4.3 汇编指令</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5._C语言的机器级表示"><div class="tree-item-contents heading-link" heading-name="5. C语言的机器级表示"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5. 
C语言的机器级表示
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5.1_x86-32位机器的过程调用"><div class="tree-item-contents heading-link" heading-name="5.1 x86-32位机器的过程调用"><span class="tree-item-title">5.1 x86-32位机器的过程调用</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#6._复杂数据类型的机器级表示"><div class="tree-item-contents heading-link" heading-name="6. 复杂数据类型的机器级表示"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">6. 
复杂数据类型的机器级表示
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#6.1_数组和指针类型的分配和访问"><div class="tree-item-contents heading-link" heading-name="6.1 数组和指针类型的分配和访问"><span class="tree-item-title">6.1 数组和指针类型的分配和访问</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#7._x86-64_保存参数规则"><div class="tree-item-contents heading-link" heading-name="7. x86-64 保存参数规则"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">7. 
x86-64 保存参数规则
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#7.1_寄存器传递和栈传递"><div class="tree-item-contents heading-link" heading-name="7.1 寄存器传递和栈传递"><span class="tree-item-title">7.1 寄存器传递和栈传递</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#7.2_性能优化"><div class="tree-item-contents heading-link" heading-name="7.2 性能优化"><span class="tree-item-title">7.2 性能优化</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#一：从代码到ELF"><div class="tree-item-contents heading-link" heading-name="一：从代码到ELF"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">一：从代码到ELF</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1._C代码到二进制目标程序"><div class="tree-item-contents heading-link" heading-name="1. C代码到二进制目标程序"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">1. 
C代码到二进制目标程序
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.1_C程序阶段"><div class="tree-item-contents heading-link" heading-name="1.1 C程序阶段"><span class="tree-item-title">1.1 C程序阶段</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.2_预处理阶段(Preprocessor)"><div class="tree-item-contents heading-link" heading-name="1.2 预处理阶段(Preprocessor)"><span class="tree-item-title">1.2 预处理阶段(Preprocessor)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.3_编译阶段"><div class="tree-item-contents heading-link" heading-name="1.3 编译阶段"><span class="tree-item-title">1.3 编译阶段</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.4_汇编阶段"><div class="tree-item-contents heading-link" heading-name="1.4 汇编阶段"><span class="tree-item-title">1.4 汇编阶段</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.5_链接"><div class="tree-item-contents heading-link" heading-name="1.5 链接"><span class="tree-item-title">1.5 链接</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1.6_链接器的由来"><div class="tree-item-contents heading-link" heading-name="1.6 链接器的由来"><span class="tree-item-title">1.6 链接器的由来</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2._三类目标文件"><div class="tree-item-contents heading-link" heading-name="2. 三类目标文件"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">2. 
三类目标文件
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2.1_可重定位目标文件（.o）"><div class="tree-item-contents heading-link" heading-name="2.1 可重定位目标文件（.o）"><span class="tree-item-title">2.1 可重定位目标文件（.o）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2.2_可执行目标文件（默认a.out）"><div class="tree-item-contents heading-link" heading-name="2.2 可执行目标文件（默认a.out）"><span class="tree-item-title">2.2 可执行目标文件（默认a.out）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2.3_共享库文件（.so）"><div class="tree-item-contents heading-link" heading-name="2.3 共享库文件（.so）"><span class="tree-item-title">2.3 共享库文件（.so）</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#2.4_目标文件的格式"><div class="tree-item-contents heading-link" heading-name="2.4 目标文件的格式"><span class="tree-item-title">2.4 目标文件的格式</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3._ELF的两种视图（x64）"><div class="tree-item-contents heading-link" heading-name="3. ELF的两种视图（x64）"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3. 
ELF的两种视图（x64）
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.1_链接视图——可重定位目标文件(Relocatable_Object_File)"><div class="tree-item-contents heading-link" heading-name="3.1 链接视图——可重定位目标文件(Relocatable Object File)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.1 链接视图——可重定位目标文件(Relocatable Object File)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.1.1_ELF头(ELF_Header)"><div class="tree-item-contents heading-link" heading-name="3.1.1 ELF头(ELF Header)"><span class="tree-item-title">3.1.1 ELF头(ELF Header)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.1.2_节头表"><div class="tree-item-contents heading-link" heading-name="3.1.2 节头表"><span class="tree-item-title">3.1.2 节头表</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#番外：`switch`_jump_table"><div class="tree-item-contents heading-link" heading-name="番外：`switch` jump table"><span class="tree-item-title">番外：<code>switch</code> jump table</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.2_执行视图——可执行目标文件(Executable_Object_File)"><div class="tree-item-contents heading-link" heading-name="3.2 执行视图——可执行目标文件(Executable Object File)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">3.2 执行视图——可执行目标文件(Executable Object File)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.2.1_ELF头"><div class="tree-item-contents heading-link" heading-name="3.2.1 ELF头"><span class="tree-item-title">3.2.1 ELF头</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.2.2_程序头表(Segment_Header_Table)"><div class="tree-item-contents heading-link" heading-name="3.2.2 程序头表(Segment Header Table)"><span class="tree-item-title">3.2.2 程序头表(Segment Header Table)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#3.2.3_存储器映像"><div class="tree-item-contents heading-link" heading-name="3.2.3 存储器映像"><span class="tree-item-title">3.2.3 存储器映像</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4._符号及符号解析（链接操作步骤1）"><div class="tree-item-contents heading-link" heading-name="4. 符号及符号解析（链接操作步骤1）"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4. 
符号及符号解析（链接操作步骤1）
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.1_符号及符号表"><div class="tree-item-contents heading-link" heading-name="4.1 符号及符号表"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.1 符号及符号表</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.1.1_链接符号的类型"><div class="tree-item-contents heading-link" heading-name="4.1.1 链接符号的类型"><span class="tree-item-title">4.1.1 链接符号的类型</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.1.2_符号的定义和引用"><div class="tree-item-contents heading-link" heading-name="4.1.2 符号的定义和引用"><span class="tree-item-title">4.1.2 符号的定义和引用</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.1.3_符号表和重定位节"><div class="tree-item-contents heading-link" heading-name="4.1.3 符号表和重定位节"><span class="tree-item-title">4.1.3 符号表和重定位节</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.2_符号的特性"><div class="tree-item-contents heading-link" heading-name="4.2 符号的特性"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.2 符号的特性</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.2.1_强符号和弱符号"><div class="tree-item-contents heading-link" heading-name="4.2.1 强符号和弱符号"><span class="tree-item-title">4.2.1 强符号和弱符号</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.2.2_多重定义符号的例子"><div class="tree-item-contents heading-link" heading-name="4.2.2 多重定义符号的例子"><span class="tree-item-title">4.2.2 多重定义符号的例子</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.3_静态链接"><div class="tree-item-contents heading-link" heading-name="4.3 静态链接"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.3 静态链接</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.3.1_静态库"><div class="tree-item-contents heading-link" heading-name="4.3.1 静态库"><span class="tree-item-title">4.3.1 静态库</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.3.2_静态库的创建"><div class="tree-item-contents heading-link" heading-name="4.3.2 静态库的创建"><span class="tree-item-title">4.3.2 静态库的创建</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.3.3_创建自定义静态库"><div class="tree-item-contents heading-link" heading-name="4.3.3 创建自定义静态库"><span class="tree-item-title">4.3.3 创建自定义静态库</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.4_符号解析(Symbol_Resolution)"><div class="tree-item-contents heading-link" heading-name="4.4 符号解析(Symbol Resolution)"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">4.4 符号解析(Symbol Resolution)</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.4.1_符号解析的过程"><div class="tree-item-contents heading-link" heading-name="4.4.1 符号解析的过程"><span class="tree-item-title">4.4.1 符号解析的过程</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#4.4.2_链接的顺序问题"><div class="tree-item-contents heading-link" heading-name="4.4.2 链接的顺序问题"><span class="tree-item-title">4.4.2 链接的顺序问题</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5._重定位（链接操作步骤2）|_IA-32"><div class="tree-item-contents heading-link" heading-name="5. 重定位（链接操作步骤2）| IA-32"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5. 
重定位（链接操作步骤2）| IA-32
</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5.1_重定位信息"><div class="tree-item-contents heading-link" heading-name="5.1 重定位信息"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">5.1 重定位信息</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="5"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5.1.1_查看重定位条目信息(x64)"><div class="tree-item-contents heading-link" heading-name="5.1.1 查看重定位条目信息(x64)"><span class="tree-item-title">5.1.1 查看重定位条目信息(x64)</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5.2_PC相对地址重定位"><div class="tree-item-contents heading-link" heading-name="5.2 PC相对地址重定位"><span class="tree-item-title">5.2 PC相对地址重定位</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#5.3_绝对地址重定位"><div class="tree-item-contents heading-link" heading-name="5.3 绝对地址重定位"><span class="tree-item-title">5.3 绝对地址重定位</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#6._可执行文件的加载"><div class="tree-item-contents heading-link" heading-name="6. 可执行文件的加载"><span class="tree-item-title">6. 
可执行文件的加载
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#7.动态链接"><div class="tree-item-contents heading-link" heading-name="7.动态链接"><span class="tree-item-title">7.动态链接</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#二：从ELF到进程"><div class="tree-item-contents heading-link" heading-name="二：从ELF到进程"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">二：从ELF到进程</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#0._什么是加载器"><div class="tree-item-contents heading-link" heading-name="0. 什么是加载器"><span class="tree-item-title">0. 
什么是加载器
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#1._进程内存布局"><div class="tree-item-contents heading-link" heading-name="1. 进程内存布局"><span class="tree-item-title">1. 
进程内存布局
</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="some-notes\进程的一生——从出生到死亡-(abandoned).html#三：进程的异常、中断和结束"><div class="tree-item-contents heading-link" heading-name="三：进程的异常、中断和结束"><span class="tree-item-title">三：进程的异常、中断和结束</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>